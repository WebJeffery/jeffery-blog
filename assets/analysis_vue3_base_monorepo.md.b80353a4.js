import{_ as s,o as n,c as a,Q as e}from"./chunks/framework.69210375.js";const l="/jeffery-blog/assets/monorepo.72a15d33.png",p="/jeffery-blog/assets/volta.fd37a42f.png",F=JSON.parse('{"title":"monorepo 代码管理策略","description":"","frontmatter":{},"headers":[],"relativePath":"analysis/vue3/base/monorepo.md","lastUpdated":1711638490000}'),o={name:"analysis/vue3/base/monorepo.md"},r=e('<h1 id="monorepo-代码管理策略" tabindex="-1">monorepo 代码管理策略 <a class="header-anchor" href="#monorepo-代码管理策略" aria-label="Permalink to &quot;monorepo 代码管理策略&quot;">​</a></h1><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>Vue3 采用 <code>monorepo</code> 的方式进行项目代码管理。在本文中，会从以下几个方面介绍</p><ul><li><code>monorepo</code> 是什么，有哪些优缺点？了解其技术应用背景、解决技术痛点</li><li>探讨几种实现 <code>monorepo</code> 策略的具体方案？根据项目场景选择适合的技术方案</li><li><code>Vue3</code> 源代码 monrepo 实现，了解其实现细节。</li><li>搭建 monorepo 真实项目</li></ul><h2 id="monorepo-是什么" tabindex="-1">monorepo 是什么？ <a class="header-anchor" href="#monorepo-是什么" aria-label="Permalink to &quot;monorepo 是什么？&quot;">​</a></h2><p>Monorepo（单一代码仓库）是一种代码管理策略，用于将多个相关项目存储在同一个代码仓库中。相比于传统的多个独立代码仓库，Monorepo 的目标是提高代码的可共享性、可重用性和协作效率</p><p>那么，采取一种新的策略，肯定是因为该策略具备一些优点。从下面这张图中，可以看出，项目代码的管理策略是在实践中不断发展变化的。</p><p><img src="'+l+`" alt="monorepo"></p><ul><li>第一阶段 monolith：一开始不管多少代码都放在一个项目中进行管理，随着时间推移，代码量越来越多，每一次构建都会花费很长时间，代码耦合度强，可维护性差，代码冲突频繁等各种问题逐渐显现且愈加严重。</li><li>第二阶段 multi repo：将业务相对独立的功能拆分不同的项目进行维护，这样确实解决了一些问题，比如项目自治，可维护性变强。不过也存在一些问题，例如代码不能共享，联调困难，每个项目都要重复安装，版本管理等问题</li><li>第三阶段 monorepo：由于存在以上种种问题，聪明的工程师想出的一种代码管理策略，接下来就分析 monorepo 有什么优势和劣势。</li></ul><h2 id="monorepo-优劣势" tabindex="-1">monorepo 优劣势？ <a class="header-anchor" href="#monorepo-优劣势" aria-label="Permalink to &quot;monorepo 优劣势？&quot;">​</a></h2><p>通过 monorepo 策略管理的代码，目录结构看起来会是下面这样，将不同项目的目录汇集到一个目录之下</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">.</span></span>
<span class="line"><span style="color:#babed8;">├── package.json</span></span>
<span class="line"><span style="color:#babed8;">└── packages/ # 这里将存放所有子 repo 目录</span></span>
<span class="line"><span style="color:#babed8;">    ├── project_1/</span></span>
<span class="line"><span style="color:#babed8;">    │   ├── index.js</span></span>
<span class="line"><span style="color:#babed8;">    │   ├── node_modules/</span></span>
<span class="line"><span style="color:#babed8;">    │   └── package.json</span></span>
<span class="line"><span style="color:#babed8;">    ├── project_2/</span></span>
<span class="line"><span style="color:#babed8;">    │   ├── index.js</span></span>
<span class="line"><span style="color:#babed8;">    │   ├── node_module/</span></span>
<span class="line"><span style="color:#babed8;">    │   └── package.json</span></span>
<span class="line"><span style="color:#babed8;">    ...</span></span>
<span class="line"><span style="color:#babed8;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h3 id="monorepo-优势" tabindex="-1">monorepo 优势 <a class="header-anchor" href="#monorepo-优势" aria-label="Permalink to &quot;monorepo 优势&quot;">​</a></h3><p>monorepo 在代码管理上优势：</p><ol><li><strong>代码重用变得容易</strong>：由于所有的项目代码都集中于一个代码仓库，很容易抽离出各个项目共用的业务组件或工具，在代码内引用；</li><li><strong>依赖管理变得简单</strong>：由于项目之间的引用路径内化在同一个仓库之中，容易追踪当某个项目的代码修改后，会影响到其他哪些项目。通过使用 lerna 一些工具，可以做到版本依赖管理和版本号自动升级；</li><li><strong>统一构建和测试</strong>：使用统一的构建配置和流程，减少配置和维护的工作量。此外，可以在整个 Monorepo 中执行统一的测试流程，确保所有项目质量和稳定性。</li><li><strong>便于协作和开发</strong>：在一个代码仓库中，更容易地浏览、搜索和理解整个项目的代码，便于团队成员之间的协作。Monorepo 还可以促进跨项目的合作和知识共享，提高团队的整体效率和协同能力。</li><li><strong>更少的内存</strong>：多个项目引用相同的依赖，只需要安装一份依赖即可，减少重复安装节省内存空间</li></ol><h3 id="monorepo-劣势" tabindex="-1">monorepo 劣势 <a class="header-anchor" href="#monorepo-劣势" aria-label="Permalink to &quot;monorepo 劣势&quot;">​</a></h3><p>其实，优势和劣势都是相对的，在一定程度上，如果不遵循约束和规范，优势也会转换为劣势，所以在设计上要更加严谨，这也是学习源码优秀设计的原因之一。</p><ol><li><strong>新员工的学习成本变高</strong>：不同于一个项目一个代码仓库这种模式下，在 monorepo 策略下，新人可能不得不花更多精力来理清各个代码仓库之间的相互逻辑，当然这个成本可以通过新人文档的方式来解决，但编写和维护文档也需要精力成本；</li><li><strong>团队协作和权限管理变复杂</strong>：在 Monorepo 中，团队成员需要共享同一个代码仓库，并且对所有模块都具有相同的权限级别。这可能会导致一些团队成员对整个项目的代码和资源具有过多的访问权限，增加了潜在的安全风险。</li><li><strong>代码耦合和影响范围</strong>：在 Monorepo 中，一个模块的更改可能会对其他模块产生意外的影响，增加了代码耦合性，并可能导致意外的副作用。</li></ol><h3 id="如何取舍" tabindex="-1">如何取舍？ <a class="header-anchor" href="#如何取舍" aria-label="Permalink to &quot;如何取舍？&quot;">​</a></h3><p>看了之后是不是在犹豫要不要使用 monorepo 管理代码了，别灰心，软件开发领域从来没有完美一说，需要根据组织和特定的项目来选择。可以把 monorepo 策略实践在「项目」这个级别，即从逻辑上确定项目与项目之间的关联性，然后把相关联的项目整合在同一个仓库下。</p><p>通常情况下，我们不会有太多相互关联的项目，这意味着我们能够免费得到 monorepo 策略的所有好处，好好利用放大它的优点，同时通过制定规范、项目文档管理规范补齐它的短板。</p><h2 id="monorepo-实现方案" tabindex="-1">monorepo 实现方案 <a class="header-anchor" href="#monorepo-实现方案" aria-label="Permalink to &quot;monorepo 实现方案&quot;">​</a></h2><p>重新强调一下，<code>monorepo</code> 它是一个策略，是一种思想，而不是一个具体的工具，不要将它和 <code>lenrn</code>、 <code>yarn workspace</code> 划上等号，实现这个策略可以有多种方案，那么介绍以下 3 种方案。</p><h3 id="lerna" tabindex="-1">lerna <a class="header-anchor" href="#lerna" aria-label="Permalink to &quot;lerna&quot;">​</a></h3><p><a href="https://lerna.js.org/" target="_blank" rel="noreferrer">Lerna</a> 是为 monorepo 而生的工具，在项目中配置 lerna</p><p>1、项目根目录安装 <code>lenrna</code> 包 <code>npm install lerna -D</code>，使用 <code>npx lerna init</code> 初始化，于是根目录新增一个 <code>lerna.json</code> 文件，默认内容为：</p><div class="language-json line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">packages</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">[</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">packages/*</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">],</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#676E95;font-style:italic;">// 默认 npm 省略</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">npmClient</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">npm</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>lerna 默认工作目录是 <code>packages</code>，lerna 默认使用的是 <code>npm</code>，省略了配置项 <code>&quot;npmClient&quot;: &quot;npm&quot;</code></p><p>2、在 packages 目录创建多个独立的子包，分别初始化 <code>package.json</code> 文件，如下</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">.</span></span>
<span class="line"><span style="color:#babed8;">├── package.json</span></span>
<span class="line"><span style="color:#babed8;">└── packages/ # 这里将存放所有子 repo 目录</span></span>
<span class="line"><span style="color:#babed8;">    ├── project_1/</span></span>
<span class="line"><span style="color:#babed8;">    │   ├── index.js</span></span>
<span class="line"><span style="color:#babed8;">    │   ├── node_modules/</span></span>
<span class="line"><span style="color:#babed8;">    │   └── package.json</span></span>
<span class="line"><span style="color:#babed8;">    ├── project_2/</span></span>
<span class="line"><span style="color:#babed8;">    │   ├── index.js</span></span>
<span class="line"><span style="color:#babed8;">    │   ├── node_module/</span></span>
<span class="line"><span style="color:#babed8;">    │   └── package.json</span></span>
<span class="line"><span style="color:#babed8;">    ...</span></span>
<span class="line"><span style="color:#babed8;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>3、在根项目 <code>package.json</code> 配置 <code>scripts</code> 运行命令，然后执行 <code>npm install</code>，安装 packages 各个子包依赖</p><div class="language-json line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">scripts</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#FFCB6B;">bootstrap</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">lerna bootstrap</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="lerna-如何工作" tabindex="-1">lerna 如何工作 <a class="header-anchor" href="#lerna-如何工作" aria-label="Permalink to &quot;lerna 如何工作&quot;">​</a></h4><p>1、<code>lerna</code> 有两种工作模式：模式固定模式(Fixed)、独立模式(Independent)，使用 <code>version</code> 关键字表示</p><div class="language-json line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">packages</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">[</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">packages/*</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">],</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">npmClient</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">npm</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">version</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">independent</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li><p><code>independent</code> 独立模式：将每个子项目的版本号看作是相互独立的。当某个子项目代码更新后，运行 <code>lerna publish</code> 时，关联的子项目版本号<strong>不会自动升级</strong></p></li><li><p><code>Fixed</code> 固定模式：相反，使用固定模式时，任一子项目的代码变动，都会导致所有子项目的版本号基于当前指定的版本号升级。</p></li></ul><p>2、Lerna 自动检测发布，判断逻辑</p><ol><li>校验本地是否有没有被 commit 内容？</li><li>判断当前的分支是否正常？</li><li>判断当前分支是否在 remote 存在？</li><li>判断当前分支是否在 lerna.json 允许的 allowBranch 设置之中？</li><li>判断当前分支提交是否落后于 remote</li></ol><h4 id="lerna-常用命令" tabindex="-1">lerna 常用命令 <a class="header-anchor" href="#lerna-常用命令" aria-label="Permalink to &quot;lerna 常用命令&quot;">​</a></h4><p>Lerna 提供了很多 CLI 命令以满足我们的各种需求，但根据 2/8 法则，应该首先关注以下这些命令</p><ul><li>lerna run：会像执行一个 for 循环一样，在所有子项目中执行 npm script 脚本，并且，它会非常智能的识别依赖关系，并从根依赖开始执行命令；</li><li>lerna exec：像 lerna run 一样，会按照依赖顺序执行命令，不同的是，它可以执行任何命令，例如 shell 脚本；</li><li>lerna publish：发布代码有变动的 package，因此首先需要在使用 Lerna 前使用 git commit 命令提交代码，好让 Lerna 有一个 baseline；</li><li>lerna add：将本地或远程的包作为依赖添加至当前的 monorepo 仓库中，该命令让 Lerna 可以识别并追踪包之间的依赖关系，因此非常重要；</li><li><code>--concurrency &lt;number&gt;</code>：参数可以使 Lerna 利用计算机上的多个核心，并发运行，从而提升构建速度；</li><li><code>--scope &#39;@mono/{pkg1,pkg2}&#39;</code>：--scope 参数可以指定 Lerna 命令的运行环境，通过使用该参数，Lerna 将不再是一把梭的在所有仓库中执行命令，而是可以精准地在我们所指定的仓库中执行命令，并且还支持示例中的模版语法；</li><li><code>--stream</code>：该参数可使我们查看 Lerna 运行时的命令执行信息</li></ul><h3 id="yarn-workspaces" tabindex="-1">yarn workspaces <a class="header-anchor" href="#yarn-workspaces" aria-label="Permalink to &quot;yarn workspaces&quot;">​</a></h3><p><code>yarn workspaces</code> 天然自带 <code>monorepo</code> 能力。虽然没有专用的配置文件，但需要在项目根路径下 <code>package.json</code> 文件中做些配置，例如</p><div class="language-json line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">workspaces</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">[</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">packages/*</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>执行 <code>yarn install</code>，各个子项目会安装各自的依赖项，配置相对简单</p><p><strong>将 lerna + yarn workspace 结合实现 monorepo</strong></p><p>在这里 <code>lerna</code> 和 <code>yarn workspace</code> 角色分明，依赖管理的工作交给 <code>yarn worksapces</code>，利用 <code>lerna</code> 提供的一些工具命令来优化对 monorepo 类型项目的管理，比如启动不同的项目，利用 lerna 选择性的执行某些命令。同时 lerna 还提供了诸如版本发布等可以优化开发体验的工具</p><h3 id="pnpm-workspace" tabindex="-1">pnpm workspace <a class="header-anchor" href="#pnpm-workspace" aria-label="Permalink to &quot;pnpm workspace&quot;">​</a></h3><p><code>pnpm</code> 作为一个比较新的工具，相比于 <code>yarn</code> 安装速度更快，占用内存更少，它也和 yarn 一样，提供了工作空间实现 <code>monorepo</code></p><p><code>pnpm</code> 配置 monorepo，在项目根目录下新建 <code>pnpm-workspace.yaml</code> 文件</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">  packages:</span></span>
<span class="line"><span style="color:#babed8;">  - &#39;packages/*&#39;</span></span>
<span class="line"><span style="color:#babed8;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>通过上面简单的配置，pnpm 就搭建了 <code>monorepo</code> 环境，实现起来相当简单。总的来说，小项目不需要 monorepo，在大项目中也许需要将业务和组件库代码抽离，需要考虑利用这种手段，实现多个项目的代码和配置共享</p><p>跟 <code>yarn</code> 一样，<code>pnpm</code> 可以和 <code>lerna</code> 一起工作 。接下来介绍 Vue3 中 pnpm 实现 monorpo</p><h2 id="vue3-实现-monorepo" tabindex="-1">Vue3 实现 monorepo <a class="header-anchor" href="#vue3-实现-monorepo" aria-label="Permalink to &quot;Vue3 实现 monorepo&quot;">​</a></h2><p>在 Vue3 项目 <code>package.json</code> 写明包管理器使用 <code>pnpm</code>，node 版本 <code>18+</code>，推荐全局安装 <code>npm i -g pnpm</code></p><div class="language-json line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">packageManager</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">pnpm@8.15.0</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">engines</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#FFCB6B;">node</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">&gt;=18.12.0</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><code>pnpm-workspace.yaml</code> 配置文件告诉 pnpm 包管理目录是 <code>packages</code></p><div class="language-json line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#BABED8;">packages:</span></span>
<span class="line"><span style="color:#BABED8;">  - &#39;packages</span><span style="color:#676E95;font-style:italic;">/*&#39;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>安装项目依赖 <code>pnpm install</code>，在根目录和 packages 子目录下分别安装依赖包，运行 <code>pnpm dev</code> 打包 vue 代码</p><p>可以看到 在 <code>packages</code> 目录有十几个项目，Vue3 将内部实现的部分抽象成了一个个模块，每个模块都有自己的类型声明、单元测试、构建测试流程， 打包独立 <code>npm</code> 发布，这样设计便于维护、发版和扩展。</p><p>同时，独立的子项目模块不仅仅可以在 vue3 中使用，例如 <code>reactivity</code> 响应式这个模块，安装 <code>npm i @vue/reactivity</code> 可以在 js、react 其他项目中使用</p><h2 id="大型应用构建-monorepo-方案" tabindex="-1">大型应用构建 Monorepo 方案 <a class="header-anchor" href="#大型应用构建-monorepo-方案" aria-label="Permalink to &quot;大型应用构建 Monorepo 方案&quot;">​</a></h2><p>构建大型应用的方案有 <a href="https://turbo.build/" target="_blank" rel="noreferrer">Turborepo</a>、<a href="https://rushstack.io/" target="_blank" rel="noreferrer">Rush</a>、<a href="https://nx.app/company" target="_blank" rel="noreferrer">Nx</a></p><h3 id="turborepo" tabindex="-1">Turborepo <a class="header-anchor" href="#turborepo" aria-label="Permalink to &quot;Turborepo&quot;">​</a></h3><p><a href="https://turbo.build/" target="_blank" rel="noreferrer">Turborepo</a> 是 Vercel 团队开源的高性能构建代码仓库系统，允许开发者使用不同的构建系统。</p><p>构建加速思路：</p><ul><li>Multiple Running Task：构建任务并行进行，构建顺序交给开发者配置</li><li>Cache、Remote Cache：通过缓存 及 远程缓存，减少构建时间</li></ul><h3 id="rush" tabindex="-1">Rush <a class="header-anchor" href="#rush" aria-label="Permalink to &quot;Rush&quot;">​</a></h3><ul><li><p>解决了幽灵依赖：将项目所有依赖都安装到 Repo 根目录的 <code>common/temp</code> 下，通过软链接到各项目，保证了 <code>node_modules</code> 下依赖与 <code>package.json</code> 一致</p></li><li><p>并行构建：Rush 支持并行构建多个项目，提高了构建效率</p></li><li><p>插件系统：Rush 提供了丰富的插件系统，可以扩展其功能，满足不同的需求，<a href="https://rushstack.io/zh-cn/pages/heft/core_plugins/" target="_blank" rel="noreferrer">具体参考</a></p></li><li><p>项目发布，ChangeLog 支持友好：自动修改项目版本号，自动生成 ChangeLog</p></li></ul><h3 id="nx" tabindex="-1">Nx <a class="header-anchor" href="#nx" aria-label="Permalink to &quot;Nx&quot;">​</a></h3><p><a href="https://nx.app/company" target="_blank" rel="noreferrer">Nx</a> 是 Nrwl 团队开发的，同时在维护 Lerna，目前 Nx 可以与 Learn 5.1 及以上集成使用 构建加速思路（比 Turborepo 更丰富）</p><ul><li>缓存： 通过缓存 及 远程缓存，减少构建时间（远程缓存：Nx 公开了一个公共 API，它允许您提供自己的远程缓存实现，Turborepo 必须使用内置的远程缓存）</li><li>增量构建： 最小范围构建，非全量构建</li><li>并行构建： Nx 自动分析项目的关联关系，对这些任务进行排序以最大化并行性</li><li>分布式构建： 结合 Nx Cloud，您的任务将自动分布在 CI 代理中（多台远程构建机器），同时考虑构建顺序、最大化并行化和代理利用率</li></ul><p>用 Nx 强大的任务调度器加速 Lerna：Lerna 擅长管理依赖关系和发布，但扩展基于 Lerna 的 Monorepos 很快就会变得很痛苦，因为 Lerna 很慢。这就是 Nx 的闪光点，也是它可以真正加速你的 monorepo 的地方。</p><h2 id="monorepo-方案概览" tabindex="-1">monorepo 方案概览 <a class="header-anchor" href="#monorepo-方案概览" aria-label="Permalink to &quot;monorepo 方案概览&quot;">​</a></h2><table><thead><tr><th>工具</th><th>优点</th><th>缺点</th><th>官网链接</th></tr></thead><tbody><tr><td>Bazel</td><td>构建速度快；支持多种编程语言</td><td>配置和学习曲线较陡峭</td><td><a href="https://bazel.build/" target="_blank" rel="noreferrer">https://bazel.build/</a></td></tr><tr><td>Gradle Build Tool</td><td>支持多种编程语言；易于使用</td><td>对大型项目的支持不够好</td><td><a href="https://gradle.org/" target="_blank" rel="noreferrer">https://gradle.org/</a></td></tr><tr><td>Lage</td><td>支持多种语言和框架；易于使用</td><td>相对较新，文档和社区支持相对较少</td><td><a href="https://github.com/lage-tech/lage" target="_blank" rel="noreferrer">https://github.com/lage-tech/lage</a></td></tr><tr><td>Lerna</td><td>非常适合管理 npm 包；可以为子包设置依赖关系，并且可以在子包之间共享代码</td><td>依赖关系管理不太灵活，需要手动管理依赖关系等</td><td><a href="https://lerna.js.org/" target="_blank" rel="noreferrer">https://lerna.js.org/</a></td></tr><tr><td>Nx</td><td>支持多种前端框架；提供了许多有用的命令和插件</td><td>需要学习 Nx 的语法和命令，对于新手来说可能有一定的学习曲线</td><td><a href="https://nx.dev/" target="_blank" rel="noreferrer">https://nx.dev/</a></td></tr><tr><td>Pants</td><td>构建速度快；可以跨多个语言和框架构建</td><td>配置和学习曲线较陡峭</td><td><a href="https://www.pantsbuild.org/" target="_blank" rel="noreferrer">https://www.pantsbuild.org/</a></td></tr><tr><td>Rush</td><td>支持多个 npm 包；可以自动处理依赖关系</td><td>对大型项目的支持不够好</td><td><a href="https://rushjs.io/" target="_blank" rel="noreferrer">https://rushjs.io/</a></td></tr><tr><td>Turborepo</td><td>构建速度快；可以自动处理依赖关系</td><td>相对较新，文档和社区支持相对较少</td><td><a href="https://turborepo.com/" target="_blank" rel="noreferrer">https://turborepo.com/</a></td></tr></tbody></table><h2 id="monorepo-方案实践" tabindex="-1">monorepo 方案实践 <a class="header-anchor" href="#monorepo-方案实践" aria-label="Permalink to &quot;monorepo 方案实践&quot;">​</a></h2><p><a href="https://volta.sh/" target="_blank" rel="noreferrer">Volta</a> 是一个 JavaScript 工具管理器，它可以让我们轻松地在项目中锁定 node，npm 和 yarn 的版本。你只需在安装完 Volta 后，在项目的根目录中执行 <code>volta pin</code> 命令，那么无论您当前使用的 node 或 npm（yarn）版本是什么，volta 都会自动切换为您指定的版本。</p><p>因此，除了使用 Docker 和显示在文档中声明 node 和 npm（yarn）的版本之外，您就有了另一个锁定环境的强力工具。</p><p>而且相较于 nvm，Volta 还具有一个诱人的特性：当您项目的 CLI 工具与全局 CLI 工具不一致时，Volta 可以做到在项目根目录下自动识别，切换到项目指定的版本，这一切都是由 Volta 默默做到的，开发者不必关心任何事情。</p><h3 id="锁定环境-volta" tabindex="-1">锁定环境 Volta <a class="header-anchor" href="#锁定环境-volta" aria-label="Permalink to &quot;锁定环境 Volta&quot;">​</a></h3><p><img src="`+p+`" alt="volta"></p><h3 id="复用-packages-workspace" tabindex="-1">复用 packages: workspace <a class="header-anchor" href="#复用-packages-workspace" aria-label="Permalink to &quot;复用 packages: workspace&quot;">​</a></h3><p>使用 monorepo 策略后，收益最大的两点是：</p><ol><li>避免重复安装包，因此减少了磁盘空间的占用，并降低了构建时间；</li><li>内部代码可以彼此相互引用；</li><li>这两项好处全部都可以由一个成熟的包管理工具来完成，对前端开发而言，即是 yarn（1.0 以上）或 npm（7.0 以上）通过名为 <code>workspaces</code> 的特性实现的（⚠️ 注意，支持 workspaces 特性的 npm 目前依旧不是 TLS 版本）。</li></ol><p>为了实现前面提到的两点收益，您需要在代码中做三件事：</p><ol><li>调整目录结构，将相互关联的项目放置在同一个目录，推荐命名为 <code>packages</code>；</li><li>在项目根目录里的 <code>package.json</code> 文件中，设置 <code>workspaces</code> 属性，属性值为之前创建的目录；</li><li>同样，在 <code>package.json</code> 文件中，设置 <code>private</code> 属性为 true（为了避免我们误操作将仓库发布）；</li></ol><p>经过修改，项目目录结构如下：</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">.</span></span>
<span class="line"><span style="color:#babed8;">├── package.json</span></span>
<span class="line"><span style="color:#babed8;">└── packages/</span></span>
<span class="line"><span style="color:#babed8;">    ├── @mono/project_1/ # 推荐使用 \`@&lt;项目名&gt;/&lt;子项目名&gt;\` 的方式命名</span></span>
<span class="line"><span style="color:#babed8;">    │   ├── index.js</span></span>
<span class="line"><span style="color:#babed8;">    │   └── package.json</span></span>
<span class="line"><span style="color:#babed8;">    └── @mono/project_2/</span></span>
<span class="line"><span style="color:#babed8;">        ├── index.js</span></span>
<span class="line"><span style="color:#babed8;">        └── package.json</span></span>
<span class="line"><span style="color:#babed8;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>在项目根目录中执行 <code>npm install</code> 或 <code>yarn install</code> 后，在项目根目录中出现了 <code>node_modules</code> 目录，并且该目录不仅拥有所有子项目共用的 npm 包，还包含了本身子项目。因此，可以在子项目中通过各种模块引入机制，像引入一般的 npm 模块一样引入其他子项目的代码。</p><p>请注意对子项目的命名，统一以 <code>@&lt;repo_name&gt;/</code> 开头，这是一种社区最佳实践，不仅可以让用户更容易了解整个应用的架构，也方便在项目中更快捷的找到所需的子项目。</p><h3 id="统一配置-合并同类项-eslint-typescript-与-babel" tabindex="-1">统一配置：合并同类项 - Eslint，Typescript 与 Babel <a class="header-anchor" href="#统一配置-合并同类项-eslint-typescript-与-babel" aria-label="Permalink to &quot;统一配置：合并同类项 - Eslint，Typescript 与 Babel&quot;">​</a></h3><p>编写代码要遵循 DRY 不重复原则（Don&#39;t Repeat Yourself 的缩写）。应该尽量避免在多个子项目中放置重复的 eslintrc，tsconfig 等配置文件。幸运的是，Babel，Eslint 和 Typescript 都提供了相应的功能让我们减少自我重复</p><p>1、TypeScript</p><p>在 <code>packages</code> 目录中放置 <code>tsconfig.settting.json</code> 文件，并在文件中定义通用的 ts 配置，然后，在每个子项目中，可以通过 <code>extends</code> 属性，引入通用配置，并设置 <code>compilerOptions.composite</code> 的值为 true，理想情况下，子项目中的 tsconfig 文件应该仅包含下述内容：</p><div class="language-json line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">extends</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">../tsconfig.setting.json</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// 继承 packages 目录下通用配置</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">compilerOptions</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#FFCB6B;">composite</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">true,</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// 用于帮助 TypeScript 快速确定引用工程的输出文件位置</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#FFCB6B;">outDir</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">dist</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#FFCB6B;">rootDir</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">src</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">include</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">[</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">src</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>2、Eslint</p><p>对于 <code>Eslint 配置文件</code>，使用同样的方法，可以这样定义子项目的 <code>.eslintrc</code> 文件内容：</p><div class="language-json line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">extends</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">../../.eslintrc</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// 注意这里的不同</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">parserOptions</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#FFCB6B;">project</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">tsconfig.json</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>对于通用的 eslint 配置，并没有将其放置在 <code>packages</code> 目录中，而是放在整个项目的根目录下，这样做是因为一些编辑器插件只会在项目根目录寻找 <code>.eslintrc</code> 文件</p><p>3、Babel</p><p>Babel 配置文件合并的方式与 TypeScript 如出一辙，甚至更加简单，只需在子项目中的 <code>.babelrc</code> 文件中这样声明即可：</p><div class="language-json line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">extends</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">../.babelrc</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="统一命令脚本-scripty" tabindex="-1">统一命令脚本：scripty <a class="header-anchor" href="#统一命令脚本-scripty" aria-label="Permalink to &quot;统一命令脚本：scripty&quot;">​</a></h3><p>子项目间复用脚本命令, 在项目根目录创建 <code>scripts</code> 管理 monorepo 应用脚本，目录结构看起来将会是这样：</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">.</span></span>
<span class="line"><span style="color:#babed8;">├── package.json</span></span>
<span class="line"><span style="color:#babed8;">├── .eslintrc</span></span>
<span class="line"><span style="color:#babed8;">├── scirpts/ # 这里存放所有的脚本</span></span>
<span class="line"><span style="color:#babed8;">│   │   ├── packages/ # 包级别脚本</span></span>
<span class="line"><span style="color:#babed8;">│   │   │   ├── build.sh</span></span>
<span class="line"><span style="color:#babed8;">│   │   │   └── test.sh</span></span>
<span class="line"><span style="color:#babed8;">│   └───└── workspaces/ # 全局脚本</span></span>
<span class="line"><span style="color:#babed8;">│           ├── build.sh</span></span>
<span class="line"><span style="color:#babed8;">│           └── test.sh</span></span>
<span class="line"><span style="color:#babed8;">└── packages/</span></span>
<span class="line"><span style="color:#babed8;">    │   ├── tsconfig.settings.json</span></span>
<span class="line"><span style="color:#babed8;">    │   ├── .babelrc</span></span>
<span class="line"><span style="color:#babed8;">    ├── @mono/project_1/</span></span>
<span class="line"><span style="color:#babed8;">    │   ├── index.js</span></span>
<span class="line"><span style="color:#babed8;">    │   ├── .eslintrc</span></span>
<span class="line"><span style="color:#babed8;">    │   ├── .babelrc</span></span>
<span class="line"><span style="color:#babed8;">    │   ├── tsconfig.json</span></span>
<span class="line"><span style="color:#babed8;">    │   └── package.json</span></span>
<span class="line"><span style="color:#babed8;">    └── @mono/project_2/</span></span>
<span class="line"><span style="color:#babed8;">        ├── index.js</span></span>
<span class="line"><span style="color:#babed8;">        ├── .eslintrc</span></span>
<span class="line"><span style="color:#babed8;">        ├── .babelrc</span></span>
<span class="line"><span style="color:#babed8;">        ├── tsconfig.json</span></span>
<span class="line"><span style="color:#babed8;">        └── package.json</span></span>
<span class="line"><span style="color:#babed8;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>脚本分为两类「package 级别」与「workspace 级别」，并且分别放在两个文件夹内。这样做的好处在于，我们既可以在项目根目录执行全局脚本，也可以针对单个项目执行特定的脚本。</p><p>通过使用 <code>scripty</code>，子项目的 <code>package.json</code> 文件中的 <code>scripts</code> 属性将变得非常精简：</p><div class="language-json line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#676E95;font-style:italic;">// ...</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">scripts</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#FFCB6B;">test</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">scripty</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#FFCB6B;">lint</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">scripty</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#FFCB6B;">build</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">scripty</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">scripty</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#FFCB6B;">path</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">../../scripts/packages</span><span style="color:#89DDFF;">&quot;</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// 注意这里我们指定了 scripty 的路径</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#676E95;font-style:italic;">// ...</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><blockquote><p>注意：使用 <code>chmod -R u+x scripts</code> 命令使所有的 <code>shell</code> 脚本具备可执行权限，将其写在 <code>README.md</code> 文件中！</p></blockquote><h3 id="格式化-commit-信息" tabindex="-1">格式化 commit 信息 <a class="header-anchor" href="#格式化-commit-信息" aria-label="Permalink to &quot;格式化 commit 信息&quot;">​</a></h3><p>使用 <a href="https://github.com/conventional-changelog/commitlint/#what-is-commitlint" target="_blank" rel="noreferrer">commitlint</a> 工具作为格式化 commit 信息的不二之选。</p><p><code>commitlint</code> 可以帮助我们检查提交的 commit 信息，它强制约束我们的 commit 信息必须在开头附加指定类型，用于标示本次提交的大致意图，支持的类型关键字有：</p><ul><li>feat：表示添加一个新特性；</li><li>chore：表示做了一些与特性和修复无关的「家务事」；</li><li>fix：表示修复了一个 Bug；</li><li>refactor：表示本次提交是因为重构了代码；</li><li>style：表示代码美化或格式化；</li><li>...</li></ul><p>除了限定 commit 信息类型外，commitlint 还支持（虽然不是必须的）显示指定我们本次提交所对应的子项目名称。假如我们有一个名为 @mono/project1 的子项目，我们针对该项目提交的 commit 信息可以写为：</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">git commit -m &quot;feat(project1): add a attractive button&quot; # 注意，我们省略了 @mono 的项目前缀</span></span>
<span class="line"><span style="color:#babed8;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>通过下面的命令安装 commitlint 以及周边依赖：</p><div class="language-shell line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">npm</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">i</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">-D</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">@commitlint/cli</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">@commitlint/config-conventional</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">@commitlint/config-lerna-scopes</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">commitlint</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">husky</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">lerna-changelog</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>安装了 <a href="https://www.npmjs.com/package/husky" target="_blank" rel="noreferrer">husky</a>，在根目录下的 <code>package.json</code> 文件</p><div class="language-json line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#676E95;font-style:italic;">//  ...</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">husky</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#FFCB6B;">hooks</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">      </span><span style="color:#89DDFF;">&quot;</span><span style="color:#F78C6C;">commit-msg</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">commitlint -E HUSKY_GIT_PARAMS</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#676E95;font-style:italic;">//  ...</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>为了能够让 commitlint 感知我们的子项目名称，我们还需在项目根目录中增加 <code>commitlint.config.js</code> 文件，并设置文件内容为：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">module.exports</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#F07178;">extends</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> [</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">@commitlint/config-conventional</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">@commitlint/config-lerna-scopes</span><span style="color:#89DDFF;">&#39;</span><span style="color:#BABED8;">]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>通过在命令行执行 <code>echo &quot;build(project1): change something&quot; | npx commitlint</code> 命令即可验证 <code>commit</code> 信息是否通过 <code>commitlint</code> 的检查</p><h2 id="如何从-multirepo-迁移至使用-monorepo-策略" tabindex="-1">如何从 multirepo 迁移至使用 monorepo 策略 <a class="header-anchor" href="#如何从-multirepo-迁移至使用-monorepo-策略" aria-label="Permalink to &quot;如何从 multirepo 迁移至使用 monorepo 策略&quot;">​</a></h2><p>如果想要导入远程仓库，或是要获取某个分支或标签该怎么做呢？答案是使用 <a href="https://github.com/hraban/tomono" target="_blank" rel="noreferrer">tomono</a>，其内容是一个 shell 脚本。</p><p>使用 tomono 导入远程仓库，您所需要做的只有两件事：</p><ol><li>创建一个包含所有需要导入 repo 地址的文本文件；</li><li>执行 shell 命令：<code>cat repos.txt | ~/tomono/tomono.sh</code>（这里我们假定您的文本文件名为 repos.txt，且将 tomono 下载在用户根目录；</li></ol><p>repo 文件内容示例如下：</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">// 1. Git仓库地址  2. 子项目名称  3. 迁移后的路径</span></span>
<span class="line"><span style="color:#babed8;">git@github.com/backend.git @mono/backend packages/backend</span></span>
<span class="line"><span style="color:#babed8;">git@github.com/frontend.git @mono/frontend packages/frontend</span></span>
<span class="line"><span style="color:#babed8;">git@github.com/mobile.git @mono/mobile packages/mobile</span></span>
<span class="line"><span style="color:#babed8;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="扩展阅读" tabindex="-1">扩展阅读 <a class="header-anchor" href="#扩展阅读" aria-label="Permalink to &quot;扩展阅读&quot;">​</a></h2><ul><li><p>介绍实践 monorepo 生态：<a href="https://github.com/korfuri/awesome-monorepo" target="_blank" rel="noreferrer">awesome-monorepo</a></p></li><li><p><a href="https://juejin.cn/post/7242623686900482108" target="_blank" rel="noreferrer">使用 NX+PNPM 搭建 Monorepo 项目</a></p></li><li><p><a href="http://1.13.188.124/today/20230225.html" target="_blank" rel="noreferrer">http://1.13.188.124/today/20230225.html</a></p></li><li><p><a href="https://www.pipipi.net/26124.html" target="_blank" rel="noreferrer">https://www.pipipi.net/26124.html</a></p></li><li><p><a href="https://www.yangyitao.com/vue3/01.%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5-monorepo.html" target="_blank" rel="noreferrer">https://www.yangyitao.com/vue3/01.代码管理策略-monorepo.html</a></p></li><li><p><a href="https://notes.fe-mm.com/fe/monorepo/" target="_blank" rel="noreferrer">https://notes.fe-mm.com/fe/monorepo/</a></p></li></ul>`,130),t=[r];function c(i,d,b,m,u,y){return n(),a("div",null,t)}const h=s(o,[["render",c]]);export{F as __pageData,h as default};
