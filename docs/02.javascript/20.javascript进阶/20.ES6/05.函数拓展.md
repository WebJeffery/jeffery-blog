---
title: 函数拓展
date: 2020-02-14 19:27:01
permalink: /pages/sdeseweeewbdf257cb
author: 
  name: jeffery
categories: 
  - javascript
tags: 
  - javascript
---

# 函数拓展

## 形参默认值

ES5 给默认值写法

```js
function makeRequest(url, timeout, callback) {
    timeout = (typeof timeout !== "undefined") ? timeout : 2000;
    callback = (typeof callback !== "undefined") ? callback : function() {};
    // 函数的剩余部分
}
```

ES6 默认值简化写法
```js
function makeRequest(url, timeout = 2000, callback) {
    console.log(url);
    console.log(timeout);
    console.log(callback);
}
```

如果传入 `undefined`，将触发该参数等于默认值，`null` 则没有这个效果

```js
function makeRequest(url, timeout = 2000, callback) {
    console.log(timeout);
}
makeRequest("/foo");//2000
makeRequest("/foo", undefined);//2000
makeRequest("/foo", null);//null
makeRequest("/foo", 100);//100
```

- 使用参数默认值时，函数不能有同名参数

```js
// SyntaxError: Duplicate parameter name not allowed in this context
function foo(x, x, y = 1) {
  // ...
}
```

- 参数默认值是惰性求值的

```js
let x = 99;
function foo(p = x + 1) {
  console.log(p);
}
foo() // 100
x = 100;
foo() // 101
```

上面代码中，参数p的默认值是x+1。这时，每次调用函数foo，都会重新计算x+1，而不是默认p等于100

- length属性

指定了默认值以后，函数的 `length` 属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，`length` 属性将失真

```js
(function (a) {}).length // 1
(function (a = 5) {}).length // 0
(function (a, b, c = 5) {}).length // 2
```

这是因为`length`属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，rest 参数也不会计入`length`属性



## 不定参数

　不定参数有两条使用限制

1、每个函数最多只能声明一个不定参数，而且一定要放在所有参数的末尾

```js
// 语法错误：不能在剩余参数后使用具名参数
function pick(object, ...keys, last) {
    let result = Object.create(null);
    for (let i = 0, len = keys.length; i < len; i++) {
        result[keys[i]] = object[keys[i]];
    }
    return result;
}
```

　2、不定参数不能在对象字面量的 setter 属性中使用

```js
let object = {
    // 语法错误：不能在 setter 中使用剩余参数
    set name(...value) {
        // 一些操作
    }
};
```

之所以存在这条限制，是因为对象字面量setter的参数有且只能有一个。而在不定参数的定义中，参数的数量可以无限多，所以在当前上下文中不允许使用不定参数



## 展开运算符

展开运算符可以简化使用数组给函数传参的编码过程，在大多数使用 `apply()` 方法的情况下展开运算符可能是一个更合适的方案

```js
let values = [-25, -50, -75, -100]
console.log(Math.max(...values, 0)); // 0
```

## 箭头函数

箭头函数使用注意：

1、没有 `this`、`super`、`arguments` 和 `new.target`

绑定箭头函数中的 `this`、`super`、`arguments` 和 `new.target` 这些值由外围最近一层非箭头函数决定

2、不能通过 `new` 关键字调用

箭头函数没有 `construct` 方法，不能被用作构造函数，如果通过 `new` 关键字调用箭头函数，程序抛出错误

3、没有原型

由于不可以通过 `new` 关键字调用箭头函数，因而没有构建原型的需求，所以箭头函数不存在 `prototype` 这个属性

4、不可以改变 `this` 绑定

函数内部的 `this` 值不可被改变，在函数的生命周期内始终保持一致

5、不支持 `arguments` 对象

箭头函数没有 `arguments` 绑定，必须通过命名参数和不定参数这两种形式访问函数的参数

6、不支持重复的命名参数

无论在严格还是非严格模式下，箭头函数都不支持重复的命名参数；

::: tips
箭头函数同样也有一个name属性，这与其他函数的规则相同
:::

箭头函数的语法多变，根据实际的使用场景有多种形式。所有变种都由函数参数、箭头、函数体组成，根据使用的需求，参数和函数体可以分别采取多种不同的形式

```js
var reflect = value => value;
// 有效等价于：
var reflect = function(value) {
    return value;
};
```

如果要传入两个或两个以上的参数，要在参数的两侧添加一对小括号

```js
var sum = (num1, num2) => num1 + num2;
// 有效等价于：
var sum = function(num1, num2) {
    return num1 + num2;
};
```

如果函数没有参数，也要在声明的时候写一组没有内容的小括号

```js
var getName = () => "huochai";
// 有效等价于：
var getName = function() {
    return "huochai";
};
```

如果希望为函数编写由多个表达式组成的更传统的函数体，那么需要用花括号包裹函数体，并显式地定义一个返回值

```js
var sum = (num1, num2) => {
    return num1 + num2;
};
// 有效等价于：
var sum = function(num1, num2) {
    return num1 + num2;
};
```

除了arguments对象不可用以外，某种程度上都可以将花括号里的代码视作传统的函数体定义

如果想创建一个空函数，需要写一对没有内容的花括号

```js
var doNothing = () => {};
// 有效等价于：
var doNothing = function() {};
```

　　花括号代表函数体的部分，但是如果想在箭头函数外返回一个对象字面量，则需要将该字面量包裹在小括号里

```js
var getTempItem = id => ({ id: id, name: "Temp" });
// 有效等价于：
var getTempItem = function(id) {
    return {
        id: id,
        name: "Temp"
    };
};
```

将对象字面量包裹在小括号中是为了将其与函数体区分开来

【this】

函数内的 `this` 绑定是 `JS` 中最常出现错误的因素，函数内的 `this` 值可以根据函数调用的上下文而改变，这有可能错误地影响其他对象

```js
var PageHandler = {
    id: "123456",
    init: function() {
        document.addEventListener("click", function(event) {
            this.doSomething(event.type); // 错误
        }, false);
    },
    doSomething: function(type) {
        console.log("Handling " + type + " for " + this.id);
    }
};
```

在这段代码中，对象 `pageHandle` r的设计初衷是用来处理页面上的交互，通过调用 `init()` 方法设置交互，依次分配事件处理程序来调用 `this.dosomething()` 。然而，这段代码并没有如预期的正常运行

实际上，因为 `this` 绑定的是事件目标对象的引用(在这段代码中引用的是document)，而没有绑定 `pageHandler` ，且由于`this.dosonething()` 在目标 `document` 中不存在，所以无法正常执行，尝试运行这段代码只会使程序在触发事件处理程序时抛出错误

可以使用 `bind()` 方法显式地将 `this` 绑定到 `pageHandler` 函数上来修正这个问题

```js
var PageHandler = {
    id: "123456",
    init: function() {
        document.addEventListener("click", (function(event) {
            this.doSomething(event.type); // 错误
        }).bind(this), false);
    },
    doSomething: function(type) {
        console.log("Handling " + type + " for " + this.id);
    }
};
```

　　现在代码如预期的运行，但可能看起来仍然有点奇怪。调用 `bind(this)` 后，事实上创建了一个新函数，它的 `this` 被绑定到当前的`this`，也就是 `page Handler`

　　可以通过一个更好的方式来修正这段代码：使用箭头函数

　箭头函数中没有 `this` 绑定，必须通过查找作用城链来决定其值。如果箭头函数被非箭头函数包含，则 `this` 绑定的是最近一层非箭头函数的 `this`；否则，`this` 的值会被设置为 `undefined`

```js
var PageHandler = {
    id: "123456",
    init: function() {
        document.addEventListener("click",
            event => this.doSomething(event.type), false);
        },
    doSomething: function(type) {
        console.log("Handling " + type + " for " + this.id);
    }
};
```

　　这个示例中的事件处理程序是一个调用了 `this.doSomething()` 的箭头函数，此处的 `this` 与 `init()` 函数里的 `this`一致，所以此版本代码的运行结果与使用 `bind(this)` 一致。虽然 `dosomething()` 方法不返回值，但是它仍是函数体内唯一的一条执行语句，所以不必用花括号将它包裹起来

　　箭头函数缺少正常函数所拥有的 `prototype` 属性，它的设计初衷是即用即弃，所以不能用它来定义新的类型。如果尝试通过 `new` 关键字调用一个箭头函数，会导致程序抛出错误

```js
var MyType = () => {},
object = new MyType(); // 错误：不能对箭头函数使用 'new'
```

【数组】 

　　箭头函数的语法简洁，非常适用于数组处理。如果想给数组排序，通常需要写一个自定义的比较器

```js
var result = values.sort(function(a, b) {
    return a - b;
});
```

　　只想实现一个简单功能，但这些代码实在太多了。用箭头函数简化如下

```js
var result = values.sort((a, b) => a - b);
```

　　诸如sort()、map()及reduce()这些可以接受回调函数的数组方法，都可以通过箭头函数语法简化编码过程并减少编码量

```js
// 正常函数写法
[1,2,3].map(function (x) {
  return x * x;
});

// 箭头函数写法
[1,2,3].map(x => x * x);
```

【arguments】

箭头函数没有自己的 `arguments` 对象，且未来无论函数在哪个上下文中执行，箭头函数始终可以访问外围函数的 `arguments` 对象

```js
function createArrowFunctionReturningFirstArg() {
    return () => arguments[0];
}
var arrowFunction = createArrowFunctionReturningFirstArg(5);
console.log(arrowFunction()); // 5
```

　【辨识方法】

　　尽管箭头函数与传统函数的语法不同，但它同样可以被识别出来

```js
var comparator = (a, b) => a - b;
console.log(typeof comparator); // "function"
console.log(comparator instanceof Function); // true
```

　　同样地，仍然可以在箭头函数上调用 `call()`、`apply()`及`bind()`方法，但与其他函数不同的是，箭头函数的 `this` 值不会受这些方法的影响

```js
var sum = (num1, num2) => num1 + num2;
console.log(sum.call(null, 1, 2)); // 3
console.log(sum.apply(null, [1, 2])); // 3
var boundSum = sum.bind(null, 1, 2);
console.log(boundSum()); // 3
```

　　包括回调函数在内所有使用匿名函数表达式的地方都适合用箭头函数来改写

【函数柯里化】

　　柯里化是一种把接受多个参数的函数变换成接受一个单一参数的函数，并且返回（接受余下的参数而且返回结果的）新函数的技术

　　如果使用ES5的语法来写，如下所示

```js
function add(x){
  return function(y){
    return y + x;
  };
}

var addTwo = add(2);
addTwo(3);          // => 5
add(10)(11);        // => 21
```

　　使用ES6的语法来写，如下所示

```js
var add = (x) => (y) => x+y
```

　　一般来说，出现连续地箭头函数调用的情况，就是在使用函数柯里化的技术

 

### 尾调用优化

　　ES6关于函数最有趣的变化可能是尾调用系统的引擎优化。尾调用指的是函数作为另一个函数的最后一条语句被调用

```js
function doSomething() {
    return doSomethingElse(); // 尾调用
}
```

　　尾调用之所以与其他调用不同，就在于它的特殊的调用位置

　　我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数`A`的内部调用函数`B`，那么在`A`的调用帧上方，还会形成一个`B`的调用帧。等到`B`运行结束，将结果返回到`A`，`B`的调用帧才会消失。如果函数`B`内部还调用函数`C`，那就还有一个`C`的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）

　　尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了

　　尾调用优化（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存

　　ES6缩减了严格模式下尾调用栈的大小(非严格模式下不受影响)，如果满足以下条件，尾调用不再创建新的栈帧，而是清除并重用当前栈帧

　　1、尾调用不访问当前栈帧的变量(也就是说函数不是一个闭包)

　　2、在函数内部，尾调用是最后一条语句

　　3、尾调用的结果作为函数值返回

　　以下这段示例代码满足上述的三个条件，可以被JS引擎自动优化

```js
"use strict";
function doSomething() {
    // 被优化
    return doSomethingElse();
}
```

　　在这个函数中，尾调用doSomethingElse()的结果立即返回，不调用任何局部作用域变量。如果做一个小改动，不返回最终结果，那么引擎就无法优化当前函数

```js
"use strict";
function doSomething() {
    // 未被优化：缺少 return
    doSomethingElse();
}
```

　　同样地，如果定义了一个函数，在尾调用返回后执行其他操作，则函数也无法得到优化

```js
"use strict";
function doSomething() {
    // 未被优化：在返回之后还要执行加法
    return 1 + doSomethingElse();
}
```

　　如果把函数调用的结果存储在一个变量里，最后再返回这个变量，则可能导致引擎无法优化

```js
"use strict";
function doSomething() {
    // 未被优化：调用并不在尾部
    var result = doSomethingElse();
    return result;
}
```

　　可能最难避免的情况是闭包的使用，它可以访问作用域中所有变量，因而导致尾调用优化失效

```js
"use strict";
function doSomething() {
    var num = 1,
    func = () => num;
    // 未被优化：此函数是闭包
    return func();
}
```

　　在示例中，闭包 `func()` 可以访问局部变量 `num`，即使调用 `func()` 后立即返回结果，也无法对代码进行优化

【应用】

　　实际上，尾调用的优化发生在引擎背后，除非尝试优化一个函数，否则无须思考此类问题。递归函数是其最主要的应用场景，此时尾调用优化的效果最显著

```js
function factorial(n) {
    if (n <= 1) {
        return 1;
    } else {
        // 未被优化：在返回之后还要执行乘法
        return n * factorial(n - 1);
    }
}
```

　　由于在递归调用前执行了乘法操作，因而当前版本的阶乘函数无法被引擎优化。如果n是一个非常大的数，则调用栈的尺寸就会不断增长并存在最终导致栈溢出的潜在风险

　　优化这个函数，首先要确保乘法不会在函数调用后执行，可以通过默认参数来将乘法操作移出return语句，结果函数可以携带着临时结果进入到下一个迭代中

```js
function factorial(n, p = 1) {
    if (n <= 1) {
        return 1 * p;
    } else {
        let result = n * p;
        // 被优化
        return factorial(n - 1, result);
    }
}
```

　　在这个重写后的factorial()函数中，第一个参数p的默认值为1，用它来保存乘法结果，下一次迭代中可以取出它用于计算，不再需要额外的函数调用。当n大于1时，先执行一轮乘法计算，然后将结果传给第二次factorial()调用的参数。现在，ES6引擎就可以优化递归调用了

　　写递归函数时，最好得用尾递归优化的特性，如果递归函数的计算量足够大，则尾递归优化可以大幅提升程序的性能

　　另一个常见的事例是Fibonacci数列

```js
function Fibonacci (n) {
  if ( n <= 1 ) {return 1};
  return Fibonacci(n - 1) + Fibonacci(n - 2);
}

Fibonacci(10) // 89
Fibonacci(100) // 堆栈溢出
Fibonacci(500) // 堆栈溢出
```

　　尾递归优化过的 Fibonacci 数列实现如下

```js
function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {
  if( n <= 1 ) {return ac2};
  return Fibonacci2 (n - 1, ac2, ac1 + ac2);
}

Fibonacci2(100) // 573147844013817200000
Fibonacci2(1000) // 7.0330367711422765e+208
Fibonacci2(10000) // Infinity
```

　　由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出，相对节省内存