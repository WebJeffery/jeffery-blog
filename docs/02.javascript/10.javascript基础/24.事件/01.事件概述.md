---
title: 事件概述
date: 2021-04-14 19:33:10
permalink: /pages/azdwewsessew
author: 
  name: jeffery
categories: 
  - javascript
tags: 
  - javascript
---
# 事件概述

## 事件机制

### 事件冒泡

事件冒泡(event bubbling)，即事件开始时由最具体的元素(文档中嵌套层次最深的那个节点)接收，然后逐级向上传播到较为不具体的节点(文档)

以下列 `HTML` 结构为例，说明事件冒泡、事件捕获及事件流

```html
<!DOCTYPE HTML>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Document</title>
<body>
<div></div>
</body>    
</html>
```

如果单击了页面中的 `<div>` 元素，那么这个 `click` 事件沿 `DOM` 树向上传播，在每一级节点上都会发生，按照如下顺序传播：

```html
(1)    <div>
(2)    <body>
(3)    <html>
(4)    document
```

所有现代浏览器都支持事件冒泡，但在具体实现在还是有一些差别。IE9、Firefox、Chrome、Safari将事件一直冒泡到 `window` 对象

```html
(1)    <div>
(2)    <body>
(3)    <html>
(4)    document
(5)    window
<!DOCTYPE HTML>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Document</title>
```
### 事件捕获

事件捕获是不太具体的节点更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于在事件到达预定目标之前就捕获它

以同样的 `HTML` 结构为例，说明事件捕获

```html
<!DOCTYPE HTML>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Document</title>
<body>
<div></div>
</body>    
</html>
```

在事件捕获过程中，`document` 对象首先接收到`click`事件，然后事件沿`DOM`树依次向下，一直传播到事件的实际目标，即`<div>`元素

```html
(1)    document
(2)    <html>
(3)    <body>
(4)    <div>
```

IE9、Firefox、Chrome、Safari等现代浏览器都支持事件捕获，但是从`window`对象开始捕获

```html
(1)    window
(2)    document
(3)    <html>
(4)    <body>
(5)    <div>
```

`addEventListener()` 方法中的第三个参数设置为 `true` 时，即为事件捕获阶段，默认为 `false` 事件冒泡

### 事件流

事件流又称为事件传播，`DOM2` 级事件规定的事件流包括三个阶段：事件捕获阶段(capture phase)、处于目标阶段(target phase)和事件冒泡阶段(bubbling phase)

首先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标接收到事件，最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应

![eventFlow](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_DOM_event_eventFlow.jpg)

## 事件处理程序

事件处理程序又叫事件侦听器，实际上就是事件的绑定函数。事件发生时会执行函数中相应代码。事件处理程序有`HTML`事件处理程序、`DOM0`级事件处理程序、`DOM2`级事件处理程序和`IE事件处理程序`四类

### HTML事件处理程序会

`HTML` 事件处理程序会创建一个封装着元素属性值的函数。这个函数中有一个局部变量 `event`，也就是事件对象。通过`event`变量，可以直接访问事件对象，不用自己定义它，也不用从函数的参数列表中获取

```html
<div id="box" style="height:30px;width:200px;background-color:pink;"onclick = "this.innerHTML+= event.type;"></div>
```

### DOM0级事件处理程序

以 `DOM0` 级方式添加的事件处理程序会在事件流的冒泡阶段被处理

```html
<div id="box" style="height:30px;width:200px;background-color:pink;"></div>
<script>
box.onclick = function(){this.innerHTML += '1';}    
</script>    
```

可以通过将事件处理程序属性设置为 `null` 来删除事件处理程序

```js
box.onclick = null;
```

**缺点**

`DOM0` 级事件处理程序的缺点是围绕着每个事件目标对于每种事件类型只能添加一个事件处理程序
### DOM2级事件处理程序

`DOM2` 级事件处理程序定义了两个方法用于处理指定和删除事件处理程序的操作：`addEventListener()`和`removeEventListener()`

所有`DOM`节点中都包含这两个方法，并且它们都接受3个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后的布尔值参数如果是 `true`，表示在捕获阶段调用事件处理程序；如果是 `false`，表示在冒泡阶段调用事件处理程序。若最后的布尔值不填写，则和 `false` 效果一样

::: tip
IE8-浏览器不支持DOM2级事件处理程序
:::

使用`DOM2`级事件处理程序的好处是可以添加多个事件处理程序，并按照他们添加的顺序触发

```html
<div id="box" style="height:30px;width:200px;background-color:pink;"></div>
<script>
box.addEventListener('click',function(){this.innerHTML += '1'},false);
box.addEventListener('click',function(){this.innerHTML += '2'},false);    
</script>    
```

**移除**

通过`addEventListener()`添加的事件处理程序只能使用`removeEventListener()`来移除，移除时传入的参数与添加处理程序时使用的参数相同。这意味着，`addEventListener()`添加的匿名函数将无法移除　　

以下无效

```html
<div id="box" style="height:30px;width:200px;background-color:pink;"></div>
<script>
box.addEventListener("click",function(){
    this.innerHTML += '1'
},false);
box.removeEventListener('click',function(){
    this.innerHTML += '1'
},false);    
</script>
```

以下有效

```html
<div id="box" style="height:30px;width:200px;background-color:pink;"></div>
<script>
var handle = function(){this.innerHTML += '1'};
box.addEventListener("click",handle,false);
box.removeEventListener('click',handle,false);    
</script>
```

### IE事件处理程序

IE实现了与 `DOM` 中类似的两个方法：`attachEvent()`和`detachEvent()`。这两个方法接受相同的两个参数：事件处理程序名称与事件处理程序函数。由于IE8-浏览器只支持事件冒泡，所以通过 `attachEvent()`添加的事件处理程序都会被添加到事件冒泡阶段

`attachEvent()` 方法的第一个参数是 `"onclick"`，而非DOM的 `addEventListener()` 方法中的 `"click"`

```html
<div id="box" style="height:30px;width:200px;background-color:pink;"></div>
<script>
box.attachEvent('onclick',function(){this.innerHTML += '1';});
</script>
```

`attachEvent()` 方法只冒泡到 `document`，且IE10-浏览器支持

**移除**

使用 `attachEvent()` 添加的事件可以通过`detachEvent()`来移除，条件是必须提供相同的参数。与`DOM`方法一样，这也意味着添加的匿名函数将不能被移除。不过，只要能够将对相同函数的引用传给 `detachEvent()`，就可以移除相应的事件处理程序　　

以下无效

```html
<div id="box" style="height:30px;width:200px;background-color:pink;"></div>
<script>
box.attachEvent("onclick",function(){
    box.innerHTML += '1'
},false);
box.detachEvent('onclick',function(){
    box.innerHTML += '1'
},false);    
</script>
```

以下有效

```html
<div id="box" style="height:30px;width:200px;background-color:pink;"></div>
<script>
var handle = function(){box.innerHTML += '1'};
box.attachEvent("onclick",handle,false);
box.detachEvent('onclick',handle,false);    
</script>    
```
### 小结

由于IE8-浏览器不支持 `addEventListener()` 方法，所以需要配合 `attachEvent()` 方法来实现全浏览器的事件绑定兼容写法。同时，由于 `attachEvent()` 方法中的`this`指向 `window` ，所以需要对 `this` 进行显式修改

```js
function addEvent(target,type,handler){
    if(target.addEventListener){
        target.addEventListener(type,handler,false);
    }else{
        target.attachEvent('on'+type,function(event){
            return handler.call(target,event);
        });
    }
}
```

## 事件对象

事件对象包含与创建它的特定事件有关的属性和方法。触发的事件类型不一样，可用的属性和方法也不一样。不过，所有事件都有些共有的属性和方法

### 事件类型

事件有很多类型，事件对象中的 `type` 属性表示被触发的事件类型

### 事件目标

事件目标，共有 `currentTarget`、`target`和`srcElement`这三个属性

**currentTarget**

`currentTarget` 属性返回事件当前所在的节点，即正在执行的监听函数所绑定的那个节点，IE8-浏览器不支持

一般地，`currentTarget` 与事件中的 `this` 指向相同。但在 `attachEvent()` 事件处理程序中，`this` 指向 `window`

**target**

`currentTarget` 属性返回事件正在执行的监听函数所绑定的节点，而 `target` 属性返回事件的实际目标节点

**srcElement**

`srcElement` 属性与 `target` 属性功能一致，firefox浏览器不支持

### 事件代理

由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理(delegation)，也叫事件委托

事件代理应用事件目标的 `target`和 `srcElement` 属性完成。利用事件代理，可以提高性能及降低代码复杂度

```JS
//事件代理方法
box.onmouseover = function(e){
    e = e || event;
    var target = e.target || e.srcElement;
    target.style.backgroundColor = 'lightblue';
}
box.onmouseout = function(e){
    e = e || event;
    var target = e.target || e.srcElement;
    target.style.backgroundColor = 'pink';
}
```

### 事件冒泡

事件冒泡是事件流的第三个阶段，通过事件冒泡可以在这个阶段对事件做出响应

关于冒泡，事件对象中包含 `bubbles`、`cancelBubble`、`stopPropagation()`和`stopImmediatePropagation()`这四个相关的属性和方法

**bubbles**

`bubbles` 属性返回一个布尔值，表示当前事件是否会冒泡。该属性为只读属性

发生在文档元素上的大部分事件都会冒泡，但`focus`、`blur`和`scroll`事件不会冒泡。所以，除了这三个事件`bubbles`属性返回`false`外，其他事件该属性都为`true`

**stopPropagation()**

`stopPropagation()` 方法表示取消事件的进一步捕获或冒泡，无返回值

IE8-浏览器不支持

**stopImmediatePropagation()**

`stopImmediatePropagation()`方法不仅可以取消事件的进一步捕获或冒泡，而且可以阻止同一个事件的其他监听函数被调用，无返回值

IE8-浏览器不支持

使用 `stopIPropagation()`方法，可以阻止冒泡，但无法阻止同一事件的其他监听函数被调用

使用`stopImmediatePropagation()`方法，即可以阻止冒泡，也可以阻止同一事件的其他监听函数被调用

**cancelBubble**

`cancelBubble` 属性只能用于阻止冒泡，无法阻止捕获阶段。该值可读写，默认值是 `false`。当设置为`true`时，`cancelBubble`可以取消事件冒泡

该属性全浏览器支持，但并不是标准写法

### 事件流

**eventPhase**

`eventPhase` 属性返回一个整数值，表示事件目前所处的事件流阶段

- 0表示事件没有发生
- 1表示捕获阶段
- 2表示目标阶段
- 3表示冒泡阶段

### 取消默认行为

常见的默认行为有点击链接后，浏览器跳转到指定页面；或者按一下空格键，页面向下滚动一段距离

关于取消默认行为的属性包括 `cancelable`、`defaultPrevented`、`preventDefault()`和`returnValue`

**使用**

- 1、在 `DOM0` 级事件处理程序中取消默认行为，使用`returnValue`、`preventDefault()`和`return false`都有效

- 2、在`DOM2`级事件处理程序中取消默认行为，使用`return false`无效

- 3、在IE事件处理程序中取消默认行为，使用`preventDefault()`无效


## 事件类型

### 鼠标事件

鼠标事件共10类，包括 `click`、`contextmenu`、`dblclick`、`mousedown`、`mouseup`、`mousemove`、`mouseover`、`mouseout`、`mouseenter`和`mouseleave`

```html
click         当用户按下并释放鼠标按键或其他方式“激活”元素时触发
contextmenu   可以取消的事件，当上下文菜单即将出现时触发。当前浏览器在鼠标右击时显示上下文菜单
dblclick      当用户双击鼠标时触发
mousedown     当用户按下鼠标按键时触发
mouseup       当用户释放鼠标按键时触发
mousemove     当用户移动鼠标时触发
mouseover     当鼠标进入元素时触发。relatedTarget(在IE中是fromElement)指的是鼠标来自的元素
mouseout      当鼠标离开元素时触发。relatedTarget(在IE中是toElement)指的是鼠标要去往的元素
mouseenter    类似mouseover，但不冒泡。IE将其引入，HTML5将其标准化，但尚未广泛实现
mouseleave    类似mouseout，但不冒泡。IE将其引入，HTML5将其标准化，但尚未广泛实现
```

#### 顺序

**【1】鼠标移入时，触发 `mouseover`、`mouseenter`和`mousemove`事件**

IE浏览器会先触发一次`mousemove`事件，再触发`mouseover`和`mouseenter`事件，再触发多次`mousemove`事件

而其他浏览器都是先触发 `mouseover` 和 `mouseenter`事件，再触发多次 `mousemove` 事件

  **【2】鼠标移出时，触发`mousemove`、`mouseleave`和`mouseout` 事件**

所有浏览器的顺序都是一样

**【3】双击鼠标时，触发 `mousedown`、`mouseup`、`click`、`dblclick`事件**

一般地，浏览器的顺序是(1)`mousedown`、(2)`mouseup`、(3)`click`、(4)`mousedown`、(5)`mouseup`、(6)`click`、(7)`dblclick`


**【4】点击鼠标右键时，触发`mousedown`、`mouseup`、`contextmenu`事件**

一般地，浏览器的顺序是(1)`mousedown`、(2)`mouseup`、(3)`contextmenu`

但safari浏览器有一个小bug，它不触发`mouseup`事件，顺序为(1)`mousedown`、(2)`contextmenu`

**【5】嵌套元素的移入移出时，触发mouseover、mouseenter、mouseleave、mouseout事件**

从父级元素进入子级元素时，顺序为:(1)父级元素的`mouseout`、(2)子级元素的`mouseover`、(3)父级元素的`mouseover`、(4)子级元素的`mouseenter`

从子级元素进入父级元素时，顺序为:(1)子级元素的`mouseout`、(2)父级元素的`mouseout`、(3)子级元素的`mouseleave`、(4)父级元素的`mouseover`

### 键盘事件

键盘事件用来描述键盘行为，主要有 `keydown`、`keypress`、`keyup`三个事件

**keydown**

当用户按下键盘上的任意键时触发，如果按住不放的话，会重复触发该事件

**keypress**

当用户按下键盘上的字符键时触发，按下功能键时不触发。如果按住不放的话，会重复触发该事件

**keyup**

当用户释放键盘上的键时触发

系统为了防止按键误被连续按下，所以在第一次触发`keydown`事件后，有500ms的延迟，才会触发第二次`keydown`事件

#### 顺序

如果用户一直按键不松开，就会连续触发键盘事件，触发的顺序如下

```
1、keydown
2、keypress
3、keydown
4、keypress
5、（重复以上过程）
6、keyup
```

### 剪贴板事件

#### 定义

剪贴板操作包括剪切(cut)、复制(copy)和粘贴(paste)这三个操作，快捷键分别是 `ctrl+x`、`ctrl+c`、`ctrl+v`。

关于这3个操作共对应下列6个剪贴板事件

- copy：在发生复制操作时触发

- cut：在发生剪切操作时触发

- paste：在发生粘贴操作时触发

::: tip
IE浏览器只有在文本中选定字符时，copy和cut事件才会发生。且在非文本框中(如div元素)只能发生copy事件;

firfox浏览器只有焦点在文本框中才会发生paste事件
:::

```html
<input value="text" id="test">
<script>
test.onpaste= test.oncopy = test.oncut = function(e){
    e = e || event;
    test.value = e.type;
    return false;
}
</script>
```

- beforecopy：在发生复制操作前触发

- beforecut：在发生剪切操作前触发

- beforepaste：在发生粘贴操作前触发

```html
<input value="text" id="test">
<script>
test.onbeforepaste= test.onbeforecopy = test.onbeforecut = function(e){
    e = e || event;
    test.value = e.type;
    return false;
}
</script>
```
#### 对象方法

剪贴板中的数据存储在 `clipboardData` 对象中。对于IE浏览器来说，这个对象是 `window` 对象的属性；对于其他浏览器来说，这个对象是事件对象的属性

```js
e = e || event;
var clipboardData = e.clipboardData || window.clipboardData;
```

这个对象有三个方法：`getData()`、`setData()`和`clearData ()`

**getData()**

`getData()` 方法用于从剪贴板中取得数据，它接受一个参数，即要取得的数据的格式。在IE中，有两种数据格式："text" 和 "URL"。在其他浏览器中，这个参数是一种MIME类型；不过，可以用"text"代表

[注意]在IE浏览器中，`cut`和`copy`事件中的`getData()`方法始终返回`null`；而其他浏览器始终返回空字符串''。但如果和`setDada()`方法配合，就可以正常使用

```html
<input id="test" value="123">
<script>
test.onpaste=function(e){
    e = e || event;
    var clipboardData = e.clipboardData || window.clipboardData;
    test.value = '测试' + clipboardData.getData('text');
    return false;
}
</script>
```

**setData()**

`setData()` 方法的第一个参数也是数据类型，第二个参数是要放在剪贴板中的文本。对于第一个参数的规则与`getData()`相同

在IE浏览器中，该方法在成功将文本放到剪贴板中后，返回`true`，否则返回`false`；而其他浏览器中，该方法无返回值

::: tip
[注意]在paste事件中，只有IE浏览器可以正常使用setData()方法，chrome浏览器会静默失败，而firefox浏览器会报错
:::

```html
<input id="test" value="123">
<script>
test.oncopy=function(e){
    e = e || event;
    var clipboardData = e.clipboardData || window.clipboardData;
    clipboardData.setData('text','测试');
    test.value = clipboardData.getData('text');
    return false;
}
</script>
```


**clearData()**

`clearData()`方法用于从剪贴板中删除数据，它接受一个参数，即要取得的数据的格式。在IE中，有两种数据格式："text"和"URL"。在其他浏览器中，这个参数是一种MIME类型；不过，可以用"text"表示

在IE浏览器中，该方法在成功将文本放到剪贴板中后，返回`true`，否则返回 `false`；而其他浏览器该方法的返回值为 `undefined`

:::
在paste事件中，chrome浏览器和IE浏览器可以正常使用setData()方法，而firefox浏览器会报错
:::

```html
<input id="test" value="123">
<script>
test.oncopy=function(e){
    e = e || event;
    var clipboardData = e.clipboardData || window.clipboardData;
    test.value = clipboardData.clearData('text');
    return false;
}
</script>
```
#### 应用

【1】屏蔽剪贴板

　　通过阻止默认行为来屏蔽剪贴板。对于一些受保护的文档来说是一种选择

```html
<input value="text">
<button id="test">屏蔽剪贴板</button>
<script>
test.onclick = function(){
    document.oncopy=document.oncut = document.onpaste = function(e){
        e = e || event;
        alert('该文档不允许复制剪贴操作，谢谢配合')
        return false;
    }    
}
</script>
```

【2】过滤字符,如果确保粘贴到文本框中的文本中包含某些字符，或者符合某种形式时，可以使用剪贴板事件。比如只允许粘贴数字

```html
<input id="test">
<script>
test.onpaste = function(e){
    e = e || event;
    var clipboardData = e.clipboardData || window.clipboardData;
    if(!/^\d+$/.test(clipboardData.getData('text')))
        return false;
    }    
}
</script>    
```
### 加载事件

#### load

`load` 事件是最常用的一个事件，当页面完全加载后(包括所有图像、`javascript`文件、`CSS`文件等外部资源)，就会触发 `window` 上的 `load` 事件

IE8-浏览器不会为该事件设置`srcElement`属性，而其他浏览器的 `target` 属性指向 `document`

```js
window.onload = function(e){
    e = e || event;
    var target = e.target || e.srcElement;
    //IE8-浏览器返回null，其他浏览器返回document
    console.log(target);
}
```

`load` 事件不仅发生在 `document` 对象，还发生在各种外部资源上面。浏览网页就是一个加载各种资源的过程，图像(`image`)、样式表(`style sheet`)、脚本(`script`)、视频(`video`)、音频(`audio`)、`Ajax`请求(`XMLHttpRequest`)等等。这些资源和`document`对象、`window`对象、`XMLHttpRequestUpload`对象，都会触发`load`事件

::: tip
如果页面从浏览器缓存加载，并不会触发`load`事件
:::

::: tip
要在指定图像的src属性之前先指定事件，图像是从设置src属性之后开始下载
:::

```js
var img = new Image();
img.onload = function(){
    document.body.appendChild(img);
}
img.src="http://sandbox.runjs.cn/uploads/rs/26/ddzmgynp/chunfen.jpg";
<iframe id="test" src="https://baidu.com" frameborder="0"></iframe>
<script>
test.onload = function(){
    console.log(666);
}
</script>
```

`script` 也可以触发 `load` 事件，以便开发人员确定动态加载的 `javascript` 文件是否加载完毕。与图像不同，只有在设置了 `script` 元素的 `src` 属性并将该元素添加到文档后，才会开始下载 `javascript` 文件。换句话说，指定 `src` 属性和指定事件处理程序的先后顺序不重要

IE8-浏览器不支持该用法

```js
var script = document.createElement('script');
script.onload = function(){
    console.log(666);
}
document.body.appendChild(script);
script.src="http://files.baidu.com/files/jeffery/excanvas.js";
```

类似地，`link`元素可以触发`load`事件，且无兼容性问题。与`script`类似，在未指定`href`属性并将`link`元素添加到文档之前也不会开始下载样式表

```js
var link = document.createElement('link');
link.rel="stylesheet";
link.onload = function(){
    console.log(666);
}
document.getElementsByTagName('head')[0].appendChild(link);
link.href="http://sandbox.runjs.cn/uploads/rs/26/ddzmgynp/style.css";
```
#### error

`load` 事件在加载成功时触发，而`error`事件与之正相反，在加载失败时触发。凡是可以触发`load`事件的元素，同样可以触发`error`事件

任何没有通过`try-catch`处理的错误都会触发`window`对象的`error`事件

`error`事件可以接收三个参数：错误消息、错误所在的`URL`和行号。多数情况下，只有错误消息有用，因为URL只是给出了文档的位置，而行号所指的代码行既可能出自嵌入的`javascript`代码，也可能出自外部的文件

要指定`onerror`事件处理程序，可以使用`DOM0`级技术，也可以使用DOM2级事件的标准格式

```js
//DOM0级
window.onerror = function(message,url,line){
    alert(message);
}
//DOM2级
window.addEventListener("error",function(message,url,line){
    alert(message);
});
```

浏览器是否显示标准的错误消息，取决于`onerror`的返回值。如果返回值为`false`，则在控制台中显示错误消息；如果返回值为`true`，则不显示

```js
//控制台显示错误消息
window.onerror = function(message,url,line){
    alert(message);
    return false;
}
a;

//控制台不显示错误消息
window.onerror = function(message,url,line){
    alert(message);
    return true;
}
a;
```

这个事件处理程序是避免浏览器报告错误的最后一道防线。理想情况下，只要可能就不应该使用它。只要能够适当地使用`try-catch`语句，就不会有错误交给浏览器，也就不会触发`error`事件

图像也支持`error`事件。只要图像的`src`特性中的`URL`不能返回可以被识别的图像格式，就会触发`error`事件。此时的`error`事件遵循DOM格式，会返回一个以图像为目标的 `event` 对象

发生 `error` 事件时，图像下载过程已经结束，也就是不能再重新下载了。但是，可以在 `error` 事件中，重新设置图像的 `src` 属性，指向备用图像的地址

```js
var image = new Image();
document.body.appendChild(image);
image.onerror = function(e){
    image.src = 'smileBackup.gif';
}
image.src = 'smilex.gif';
```
#### abort

元素加载中止时，(如加载过程中按下ESC键，停止加载)，触发该事件，常用于图片加载

只有IE浏览器支持

```js
var image = new Image();
image.onabort = function(){
    console.log(111);
}
document.body.appendChild(image);
image.src = 'http://sandbox.runjs.cn/uploads/rs/26/ddzmgynp/chunfen.jpg';
```
#### unload

与 `load` 事件对应的是 `unload` 事件，该事件在文档被完全卸载后触发。刷新页面时，也会触发该事件

chrome/firefox/safari浏览器会阻止alert等对话框等控制台显示

```js
window.onunload = function(e){
    //chrome报错，firefox静默失败，IE弹出666
    alert(666);
}
window.onunload = function(e){
    //chrome和firefox控制台显示666，IE静默失败
    console.log(666);
}
```

在卸载页面的时候，会导致“空事件处理程序”的发生。“空事件处理程序”是指内存中存留的过时不用的事件处理程序，它们是造成Web应用程序内存与性能问题的主要原因。一般来说，最好的做法是在页面卸载之前，先通过`onunload` 事件处理程序移除所有事件处理程序。因此，只要是通过 `onload` 事件处理程序添加的东西，最后都应该通过 `onunload` 事件处理程序将它们移除

#### beforeunload

`beforeunload` 事件在关闭网页或刷新网页时触发。它一般地用来**防止用户不小心关闭网页**

如果要让 `beforeunload` 事件生效，必须满足以下两个条件之一：1、事件处理程序返回一个真值；2、事件对象 `event.returnValue` 返回一个真值。如果两个条件同时满足，则以第一个条件为准

chrome/safari/firefox在对话框中不显示指定文本，只显示默认文本。而IE浏览器会在对话框中显示返回值或 `returnValue` 值

```js
window.onbeforeunload = function(e){
    e = e || event;
    //IE浏览器显示指定文本，其他浏览器显示默认文本
    e.returnValue = '要离开吗？';    
}
```
#### DOMContentLoaded

`window` 的 `onload` 事件会在页面中的一切都加载完毕时触发，但这个过程可能会因为要加载的外部资源过多而颇费周折。而 `DOMContentLoaded` 事件则在形成完整的 `DOM` 树之后就会触发，而不理会图像、`javascript`文件、`CSS`文件或其他资源是否下载完毕。与`load`事件不同，`DOMContentLoaded`支持在页面下载的早期添加事件处理程序，这也就意味着用户能够尽早地与页面进行交互

网页的`javascript`脚本是同步执行的，所以定义`DOMContentLoaded`事件的监听函数，应该放在所有脚本的最前面。否则脚本一旦发生堵塞，将推迟触发 `DOMContentLoaded` 事件

要处理 `DOMContentLoaded` 事件，可以为`document`或`window`添加相应的事件处理程序，尽管这个事件会冒泡到`window`，但它的目标实际上是`document`

IE8-浏览器不支持该事件

```js
window.addEventListener('DOMContentLoaded',function(e){
    console.log(1);
})
```

对于不支持该事件的浏览器如IE8-浏览器，可以在页面加载期间设置一个时间为0毫秒的超时调用，且必须作为页面的第一个超时调用

```js
setTimeout(function(){
    console.log(1);    
},0)
```

#### readystatechange

`readystatechange` 事件发生在 `Document` 对象和 `XMLHttpRequest` 对象，它们的`readyState`属性发生变化时触发

这个事件的目的是提供与文档或元素的加载状态有关的信息。支持`readystatechange`事件的每个对象都有一个`readyState`属性，可能包含下列5个值中的一个

```js
uninitialized(未初始化)：对象存在但尚未初始化 
loading(正在加载)：对象正在加载数据
loaded(加载完毕)：对象加载数据完成
interactive(交互)：可以操作对象了，但还没有完全加载
complete(完成)：对象已经加载完毕
```

这些状态看起来很直观，但并非所有对象都会经历 `readyState` 的这几个阶段。换句话说，如果某个阶段不适用某个对象，则该对象完全可能跳过该阶段；并没有规定哪个阶段适用于哪个对象。显然，这意味着`readystatechange` 事件经常会少于4次，而`readyState`属性的值也不总是连续的

对于 `document` 而言，值为 `"interactive"` 的 `readyState` 会在与 `DOMContentLoaded` 大致相同的时刻触发 `readystatechange` 事件。此时，`DOM` 树已经加载完毕，可以安全地操作它了，因此就会进入交互 `interactive` 阶段。但与此同时，图像及其他外部文件不一定可用

```js
//'interactive'  'complete'
document.onreadystatechange = function(e){
    if(document.readyState == 'uninitialized'){
        console.log('uninitialized');
    }
    if(document.readyState == 'loading'){
        console.log('loading');
    }
    if(document.readyState == 'loaded'){
        console.log('loaded');
    }
    if(document.readyState == 'interactive'){
        console.log('interactive');
    }
    if(document.readyState == 'complete'){
        console.log('complete');
    }    
}
```

在与`load`事件一起使用时，无法预测两个事件触发的先后顺序。在包含较多或较大的外部资源的页面中，会在`load`事件触发之前先进入交互阶段；而在包含较少或较小的外部资源的页面中，则很难说`readystatechange`事件会发生在`load`事件前面

让问题变得更复杂的是，交互阶段可能会早于也可能会晚于完成阶段出现，无法确保顺序。在包含较多外部资源的页面中，交互阶段更有可能早于完成阶段出现；而在页面中包含较少外部资源的情况下，完成阶段先于交互阶段出现的可能性更大。因此，为了尽可能抢到先机，有必要同时检测交互和完成阶段

```js
document.onreadystatechange = function(){
    if(document.readyState == 'interactive' || document.readyState == 'complete'){
        console.log('loaded');
        document.onreadystatechange = null;
    }
}
```

对于上面的代码来说，当 `readystatechange` 事件触发时，会检测 `document.readyState` 的值，看当前是否已经进入交互阶段或完成阶段。如果是，则移除相应的事件处理程序以免在其他阶段再执行

另外，IE10-浏览器支持给 `script` 元素和 `link` 元素触发 `readystatechange` 事件，用来确定外部的`javascript`或`css`文件是否已经加载完成

```js
var script  = document.createElement('script');
script.onreadystatechange = function(){
    if( script.readyState == 'loaded'  || script.readyState == 'complete'){
        console.log('loaded');
        script.onreadystatechange = null;
    }
}
script.src="js/digit.js";
document.body.appendChild(script);
var link  = document.createElement('link');
link.rel="stylesheet";
link.onreadystatechange = function(){
    if( link.readyState == 'loaded'  || link.readyState == 'complete'){
        console.log('loaded');
        link.onreadystatechange = null;
    }
}
link.href="test.css";
document.getElementsByTagName('body')[0].appendChild(link);
```

## 焦点管理

### 焦点元素

到底哪些元素可以获得焦点呢？默认情况下，只有表单元素可以获得焦点。因为只有表单元素可以交互

```js
<input type="text" value="223">
```

让非表单元素获得焦点也是有办法的，先将 `tabIndex` 属性设置为 `-1`，再调用 `focus()` 方法

```html
<div id="test" style="height:30px;width:100px;background:lightgreen">div</div>
<button id="btn">div元素获得焦点</button>
<script>
btn.onclick = function(){
    test.tabIndex = -1;
    test.focus();    
}
test.onfocus = function(){
    this.style.background = 'pink';
}
</script>
```

**activeElement**

`document.activeElement` 属性用于管理 `DOM` 焦点，保存着当前获得焦点的元素

该属性IE浏览器不支持

```html
<div id="test" style="height:30px;width:100px;background:lightgreen">div</div>
<button id="btn">div元素获得焦点</button>
<script>
console.log(document.activeElement);//<body>
btn.onclick = function(){
    console.log(document.activeElement);//<button>
    test.tabIndex = -1;
    test.focus();    
    console.log(document.activeElement);//<div>
}
</script>
```

### 获得焦点

元素获得焦点的方式有4种，包括页面加载、用户输入(按tab键)、`focus()`方法和`autofocus`属性

**【1】页面加载**

默认情况下，文档刚刚加载完成时，`document.activeElement` 中保存的是 `body` 元素的引用。文档加载期间，`document.activeElement` 的值为 `null`

```html
<script>
console.log(document.activeElement);//null
</script>
<body>
<script>
console.log(document.activeElement);//<body>
</script>
</body>
```

**【2】用户输入(按tab键)**

　　用户通常可以使用 `tab` 键移动焦点，使用空格键激活焦点。比如，如果焦点在一个链接上，此时按一下空格键，就会跳转到该链接

说到 `tab` 键，就不能不提到 `tabindex` 属性。`tabindex` 属性用来指定当前 `HTML` 元素节点是否被 `tab` 键遍历，以及遍历的优先级

- 1、如果 `tabindex=-1`，`tab` 键跳过当前元素

- 2、如果 `tabindex=0`，表示 `tab` 键将遍历当前元素。如果一个元素没有设置`tabindex`，默认值就是0

- 3、如果 `tabindex` 大于0，表示 `tab` 键优先遍历。值越大，就表示优先级越小

下列代码中，使用 `tab` 键时，button获得焦点的顺序是2、5、1、3

```html
<div id="box">
    <button tabindex= "3">1</button>
    <button tabindex= "1">2</button>
    <button tabindex= "0">3</button>
    <button tabindex= "-1">4</button>
    <button tabindex= "2">5</button>    
</div>
<script>
box.onkeyup = function(){
    document.activeElement.style.background = 'pink';
}
</script>
```

**【3】focus()**

`focus()` 方法用于将浏览器的焦点设置到表单字段，即激活表单字段，使其可以响应键盘事件

前面介绍过，若非表单元素，设置为 `tabIndex` 为 `-1`，也可以获取焦点

```html
<span id="test1" style="height:30px;width:100px;">span</span>
<input id="test2" value="input">
<button id="btn1">span元素获得焦点</button>
<button id="btn2">input元素获得焦点</button>
<script>
btn1.onclick = function(){test1.tabIndex=-1;test1.focus();}
btn2.onclick = function(){test2.focus();}
</script>
```

**【4】autofocus**

`HTML5`表单字段新增了`autofocus`属性，只要设置这个属性，不用`javascript`就能自动把焦点移动到相应字段　

该属性只能用于表单元素，普通元素即使设置 `tabIndex="-1"` 也不生效

```html
<input autofocus value="abc">
```

**hasFocus()**

`document.hasFocus()` 方法返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。通过检测文档是否获得了焦点，可以知道是不是正在与页面交互

```js
console.log(document.hasFocus());//true
//在两秒钟内点击其他标签页，使焦点离开当前页面
setTimeout(function(){
    console.log(document.hasFocus());//false
},2000);
```

### 失去焦点

如果使用 `javascript` 使元素失去焦点，那么就要使用 `blur()` 方法

`blur()` 方法的作用是从元素中移走焦点。在调用 `blur()` 方法时，并不会把焦点转移到某个特定的元素上；仅仅是将焦点从调用这个方法的元素上面移走而已

```html
<input id="test" type="text" value="123">
<button id="btn1">input元素获得焦点</button>
<button id="btn2">input元素失去焦点</button>
<script>
btn1.onclick = function(){test.focus();}
btn2.onclick = function(){test.blur();}
</script>
```

### 焦点事件

焦点事件会在页面获得或失去焦点时触发。利用这些事件并与 `document.hasFocus()`方法及 `document.activeElement` 属性配合，可以知晓用户在页面上的行踪

焦点事件共包括下面4个

**blur**

`blur` 事件在元素失去焦点时触发。这个事件不会冒泡

**focus**

`focus` 事件在元素获得焦点时触发。这个事件不会冒泡

**focusin**

`focusin` 事件在元素获得焦点时触发。这个事件与 `focus` 事件等价，但它冒泡

**focusout**

`focusour` 事件在元素失去焦点时触发。这个事件与 `blur` 事件等价，但它冒泡

::: tip
关于focusin和focusout事件，除了IE浏览器支持DOM0级事件处理程序，其他浏览器都只支持DOM2级事件处理程序
:::

```html
<div id="box"style="display:inline-block;padding:25px;background-color:lightgreen;">
    <div id="boxIn" style="height: 50px;width: 50px;background-color:pink;">123</div>
</div>
<button id="btn1">内容为123的div元素获取焦点</button>
<button id="btn2">内容为123的div元素失去焦点</button>
<button id="reset">还原</button>
<script>
reset.onclick = function(){history.go();}
//focus()方法
btn1.onclick = function(){
    boxIn.tabIndex= -1;
    boxIn.focus();
}
//blur()方法
btn2.onclick = function(){
    boxIn.blur();
}
//focusin事件
if(boxIn.addEventListener){
    boxIn.addEventListener('focusin',handler)    
}else{
    boxIn.onfocusin = handler;
}
function handler(){
    this.style.backgroundColor ='lightblue';
}
if(box.addEventListener){
    box.addEventListener('focusin',handler)    
}else{
    box.onfocusin = handler;
}    
//blur事件
function fnBlur(){
    this.style.backgroundColor = 'orange';
}
boxIn.onblur = fnBlur;
box.onblur = fnBlur;
</script>
```

由运行结果可知，`focusin` 事件可冒泡；而 `blur` 事件不可冒泡


焦点事件常用于表单展示及验证

比如，获取焦点时，修改背景颜色；失去焦点时，还原背景颜色并验证

```html
<div id="box">
    <input id="input1" type="text" placeholder="只可以输入数字">
    <input id="input2" type="text" placeholder="只可以输入汉字">    
    <span id="tips"></span>
</div>
<script>
if(box.addEventListener){
    box.addEventListener('focusin',fnIn);
    box.addEventListener('focusout',fnOut);
}else{
    box.onfocusin = fnIn;
    box.onfocusout = fnOut;
}
function fnIn(e){
    e = e || event;
    var target = e.target || e.srcElement;
    target.style.backgroundColor = 'lightgreen';
}
function fnOut(e){
    e = e || event;
    var target = e.target || e.srcElement;
    target.style.backgroundColor = 'initial';
    //如果是验证数字的文本框
    if(target === input1){
        if(!/^\d*$/.test(target.value.trim())){
            target.focus();
            tips.innerHTML = '只能输入数字，请重新输入'
            setTimeout(function(){
                tips.innerHTML = ''
            },500);
        }
    }
    //如果是验证汉字的文本框
    if(target === input2){
        if(!/^[\u4e00-\u9fa5]*$/.test(target.value.trim())){
            target.focus();
            tips.innerHTML = '只能输入汉字，请重新输入'
            setTimeout(function(){
                tips.innerHTML = ''
            },500);
        }
    }    
}
</script>
```