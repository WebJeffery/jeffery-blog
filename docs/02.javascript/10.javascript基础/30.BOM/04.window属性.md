---
title: window 属性
date: 2020-04-03 19:27:01
permalink: /pages/eeweswwasweew
author: 
  name: jeffery
categories: 
  - javascript
tags: 
  - javascript
---

# window 属性

## 窗口基本操作


### 窗口位置

**获取**

浏览器(firefox不支持)提供了 `screenLeft` 和 `screenTop` 属性，分别用于表示窗口相对于屏幕左边和上边的位置

`screenX` 和 `screenY` 属性(IE8-)也提供相同的窗口位置信息

::: tip
screenLeft、screenTop、screenX和screenY都是只读属性，修改他们的值，并不会使得窗口发生移动
:::

获取窗口位置的兼容写法如下

```js
var leftPos = (typeof window.screenLeft == "number") ? window.screenLeft : window.screenX;
var topPos = (typeof window.screenTop == "number") ? window.screenTop : window.screenY;
    console.log(leftPos,topPos);  
```

**移动**

使用 `moveTo()` 和 `moveBy()` 方法可以将窗口精确移动到一个新位置，这两个方法只有 `IE` 浏览器支持

`moveTo()` 接收两个参数，分别是新位置的 `x` 和 `y` 坐标值

　`moveBy()` 接收两个参数，分别是水平和垂直方向上移动像素数

### 窗口大小

**获取**

`outerWidth` 和 `outerHeight` 属性用于表示浏览器窗口本身的尺寸

`innerWidth` 和 `innerHeight` 属性用于表示页面大小，实际上等于浏览器窗口尺寸大小减去浏览器自身边框及菜单栏、地址栏、状态栏等的宽度

`clientWidth` 和 `clientHeight` 表示的是布局视口，指 `CSS` 布局的尺寸

**调整**

使用 `resizeTo()` 和 `resizeBy()` 这两个方法可以用来调整浏览器窗口的大小 

- `resizeTo()` 接收两个参数：浏览器窗口的新宽度和新高度
- `resizeBy()` 接收两个参数：浏览器新窗口与原窗口的宽度和高度之差

### 打开窗口

`window.open()` 方法可以导航到一个特定的 `URL` ，也可以打开一个新的浏览器窗口。这个方法接收4个参数：要加载的`URL`、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值

- 传递第一个参数，默认在新窗口打开

```html
<div id="myDiv">点击此处</div>
<script>
myDiv.onclick = function(){
    window.open("http://baidu.com");
}
</script>  
```

- 第二个参数表示已有窗口或者框架的名称，或者是 `_self`、`_parent`、`_top`、`_blank` 等窗口打开方式

```html
<div id="myDiv">点击此处</div>
<script>
//在当前窗口打开
myDiv.onclick = function(){
    window.open("http://baidu.com",'_self');
}
</script>
```

- 第三个参数是一个逗号分隔的设置字符串，表示在新窗口中都显示哪些特性

![open](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_BOM_open.jpg)

- 第四个参数只在第二个参数命名的是一个存在的窗口时才有用。它是一个布尔值，声明了由第一个参数指定的 `URL` 是应用替换掉窗口浏览历史的当前条目(true)，还是应该在窗口浏览历史中创建一个新的条目(false)，后者是默认的设置


### 关闭窗口

`close()` 将关闭一个窗口。如果已经创建了 `Window` 对象` w`，可以使用如下的代码将它关掉

```html
<div>
    <span id="span1">打开窗口</span>
    <span id="span2">关闭窗口</span>    
</div>
<script>
var w;
span1.onclick = function(){
    w = window.open();
}
span2.onclick = function(){
    if(w){
        w.close();
    }
}
</script>
```

## location 对象

`location` 提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能

### 属性

`location` 将 `URL` 解析成独立的片段，让开发人员可以通过不同的属性访问这些片段

```js
var URL = 'http://localhost:8080/index.html#text?q=test';
console.log(location.hash);//#text?q=test
console.log(location.host);//localhost:8080
console.log(location.hostname);//localhost
console.log(location.href);//http://localhost:8080/index.html#text?q=test
console.log(location.pathname);///index.html
console.log(location.port);//8080
console.log(location.protocol);//http:
console.log(location.search);''
```

![location](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_BOM_location.jpg)



**解析查询字符串函数**



```js
function getQueryStringArgs(){
    //取得查询字符串并去掉开头的问号
    var qs = location.search.length > 0  ? location.search.substring(1) : "";
    //保存数据的对象
    var args = {};
    //取得每一项
    var items = qs.length ? qs.split("&") : [];
    var item,name,value;
    var len = items.length;
    //逐个将每一项添加到args对象中
    for(var i = 0; i < len; i++){
        item = items[i].split("=");
        name = decodeURIComponent(item[0]);
        value = decodeURIComponent(item[1]);
        if(name.length){
            args[name] = value;
        }
    }
    return args;
}
location.search = "?name=abc&password=123&callback=fn";
console.log(getQueryStringArgs());//[name: "abc", password: "123", callback: "fn"]

```

### 方法

**assign**

`assign()` 方法传递一个 `URL`，可以立即打开新 `URL` 并在浏览器的历史记录中生成一条记录。如果是将 `location.href` 或 `window.location`设置为一个 `URL` 值，相当于调用`assign()`方法。

```js
location.assign("http://baidu.com");
window.location = "http://baidu.com";
document.location = "http://baidu.com";
location.href = "http://baidu.com";//最常用
```

**replace()**

`replace` 接收一个参数即要导航到的 `URL`，结果虽然会导致浏览器位置改变，但不会在历史记录中生成新记录

```js
location.replace("http://baidu.com")
```

**reload()**

`reload()` 方法用于重新加载当前显示的页面。如果调用 `reload()` 方法时不传递任何参数，页面会以最有效的方式重新加载。也就是说，如果页面自上次请求以来并没有改变过，页面就会从浏览器缓存中重新加载。如果要强制从服务器重新加载，则需要传递参数 `true`

```js
//有可能从缓存中加载
location.reload();

//从服务器重新加载
location.reload(true);
```

### 事件

`HTML5` 新增了 `hashchange` 事件，以便在 `URL` 的参数列表(及URL中“#”号后面的所有字符串)发生变化时通知开发人员。之所以新增这个事件，是因为在 `Ajax` 应用中，开发人员经常要利用 `URL` 参数列来保存状态或导航信息

必须要把 `hashchange` 事件处理程序添加给 `window` 对象，然后 `URL` 参数列表只要变化就会调用它。此时的 `event` 对象应该额外包含两个属性：`oldURL` 和 `newURL` 。这两个属性分别保存着参数列表变化前后的完整 `URL`

::: tip
所有IE浏览器都不支持oldURL和newURL这两个属性
:::

```js
window.onhashchange = function(e){
    e = e || event;
    console.log(e.oldURL,e.newURL);
}
```

对于不支持这两个属性的IE浏览器，可以通过定期检查 `location.hash` 属性来模拟

```js
(function(window) {
  if ( "onhashchange" in window.document.body ) { return; }
  var location = window.location;
  var oldURL = location.href;
  var oldHash = location.hash;
  // 每隔100毫秒检查一下URL的hash
  setInterval(function() {
    var newURL = location.href;
    var newHash = location.hash;
    if ( newHash != oldHash && typeof window.onhashchange === "function" ) {
      window.onhashchange({
        type: "hashchange",
        oldURL: oldURL,
        newURL: newURL
      });
      oldURL = newURL;
      oldHash = newHash;
    }
  }, 100);

})(window);
```

## history 对象

`history` 对象保存着用户上网的历史记录


### length

`history.length` 属性保存着历史记录的 `URL` 数量。初始时，该值为1。如果当前窗口先后访问了三个网址，`history.length` 属性等于3

由于IE10+浏览器在初始时返回2，存在兼容性问题，所以该值并不常用

```js
history.length // 初始时，该值为1
history.length // 访问三个网址后，该值为3
```

### 方法

**go()**

`go` 方法接收一个参数，表示向后或向前跳转的页面数的一个整数值。负数表示向后跳转(类似于后退按钮)，正数表示向前跳转(类似于前进按钮)

```js
//后退一页
history.go(-1)
//前进一页
history.go(1);
//前进两页
history.go(2);
```

`go()` 方法无参数时，相当于 `history.go(0)`，可以刷新当前页面

**back()**

`back()` 方法用于模仿浏览器的后退按钮，相当于 `history.go(-1)`

**forward**

`forward()` 方法用于模仿浏览器的前进按钮，相当于 `history.go(1)`

### 增改记录 pushState、replaceState 和 popstate事件

`HTML5` 为 `history` 对象添加了两个新方法，`history.pushState()` 和`history.replaceState()` ，用来在浏览历史中添加和修改记录。`state` 属性用来保存记录对象，而 `popstate` 事件用来监听 `history` 对象的变化

IE9-浏览器不支持

**pushState()**

`history.pushState()` 方法向浏览器历史添加了一个状态。`pushState()` 方法带有三个参数：一个状态对象、一个标题(现在被忽略了)以及一个可选的`URL`地址

- `state`:  状态对象是一个由 `pushState()`方法创建的、与历史纪录相关的`javascript` 对象。当用户定向到一个新的状态时，会触发 `popstate` 事件。事件的 `state` 属性包含了历史纪录的 `state` 对象。如果不需要这个对象，此处可以填`null`


- `title`:  新页面的标题，但是所有浏览器目前都忽略这个值，因此这里可以填`null`


- `URL`: 这个参数提供了新历史纪录的地址。新 `URL` 必须和当前 `URL` 在同一个域，否则，`pushState()` 将丢出异常。这个参数可选，如果它没有被特别标注，会被设置为文档的当前 `URL`

假定当前网址是 `example.com/1.html`，使用 `pushState` 方法在浏览记录(history对象)中添加一个新记录
```js
var stateObj = { foo: 'bar' };
history.pushState(stateObj, 'page 2', '2.html');
```

`pushState` 方法不会触发页面刷新，只是导致 `history` 对象发生变化，地址栏的显示地址发生变化

如果`pushState`的`url`参数，设置了一个新的锚点值(即hash)，并不会触发`hashchange`事件，即使新的 `URL` 和旧的只在 `hash` 上有区别

如果设置了一个跨域网址，则会报错。这样设计的目的是，防止恶意代码让用户以为他们是在另一个网站上

**replaceState**

`history.replaceState` 方法的参数与 `pushState` 方法一模一样，不同之处在于 `replaceState()` 方法会修改当前历史记录条目而并非创建新的条目


假定当前网页是 `example.com/example.html`

```js
history.pushState({page: 1}, 'title 1', '?page=1');
history.pushState({page: 2}, 'title 2', '?page=2');
history.replaceState({page: 3}, 'title 3', '?page=3');

history.back()
// url显示为http://example.com/example.html?page=1
history.back()
// url显示为http://example.com/example.html
history.go(2)
// url显示为http://example.com/example.html?page=3
```

**popstate 事件**

每当同一个文档的浏览历史(即history对象)出现变化时，就会触发 `popstate` 事件

需要注意的是，仅仅调用 `pushState` 方法或 `replaceState` 方法，并不会触发该事件，只有用户点击浏览器倒退按钮和前进按钮，或者使用 `javascript` 调用`back()`、`forward()`、`go()`方法时才会触发。另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发

使用的时候，可以为 `popstate` 事件指定回调函数。这个回调函数的参数是一个`event`事件对象，它的 `state` 属性指向 `pushState` 和 `replaceState`方法为当前 `URL` 所提供的状态对象(即这两个方法的第一个参数)


```js
window.onpopstate = function (event) {
  console.log('location: ' + document.location);
  console.log('state: ' + JSON.stringify(event.state));
};
```

上面代码中的 `event.state`，就是通过 `pushState` 和 `replaceState` 方法，为当前 `URL` 绑定的 `state` 对象

这个`state`对象也可以直接通过`history`对象读取


## screen 对象

每个浏览器中的 `screen` 对象都包含着各不相同的属性，其中 `chrome` 包含9个属性，`firefox` 包含10个，IE8-浏览器包含14个，`IE9+` 浏览器包含17个。

`Chrome` 事例

```js
availHeight: 1080
availLeft: -1920
availTop: 40
availWidth: 1920
colorDepth: 24
height: 1080
orientation: {
  angle: 0
  onchange: null
  type: "landscape-primary""landscape-primary", onchange: null
}
pixelDepth: 24
width: 1920
```

17个属性说明

```
属性              说明

height            屏幕的像素高度
width             屏幕的像素宽度
availHeight       屏幕的像素高度减去系统部件高度之后的值(只读)
availWidth        屏幕的像素宽度减去系统部件宽度之后的值(只读)
left              当前屏幕距左边的像素距离[firefox返回0，chrome和IE不支持]
top               当前屏幕距上方的像素距离[firefox返回0，chrome和IE不支持]
availLeft         未被系统部件占用的最左侧的像素值(只读)[chrome和firefox返回0，IE不支持]
availTop          未被系统部件占用的最上方的像素值(只读)[chrome和firefox返回0，IE不支持]
bufferDepth       读、写用于呈现屏外位图的位数[IE返回0，chrome和firefox不支持]
colorDepth        用于表现颜色的位数(只读)[IE8-返回32，其他浏览器返回24]
pixelDepth        屏幕的位深(只读)[IE8-不支持，其他浏览器返回24]
deviceXDPI        屏幕实际的水平DPI(只读)[IE返回96，chrome和firefox不支持]
deviceYDPI        屏幕实际的垂直DPI(只读)[IE返回96，chrome和firefox不支持]
logicalXDPI       屏幕逻辑的水平DPI(只读)[IE返回96，chrome和firefox不支持]
logicalYDPI       屏幕逻辑的垂直DPI(只读)[IE返回96，chrome和firefox不支持]
updateInterval      读、写以毫秒表示的屏幕刷新时间间隔[IE返回0，chrome和firefox不支持]
fontSmoothingEnabled     是否启用了字体平滑(只读)[IE返回true，chrome和firefox不支持]
```


## navigator 对象

`navigator` 对象现在已经成为识别客户端浏览器的事实标准

## 属性

每个浏览器中的 `navigator` 对象也都有一套自己的属性, 存在于所有浏览器中的属性和方法

```
属性                    说明

appCodeName             浏览器名称[所有浏览器都返回Mozilla]
userAgent               浏览器的用户代理字符串
appVersion              浏览器版本
appMinorVersion         次版本信息[IE返回0，chrome和firefox不支持]
platform                浏览器所在的系统平台[所有浏览器都返回Win32]
plugins                 浏览器中安装的插件信息的数组
mimeTypes               在浏览器中注册的MIME类型数组

language                浏览器主语言[IE10-不支持，其他浏览器返回zh-CN]
systemLanguage          操作系统语言[IE返回zh-CN，chrome和firefox不支持]
userLanguage            操作系统默认语言[IE返回zh-CN，chrome和firefox不支持]
product                 产品名称[IE10-不支持，其他浏览器返回Gecko]
productSub              产品次要信息[IE不支持，chrome返回20030107，firefox返回20100101]
vendor                  浏览器品牌[chrome返回Google Inc.，IE和firefox不支持]
onLine                  是否连接因特网[IE根据实际情况返回true或false，chrome和firefox始终返回true]

cookieEnabled           表示cookie是否启用[所有浏览器都返回true]
javaEnabled             是否启用java[IE8-浏览器返回{}，其他浏览器返回function javaEnabled()]
buildID                 浏览器编译版本[firefox返回20170125094131，chrome和IE不支持]
cpuClass                计算机使用的CPU类型[IE返回x86，chrome和firefox不支持]
oscpu                   操作系统或使用的CPU[firefox返回Windows NT 10.0; WOW64，chrome和IE不支持]

```

### 检测插件

检测浏览器插件是一种最常见的检测例程

对于非 `IE`浏览器，可以使用plugins数组来达到这个目的该数组中的每一项都包含下列属性

```
name:插件的名字　
description:插件的描述
filename:插件的文件名
length:插件所处理的MIME类型数量
```

通过循环迭代每个插件并将插件的 `name` 与给定的名字进行比较

```js
function hasPlugin(name){
    name = name.toLowerCase();
    for(var i = 0; i < navigator.plugins.length; i++){
        if(navigator.plugins[i].name.toLowerCase().indexOf(name) > -1){
            return true;
        }
    }
}
//检测flash
console.log(hasPlugin("Flash"));//true   
```

对于IE浏览器，检测插件的办法是使用专有的 `ActiveXObject` 类型，并尝试创建一个特定插件的实例。IE是使用 `COM` 对象来实现插件的，而 `COM` 对象使用唯一标识符来标识。因此，想检查特定的插件就必须知道其COM标识符。例如，Flash的标识符是`ShockwaveFlash.ShockwaveFlash`

```js
function hasIEPlugin(name){
    try{
        new ActiveXObject(name);
        return true;
    }catch(ex){
        return false;
    }
}
//检测Flash
console.log(hasIEPlugin("ShockwaveFlash.ShockwaveFlash"))//true
```

【兼容写法】

```js
//检测非IE中的插件
function hasPlugin(name){
    name = name.toLowerCase();
    for(var i = 0; i < navigator.plugins.length; i++){
        if(navigator.plugins[i].name.toLowerCase().indexOf(name) > -1){
            return true;
        }
    }
}
//检测IE中的插件
function hasIEPlugin(name){
    try{
        new ActiveXObject(name);
        return true;
    }catch(ex){
        return false;
    }
}
function hasFlash(){
    var result = hasPlugin("Flash");
    if(!result){
        result = hasIEPlugin("ShockwaveFlash.ShockwaveFlash");
    }
    return result;
}
console.log(hasFlash());//true
```

### 用户代理检测

**浏览器检测**

【1】IE

IE3-IE10 都可以通过 `MSIE` 的版本号来判断，因为有的 `IE11` 并不出现 `MSIE` 字符，且 `safari中` 也有 `rv` 字段，所以IE11需要通过`rv`后的版本号和 `Trident`来配合判断

```js
function isIE(){
    var ua = navigator.userAgent;
    //检测Trident引擎，IE8+
    if(/Trident/.test(ua)){
        //IE11+
        if(/rv:(\d+)/.test(ua)){
            return RegExp["$1"];
        }    
        //IE8-IE10    
        if(/MSIE (\d+)/.test(ua)){
            return RegExp["$1"];
        }        
    }
    //检测IE标识，IE7-
    if(/MSIE (\d+)/.test(ua)){
        return RegExp["$1"];
    }    
}
console.log(isIE());//只有IE会返回版本号，其他浏览器都返回undefined
```

【2】chrome

```js
function isChrome(){
    var ua = navigator.userAgent;
    //先排除opera,因为opera只是在chrome的userAgent后加入了自己的标识
    if(!/OPR/.test(ua)){
        if(/Chrome\/(\S+)/.test(ua)){
            return RegExp["$1"];
        }    
    }    
}
console.log(isChrome());//只有Chrome会返回版本号，其他浏览器都返回undefined
```

【3】safari

```js
function isSafari(){
    var ua = navigator.userAgent;
    //先排除opera
    if(!/OPR/.test(ua)){
        //检测出chrome和safari浏览器
        if(/Safari/.test(ua)){
            //检测出safari
            if(/Version\/(\S+)/.test(ua)){
                return RegExp["$1"];
            }        
        }
    }    
}
console.log(isSafari());//只有safari会返回版本号，其他浏览器都返回undefined
```

【4】firefox

```js
function isFireFox(){
    if(/Firefox\/(\S+)/.test(navigator.userAgent)){
        return RegExp["$1"];
    }    
}
console.log(isFireFox());//只有firefox会返回版本号，其他浏览器都返回undefined
```

【5】opera

```js
function isOpera(){
    if(/OPR\/(\S+)/.test(navigator.userAgent)){
        return RegExp["$1"];
    }    
}
console.log(isOpera());//只有opera会返回版本号，其他浏览器都返回undefined 
```

### 识别操作系统

使用 `navigator.platform` 检测操作系统更加简单，因为其可能包括的值为“Win32”、“Win64”、“MacPPC”、“MacIntel”、“X11”和"Linux i686"等，且在不同浏览器中是一致的

而通过 `navigator.userAgent` 可以来得到 `window` 系统的详细信息

```js
windows版本                        ->             内核版本
Windows XP                        ->             5.1
Windows Vista                     ->             6.0
Windows 7                         ->             6.1
Windows 8                         ->             6.2
Windows 8.1                       ->             6.3
Windows 10技术预览版             　 ->             6.4
Windows 10.0　　　　　　            ->             10.0
```

```js
function whichSyStem(){
    var ua = navigator.userAgent;
    var pf = navigator.platform;
    if(/Mac/.test(pf)){
        return "Mac";
    }
    if(/X11/.test(pf) || /Linux/.test(pf)){
        return "Linux";
    }
    if(/Win/.test(pf)){
        if(/Windows NT (\d+\.\d+)/.test(ua)){
            switch(RegExp["$1"]){
                case "5.0":
                    return "Windows 2000";
                case "5.1":
                    return "Windows XP";
                case "6.0":
                    return "Windows Vista";
                case "6.1":
                    return "Windows 7";
                case "6.2":
                    return "Windows 8";
                case "6.3":
                    return "Windows 8.1";
                case "6.4":
                case "10.0":
                    return "Windows 10";                    
            }
        }
    }
}
console.log(whichSyStem())//Windows 10
```

### 识别移动端

```js
function whichMobile(){
    var ua = navigator.userAgent;
    if(/iPhone OS (\d+_\d+)/.test(ua)){
        return 'iPhone' + RegExp.$1.replace("_",".");
    }
    if(/iPad.+OS (\d+_\d+)/.test(ua)){
        return 'iPad' + RegExp.$1.replace("_",".")
    }
    if(/Android (\d+\.\d+)/.test(ua)){
        return 'Android' + RegExp["$1"];
    }
}
console.log(whichMobile())
```
