---
title: JavaScript 语法
date: 2020-12-25 14:27:01
permalink: /pages/23a3errwdasweew
author: 
  name: jeffery
categories: 
  - javascript
tags: 
  - javascript
---

# JavaScript 语法


## 词法结构

<!-- <common-codepen-snippet title="Event handling" slug="dyoeGjW" />
<common-codepen-snippet :team="false" user="jefferyxzf" title="Event handling" slug="rNmwKGw" /> -->

词法结构是一套基础性规则，用来描述如何使用 `javascript` 来编写程序

### 定义

`javascript` 是一门动态的、弱类型的解释型编程语言，非常适合面向对象和函数式的编程风格。`javascript` 的语法源自 `java`，它的一等函数来自 `scheme`，它的基于原型的继承来自 `self`

::: tip 编程语言
编程语言分为动态类型语言和静态类型语言两种。 动态类型语言是指在运行期间才去做数据类型检查的语言，也就是说，在用动态类型语言编程时，不用给任何变量指定数据类型，该语言会在第一次赋值给变量时，在内部将数据类型记录下来。`javascript` 就是动态类型语言
:::

`javascript` 由三部分组成：`ECMAScript`、`DOM` 和 `BOM`

- `ECMAScript` 由 `ECMA-262` 定义，提供核心语言功能（ECMA是欧洲计算机制造商协会）
- `DOM` (Document Object Model)文档对象模型，提供访问和操作网页内容的方法和接口
- `BOM` (Browser Object Model)浏览器对象模型，提供与浏览器交互的方法和接口

## 语句

`JavaScript` 程序的执行单位为行 `line`，也就是一行一行地执行。一般情况下，每一行就是一个语句。

代码示例：
```js
var a = 1 + 3;
```

语句和表达式的区别：语句主要为了进行某种操作，一般情况下不需要返回值，例如 `var a = 1 + 3;` 是赋值语句；表达式则是为了得到返回值，例如 `1 + 3` 是表达式（expression），计算返回值是 3。

语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。
```js
var a = 1 + 3 ; var b = 'abc';
```

表达式不需要分号结尾。一旦在表达式后面添加分号，则 `JavaScript` 引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。
```js
1 + 3;
'abc';
```
上面两行语句只是单纯地产生一个值，并没有任何实际的意义。

### 大小写敏感

`javascript` 是对大小写敏感的，定义的关键字、变量、函数名和所有的标识符都必须采取一致的大小写形式

```js
//'online'、'Online'、'OnLine'、'ONLINE'是四个不同的变量名
```

::: warning
HTML不区分大小写(尽管XHTML区分大小写)。
:::

### 注释

`JavaScript` 提供两种注释的写法：一种是单行注释，用`//`起头；另一种是多行注释，放在`/*`和`*/`之间。
```js
// 这是单行注释

/*
 这是
 多行
 注释
*/
```

## 标识符

标识符(Identifier)是一个名字，用来对变量、函数、属性、参数进行命名，或者用做某些循环语句中的跳转位置的标记

```js
//变量
var Identifier = 123;
//属性
(new Object).Identifier = 'test';
//函数及参数
function IdentifierName(Identifier1){};
//跳转标记
Identifier:
for(var i = 0; i < 5; i++){
    if(i == 3){
        break Identifier;
    }
}
```

`javascript` 标识符名允许包含字母、数字、美元符号和下划线(但第一个字符不允许是数字)

```js
//错误示范
6num  //开头不能用数字
%sum //开头不能用除(_ $)外特殊符号,如(%  + /等)
sum+num //开头中间不能使用除(_ $)外特殊符号，如(%  + /等)
```

## 变量

  变量也是 **标识符**，用于存储数据值，访问这个变量等同于引用这个值。

### 变量的声明

JavaScript 有三种声明方式：  

* `var` 声明一个变量，可赋一个初始值。   
* `let` 声明一个块作用域变量，可赋一个初始值。  
* `const` 声明一个块作用域的只读命名的常量，对象类型可以修改属性。   

**变量场景解析**

* 若没有为变量赋初始值，则值默认为`undefined`；  
```js
let a;
console.log(a);   // undefined
```

* 若没有声明变量而直接使用，会抛出`ReferenceError`错误；   
```js
console.log(b);   // Uncaught ReferenceError: b is not defined
```

* 当变量值为 `undefined` 时，布尔值环境会当做 `false` ，数值环境会当做 `NaN`；   
```js
var a;
if(!a){
    console.log('a为undefined'); // a为undefined
}
a + 1;  // NaN
```

* 当变量值为 `null` 时，布尔值环境会当做`false`，数值环境会当做`0`；  
```js
let a = null;
if(!a){
    console.log('a为unll'); // a为unll
}
a + 1;  // 1
```

### 变量作用域

变量的作用域(scope)是程序源代码中定义这个变量的区域，是变量可以被访问到到范围

`javascript` 变量作用域分为全局作用域、局部作用域和块级作用域

- **全局作用域** 是最外围的一个全局执行环境，在 `web` 浏览器中，`window` 对象是全局执行环境，在 `javascript` 代码中的任何地方都可以访问到。**全局作用域直到应用程序退出例如关闭网页或浏览器时才会被销毁**
- **函数作用域** 即声明在函数内部，仅在当前函数内可以访问；
- **块级作用域** 即在花括号中使用 `let`、`const` 声明的变量

::: tip
  **ES6之中**，在全局执行环境，`let`、`const`、`class`声明的变量不属于顶层对象 `window` 的属性，即ES6开始，全局变量和顶层对象的属性是分开的。 
:::

```js
if(true){
    var a = 1;
}
a; // 1

if(true){
    let b = 2;
}
b; // ReferenceError: b is not defined
```

**常量**

ES6之后我们可以使用`const`来声明一个只读的常量，并且在**声明时必须赋值**，之后在相同作用域中**不能赋值**也**不能重新声明**，否则报错。   
```js
const a;   
// Uncaught SyntaxError: Missing initializer in const declaration

const b = 'leo';
b = 'hi';
// Uncaught TypeError: Assignment to constant variable.

function f(){
    const a1 = 'hi';
    console.log(a1);
}
f(); // 'hi'
const a1 = 'hi leo';
a1; // "hi leo"
```

尽管`const`声明的变量不能直接修改值，但是对于对象和数组，却是不受保护可以修改的：  
```js
const a = {name:'leo',age:25};
a.name = 'pingan'; // a => {name: "pingan", age: 25}

const b = ['hi', 'leo'];
b[1] = 'pingan';   // b => ["hi", "pingan"]
```


### 变量提升

`JavaScript` 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。如果解析过程中遇到 `var`、`function` 声明，将声明的变量或函数提升到语句的顶部，这叫做 **变量提升** 或 **函数提升**

::: warning
函数提升优先于变量提升
:::

```js
// ES5及之前
console.log(a);   // undefined，变量提升
var a = 1;
console.log(a);   // 1

// ES6开始
console.log(b);   // Uncaught ReferenceError: b1 is not defined
let b = 2;
console.log(b);   // 2
```


## 条件语句

JavaScript 提供 `if` 结构和 `switch` 结构，完成条件判断，即只有满足预设的条件，才会执行相应的语句。

**if 结构**

```js
if (布尔值)
  语句;

// 或者
if (布尔值) 语句;
```

**if...else 结构**

```js
if (m === 3) {
  // 满足条件时，执行的语句
} else {
  // 不满足条件时，执行的语句
}
```

**switch 结构**

多个if...else连在一起使用的时候，可以转为使用更方便的switch结构。
```js
switch (fruit) {
  case "banana":
    // ...
    break;
  case "apple":
    // ...
    break;
  default:
    // ...
}
```
::: warning
- 需要注意的是，每个 `case` 代码块内部的 `break` 语句不能少，否则会接下去执行下一个 `case` 代码块，而不是跳出 `switch` 结构。
- `switch` 语句后面的表达式，与 `case` 语句后面的表示式比较运行结果时，采用的是严格相等运算符 `===`，而不是相等运算符 `==`，这意味着比较时不会发生类型转换
:::

**三元运算符 ?:**

```js
(条件) ? 表达式1 : 表达式2

var even = (n % 2 === 0) ? true : false;
```

## 循环语句

循环语句用于重复执行某个操作，它有多种形式。

**while 循环**

`while` 语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块。
```js
while (条件)
  语句;

// 或者
while (条件) 语句;
```

**for 循环**

for语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件
```js
for (初始化表达式; 条件; 递增表达式)
  语句

// 或者

for (初始化表达式; 条件; 递增表达式) {
  语句
}
```
for语句后面的括号里面，有三个表达式。

- 初始化表达式（initialize）：确定循环变量的初始值，只在循环开始时执行一次。
- 条件表达式（test）：每轮循环开始时，都要执行这个条件表达式，只有值为真，才继续进行循环。
- 递增表达式（increment）：每轮循环的最后一个操作，通常用来递增循环变量。

**do...while 循环**

`do...while` 循环与 `while` 循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件
```js
do
  语句
while (条件);

// 或者
do {
  语句
} while (条件);
```

## break 语句和 continue 语句

`break` 语句和 `continue` 语句都具有跳转作用，可以让代码不按既有的顺序执行。

`break` 语句用于跳出代码块或循环。

```js
var i = 0;

while(i < 100) {
  console.log('i 当前为：' + i);
  i++;
  if (i === 10) break;
}
```
上面代码只会执行10次循环，一旦i等于10，就会跳出循环

`continue` 语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。
```js
var i = 0;

while (i < 100){
  i++;
  if (i % 2 === 0) continue;
  console.log('i 当前为：' + i);
}
```
上面代码只有在i为奇数时，才会输出i的值。如果i为偶数，则直接进入下一轮循环


## 严格模式

**严格模式的作用**

- 消除js语法的一些不合理、不严谨、不安全问题，减少怪异行为并保证代码运行安全
- 提高编译器效率，增加运行速度

**使用**

- 整个脚本启用严格模式，在顶部执行：`"use strict"`;
- 在指定函数中执行严格模式，在函数体第一行：`"use strict"`
- 不支持 `strict` 模式的浏览器把 `"use strict"` 当做一个字符串语句执行，支持 `strict` 模式的浏览器将开启 `strict` 模式
- 支持严格模式的浏览器包括 `IE10+、Firefox4+、safari12+、opera12+、chrome`

### 严格模式8条规则

【1】变量

不允许意外创建全局变量

```js
"use strict";
message = 'hello world!';
```

不能对变量调用 `delete` 操作符

```js
"use strict";
var color = 'red';
delete color;
```

【2】对象

不能为只读属性赋值
```js
"use strict";
var person = {
    name:'cook'
};
Object.defineProperty(person,'name',{
    writable: false
});
person.name = 'Nicholas';
```

不能为不可配置的属性使用 `delete` 操作
```js
"use strict";
var person = {
    name:'cook'
};
Object.defineProperty(person,'name',{
    configurable: false
});
delete person.name;
```

【3】函数

参数必须唯一
```js
"use strict";
function sun(num,num){
    //TODO
}
```

修改形参不会反映到 `arguments` 中
```js
function showValue(value){
    value = "Foo";
    alert(arguments[0]);
    //非严格模式:"Foo"
    //严格模式:"Hi"
}
showValue("Hi");
```

不允许使用 `arguments.callee` 和 `arguments.caller`
```js
"use strict";
function fn(num){
    return arguments.callee(num);
}
fn(2);
```

【4】不允许 `eval()` 在包含上下文中创建变量或函数
```js
"use strict";
function fn(){
    eval("var x=10");
    alert(x);
}
fn();

//允许以下操作
var result = eval("var x = 10, y = 11; x+y");
alert(result);//21
```

【5】不允许使用 `eval` 和 `arguments` 作为标识符，也不允许读写他们的值

```js
"use strict";
var eval = 10;
var arguments = 20;
```

【6】不允许 `this` 值为 `null` 或 `undefined`
```js
"use strict";
var color = "red";
function fn(){
    alert(this.color);
}
fn();
```

【7】不允许使用 `with` 语句
```js
"use strict";
with(location){
    alert(href);
}
```

【8】不允许使用八进制字面量
```js
"use strict";
var value = 010;
```

## eval 函数

`eval()` 是一个全局函数，`javascript` 通过 `eval()` 来解释运行由 `javascript` 源代码组成的字符串

### eval 用法

`eval()` 只有一个参数，如果传入的参数不是字符串，它直接返回这个参数。如果参数是字符串，它会把字符串当成 `javascript` 代码进行编译。如果编译失败则抛出一个语法错误(syntaxError)异常。如果编译成功，则开始执行这段代码，并返回字符串中的最后一个表达式或语句的值，如果最后一个表达式或语句没有值，则最终返回`undefined`。如果字符串抛出一个异常，这个异常将把该调用传递给 `eval()`

```js
var num = 1;
var str = 'test';
console.log(eval(num));//1
console.log(eval(str));//ReferenceError: test is not defined
````

### eval 作用域

`eval()` 使用了调用它的变量作用域环境。也就是说，它查找变量的值和定义新变量和函数的操作和局部作用域中的代码完全一样

```js
var b = 2;
function foo(str,a){
    eval(str);
    console.log(a,b);
}
foo('var b = 3;',1);//1 3
```

### 副作用

`javascript` 解释器进行了大量的代码分析和优化。而 `eval()` 的问题在于，用于动态执行的代码通常不能分析，于是解释器也无法对其进行优化，这会导致性能下降

与eval()类似的有 `setTimeout()`、`setInterval()`、`new Function()`等，这些函数都可以以字符串作为参数，在程序运行时动态执行。这种执行机制带来的好处无法抵消其性能上的损失，所以应该尽量避免使用

## with

定义 `with` 语句的目的主要是为了简化多次编写同一对象的工作

`with` 语句将 `object` 添加到作用域链的头部，然后执行 `statement`，最后把作用域链恢复到原始状态

```js
with(object){
    statement;
}
```

### 作用

在对象嵌套层次很深的时候通常会使用 `with` 语句来简化代码编写。而本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域

在客户端 `javascript` 中，可能会使用类似下面这种表达式来访问一个 `HTML` 表单中的元素

```js
document.forms[0].address.value
```

如果这种表达式在代码中多次出现，则可以使用with语句将form对象添加到作用域链的顶层

```js
with(document.forms[0]){
    name.value = '';
    address.value = '';
    emai.value = '';
}

```

这种方法减少了大量的输入，不用再为每个属性名添加 `document.forms[0]` 前缀。这个对象临时挂载在作用域链上，当 `javascript` 需要解析诸如address的标识符时，就会自动在这个对象中查找 

  注意：`with` 语句提供了一种读取对象的属性的快捷方式，但它并不能创建对象的属性

  如果对象 `o` 有一个属性 `x`，那么下面代码给这个属性赋值为 `1`

```js
var o  = {x:0};
with(o) x = 1;
console.log(o.x);//1
```

如果 `o` 中没有定义属性 `x` ，下面代码和不使用with语句的代码 `x=1` 是一模一样的。这是因为对变量 `x` 进行了 `LHS` 查询，并将 `1` 赋值给它

```js
var o  = {};
with(o) x = 1;
console.log(o.x);//undefined
console.log(x);//1
```

### 副作用

与 `eval` 类似，`with` 语句的 `javascript` 代码非常难于优化，同时也会给调试代码造成困难，并且同没有使用 `with` 语句的代码相比，它运算得更慢

  而且，如果`with`语句使用不当，还有可能造成变量泄漏，污染全局作用域的情况

```js
var x = 1;
var o = {};
with(o){
    x = 2;
}
console.log(x);//2
console.log(o.x);//undefined
```