---
title: Vue 组件原理分析
date: 2021-04-21 20:45:35
permalink: /pages/sswwwess31ef7
author: jeffery
categories: 
  - Vue 源码
tags: 
  - Vue 源码
---

# Vue 组件原理分析

阅读源码的注释仓库 [github](https://github.com/JefferyXZF/vue/tree/dev-doc)
## 组件渲染流程图

![组件化源码分析](https://gitee.com/FIF/pic-beg/raw/master/images/logo/1620540437346-component-analyse.png)

## 思考

- 全局注册组件和局部注册组件原理，它们之间的异同是什么？
- 组件是如何渲染成DOM？
- 组件的 `$root`, `$parent`, `$children` 是如何建立的层级关系？
- `mixins`, `extends` 定义的组件选项 `components` 是如何被使用的？
- 组件的两种使用场景：函数式组件和异步组件，它们的实现原理是什么，解决什么问题？

带着这几个问题一起来分析 `Vue` 组件的实现原理。


## 概要

使用 `vue` 框架开发页面，其实本质上就是写一个个组件。独立的组件将页面结构化，开发者可以专注于某个功能的开发和扩展；同时组件的设计理念又使得功能具有复用性，不同的页面可以进行组件功能的共享。

了解组件注册的实现思路，分析组件渲染的流程；知道组件和组件之间是如何建立联系的，组件之间是如何通信的，组件的使用场景有哪些，掌握这些底层的实现思路对于在解决`Vue`组件相关问题上有明显的帮助。


## 组件两种注册方式

`Vue` 组件在使用之前需要进行注册，而注册的方式有两种，全局注册和局部注册。在进入源码分析之前，先回忆一下两者的用法，以便后续掌握两者的差异。



### 全局注册

**Vue.component( id, [definition] )**

- 参数： 

  - `{string} id`
  - `{Function | Object} [definition]`

- 用法：

  注册或获取全局组件。注册还会自动使用给定的 `id` 设置组件的名称

```js
// 注册组件，传入一个扩展过的构造器
Vue.component('my-component', Vue.extend({ /* ... */ }))

// 注册组件，传入一个选项对象 (自动调用 Vue.extend)
Vue.component('my-component', { /* ... */ })

// 异步组件
Vue.component('my-component', function(resolve, reject) {
    require([./componentPath], resolve)
})

// 获取注册的组件 (始终返回构造器)
var MyComponent = Vue.component('my-component')
```

**全局注册的组件需要在全局实例化Vue前调用**，注册之后可以用在任何新创建的`Vue`实例中调用。


### 局部注册

当只需要在某个局部用到某个组件时，可以使用局部注册的方式进行组件注册，此时局部注册的组件只能在注册该组件内部使用。

- **类型**：`Object`
- **详细**：

包含 Vue 实例可用组件的哈希表。

```js
var myTest = {
    template: '<div>{{test}}</div>',
    data () {
        return {
            test: 'child'
        }
    }
}
var vm = new Vue({
    el: '#app',
    component: {
        myTest
    }
})
```



### 注册过程分析

**全局注册**

简单回顾组件的两种注册方式后，我们来看注册过程到底发生了什么，以全局组件注册为例。它通过`Vue.component(name, {...})`进行组件注册，`Vue.component` 是在 `Vue` 源码引入阶段定义的静态方法。

```js
// 路径：src/core/global-api/index.js
// 初始化全局api
function initGlobalAPI(Vue) {
  // ...
  initAssetRegisters(Vue);
}

```

`initAssetRegisters` 挂载全局方法 `component`, `filter`, `directive`

```js
var ASSET_TYPES = [
    'component',
    'directive',
    'filter'
];

// src/core/global-api/assets.js
function initAssetRegisters(Vue){
    // 定义ASSET_TYPES中每个属性的方法，其中包括component
    ASSET_TYPES.forEach(function (type) {
    // type: component,directive,filter
      Vue[type] = function (id,definition) {
          if (!definition) {
            // 直接返回注册组件的构造函数
            return this.options[type + 's'][id]
          }
          if (type === 'component') {
            // 验证component组件名字是否合法
            validateComponentName(id);
          }
          if (type === 'component' && isPlainObject(definition)) {
            // 组件名称设置
            definition.name = definition.name || id;
            // Vue.extend() 创建子组件，返回子类构造器
            definition = this.options._base.extend(definition);
          }
          // 为Vue.options 上的components属性添加将子类构造器
          this.options[type + 's'][id] = definition;
          return definition
        }
    });
}
```

`Vue.component`有两个参数，一个是需要注册组件的组件名，另一个是组件选项，如果第二个参数没有传递，则会直接返回注册过的组件选项。否则意味着需要对该组件进行注册，注册过程先会对组件名的合法性进行检测，要求组件名不允许出现非法的标签，包括`Vue`内置的组件名，如`slot, component`等。

```js
function validateComponentName(name) {
    if (!new RegExp(("^[a-zA-Z][\\-\\.0-9_" + (unicodeRegExp.source) + "]*$")).test(name)) {
      // 正则判断检测是否为非法的标签
      warn(
        'Invalid component name: "' + name + '". Component names ' +
        'should conform to valid custom element name in html5 specification.'
      );
    }
    // 不能使用Vue自身自定义的组件名，如slot, component,不能使用html的保留标签，如 h1, svg等
    if (isBuiltInTag(name) || config.isReservedTag(name)) {
      warn(
        'Do not use built-in or reserved HTML elements as component ' +
        'id: ' + name
      );
    }
  }
```

组件名的合法性检测后，如果第二个参数是一个纯对象，调用 `extend` 方法，此时的`this.options._base`代表的就是`Vue`。



`Vue.extend` 执行流程分析：

- `Vue.extend` 方法基于`Vue`去创建一个子类，此时的父类是`Vue`，并且创建子类过程使用原型继承父类 `Vue` , 这时子组件就可以调用`Vue` 方法，比如 `$emit`, `$on` 等。
- `mergeOption` 将定义的选项和父类的选项进行合并，合并遵循合并策略
- 子类挂载 `extend, mixin, use, component, filter, directive` 静态方法
- 处理递归组件，最终返回一个子类构造器 `Sub`。

```js
Vue.extend = function (extendOptions: Object): Function {
    //...
    const name = extendOptions.name || Super.options.name
    if (process.env.NODE_ENV !== 'production' && name) {
      validateComponentName(name) // 检验组件名称
    }

    const Sub = function VueComponent (options) {
      this._init(options)
    }
    // 原型继承
    Sub.prototype = Object.create(Super.prototype)
    Sub.prototype.constructor = Sub
    Sub.cid = cid++
    // 子类和父类构造器的配置选项进行合并
    Sub.options = mergeOptions(
      Super.options,
      extendOptions
    )
    Sub['super'] = Super

    // 继承父类方法
    Sub.extend = Super.extend
    Sub.mixin = Super.mixin
    Sub.use = Super.use

    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type]
    })
    // 递归组件
    if (name) {
      Sub.options.components[name] = Sub
    }
		// ...
    return Sub
  }
```

全局注册组件就是 `Vue` 实例化前创建一个基于`Vue`的子类构造器，并将组件的信息加载到实例`options.components`对象中。



**局部注册**

局部注册，本质上也是调用 `Vue.extend` 方法得到一个 `Vue` 子类构造器



**局部注册组件和全局注册组件的原理一样，区别在于：**

- 全局注册添加的子组件在根实例下；局部注册添加的对象配置是在某个组件下

- 全局注册添加的是一个函数；局部注册添加的是一个对象

因此局部注册中缺少了一步构建子类构造器的过程，这个过程放在哪里进行呢？ 先看 `createComponent` 的源码，源码中根据选项是对象还是函数来区分局部和全局注册组件【异步组件除外】，**如果选项的值是对象，则该组件是局部注册的组件，此时在创建子`Vnode`时会调用 父类的`extend`方法去创建一个子类构造器。**

```js
// src/core/vdom/create-component.js
function createComponent (
  Ctor: Class<Component> | Function | Object | void, // 子类构造器
  data: ?VNodeData,
  context: Component,
  children: ?Array<VNode>,
  tag?: string // 子组件占位符
): VNode | Array<VNode> | void {

  // _base存放了Vue,作为基类
  const baseCtor = contextß.$options._base

  // 针对局部组件注册场景
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor)
  }
// ...
}
```
从这里可以得出结论，不管是全局注册组件还是局部注册组件都要调用 `Vue.extend` 方法


## 组件渲染流程

介绍完组件注册过程，接下来分析组件挂载和渲染过程。`new Vue` 初始化后，会执行 `$mount` 方法挂载，`runtime + compiler` 版本`$mount` 包含编译器将 `template` 转化为 `render` 函数。在实例化 `render Watcher` 调用 `updateComponent` ，执行 `render` 函数调用 `createElement` 得到 `vnode`, 最终组成 `vnode Tree` ，最后调用 `_update` 将 `vnode Tree` 转化为真实的 `DOM Tree`

![image-20210509135812496](https://gitee.com/FIF/pic-beg/raw/master/images/logo/1620539916261-image-20210509135812496.png)

### 具体流程分析

结合实际的例子对照着流程图分析一下这个过程：

- 场景

  ```javascript
  Vue.component('test', {
  template: '<span>hello world</span>'
  })
  
  var vm = new Vue({
  el: '#app',
  template: '<div><test></test></div>'
  })
  ```

- 父`render`函数

  ```javascript
  function() {
  with(this){return _c('div',[_c('test')],1)}
  }
  ```




- `Vue`根实例初始化会执行 `vm.$mount(vm.$options.el)`实例挂载的过程，完整流程会经历`render`函数生成`Vnode`，以及`Vnode`生成真实`DOM`的过程。
- `render`函数生成`Vnode`过程中，子会优先父执行生成`Vnode`过程，也就是`_c('test')`函数会先被执行。`'test'`会先判断是普通的`html`标签还是组件的占位符。
- 如果为一般标签，会执行`new Vnode`过程；如果是组件的占位符，则会在判断组件已经被注册过的前提下进入`createComponent`创建子组件`Vnode`的过程。
- `createComponent`是创建组件`Vnode`的过程，创建过程会再次**合并选项配置，并安装组件相关的内部钩子**，最后通过`new Vnode()`生成以`vue-component`开头的`Virtual DOM`
- `render`函数执行过程也是一个循环递归调用创建`Vnode`的过程，执行3，4步之后，完整的生成了一个包含各个子组件的`Vnode tree`



`render` 函数执行，调用 `_createElement` 函数生成 `vnode`

```js
// 内部执行将render函数转化为Vnode的函数
function _createElement(context,tag,data,children,normalizationType) {
  ···
  if (typeof tag === 'string') {
    // 子节点的标签为普通的html标签，直接创建Vnode
    if (config.isReservedTag(tag)) {
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      );
    // 子节点标签为注册过的组件标签名，则子组件Vnode的创建过程
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // 创建子组件Vnode
      vnode = createComponent(Ctor, data, context, children, tag);
    }
  }
}
```



`config.isReservedTag(tag)`用来判断标签是否为普通的`html`标签，如果是普通节点会直接创建`Vnode`节点，如果不是，则需要判断这个占位符组件是否已经注册到，可以通过`context.$options.components[组件名]`拿到注册后的组件选项。如何判断组件是否已经全局注册，看看`resolveAsset`的实现。

```js
// 需要明确组件是否已经被注册
  function resolveAsset (options,type,id,warnMissing) {
    // 标签为字符串
    if (typeof id !== 'string') {
      return
    }
    // 这里是 options.component
    var assets = options[type];
    // 这里的分支分别支持大小写，驼峰的命名规范
    if (hasOwn(assets, id)) { return assets[id] }
    var camelizedId = camelize(id);
    // 驼峰转化
    if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
    // 首字符转化为大写
    var PascalCaseId = capitalize(camelizedId);
    if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }
    // fallback to prototype chain
    var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
    if (warnMissing && !res) {
      warn(
        'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
        options
      );
    }
    // 最终返回子类的构造器
    return res
  }
```



拿到注册过的子类构造器后，调用`createComponent`方法创建子组件`Vnode`

```js
 // 创建子组件过程
  function createComponent (
    Ctor, // 子类构造器
    data,
    context, // vm实例
    children, // 子节点
    tag // 子组件占位符
  ) {
    ···
    // Vue.options里的_base属性存储Vue构造器
    var baseCtor = context.$options._base;
    // 针对局部组件注册场景
    if (isObject(Ctor)) {
      Ctor = baseCtor.extend(Ctor);
    }
    data = data || {};
    // 构造器配置合并
    resolveConstructorOptions(Ctor);
    // 挂载组件钩子
    installComponentHooks(data);
    // return a placeholder vnode
    var name = Ctor.options.name || tag;
    // 创建子组件vnode，名称以 vue-component- 开头, children 为空
    var vnode = new VNode(("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),data, undefined, undefined, undefined, context,{ Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },asyncFactory);
    return vnode
  }
```



其中关键是安装组件钩子函数，几个钩子函数会在后续`patch`过程的不同阶段执行，这里看看`installComponentHooks`安装组件钩子函数时做了哪些操作。

```js
  // 组件内部自带钩子
 var componentVNodeHooks = {
    init (vnode, hydrating) {
    },
    prepatch (oldVnode, vnode) {
    },
    insert (vnode) {
    },
    destroy (vnode) {
    }
  };
var hooksToMerge = Object.keys(componentVNodeHooks);
// 将componentVNodeHooks 钩子函数合并到组件data.hook中 
function installComponentHooks (data) {
    var hooks = data.hook || (data.hook = {});
    for (var i = 0; i < hooksToMerge.length; i++) {
      var key = hooksToMerge[i];
      var existing = hooks[key];
      var toMerge = componentVNodeHooks[key];
      // 如果钩子函数存在，则执行mergeHook$1方法合并
      if (existing !== toMerge && !(existing && existing._merged)) {
        hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;
      }
    }
  }
function mergeHook$1 (f1, f2) {
  // 返回一个依次执行f1,f2的函数
    var merged = function (a, b) {
      f1(a, b);
      f2(a, b);
    };
    merged._merged = true;
    return merged
  }
```



## 组件 Vnode 渲染真实 DOM

### 具体流程分析

- 经过`vm._render()`生成完整的`Virtual Dom`树后，紧接着执行`Vnode`渲染真实`DOM`的过程，这个过程是`vm._update()`方法的执行，而其核心是`vm.__patch__`。

- `vm.__patch__`内部会通过 `createElm`去创建真实的`DOM`元素，期间遇到子`Vnode`递归调用`createElm`方法。

- 递归调用过程中，通过`createComponent`方法创建组件，如果是组件重新走实例化组件和挂载，该方法和渲染`Vnode`阶段的方法`createComponent`不同，他会调用子组件的`init`初始化钩子函数，并完成组件的`DOM`插入。

- `init`初始化组件钩子函数的核心是实例化子组件并进行挂载，实例化子组件的过程又回到合并配置，初始化生命周期，初始化事件中心，初始化渲染的过程。初始化后手动挂载`$mount`。



完成所有子组件的实例化和节点挂载后，最后才回到根节点的挂载。

`__patch__`核心代码是通过`createElm`创建真实节点，当创建过程中遇到子`vnode`时，会调用`createChildren`,`createChildren`的目的是对子`vnode`递归调用`createElm`创建子组件节点。

```js
// 创建真实dom
function createElm (vnode,insertedVnodeQueue,parentElm,refElm,nested,ownerArray,index) {
  ···
  // 递归创建子组件真实节点,直到完成所有子组件的渲染才进行根节点的真实节点插入
  if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
    return
  }
  ···
  var children = vnode.children;
  // 
  createChildren(vnode, children, insertedVnodeQueue);
  ···
  insert(parentElm, vnode.elm, refElm);
}
function createChildren(vnode, children, insertedVnodeQueue) {
  for (var i = 0; i < children.length; ++i) {
    // 遍历子节点，递归调用创建真实dom节点的方法 - createElm
    createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
  }
}
```

`createComponent`方法会对子组件`Vnode`进行处理中，还记得在`Vnode`生成阶段为子`Vnode`安装了一系列的钩子函数吗，在这个步骤我们可以通过是否拥有这些定义好的钩子来判断是否是已经注册过的子组件，如果条件满足，则执行组件的`init`钩子。

`init`钩子做的事情只有两个，**实例化组件构造器，执行子组件的挂载流程。**

```js
function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
  var i = vnode.data;
  // 是否有钩子函数可以作为判断是否为组件的唯一条件
  if (isDef(i = i.hook) && isDef(i = i.init)) {
    // 执行init钩子函数
    i(vnode, false /* hydrating */);
  }
  ···
}
var componentVNodeHooks = {
  init () {
    // 忽略keepAlive过程
    // 实例化
    var child = vnode.componentInstance = createComponentInstanceForVnode(vnode,activeInstance);
    // 挂载
    child.$mount(hydrating ? vnode.elm : undefined, hydrating);
  }
}
function createComponentInstanceForVnode(vnode, parent) {
  ···
  // 实例化Vue子组件实例
  return new vnode.componentOptions.Ctor(options)
}
```

显然`Vnode`生成真实`DOM`的过程也是一个不断递归创建子节点的过程，`patch`过程如果遇到子`Vnode`,会优先实例化子组件，并且执行子组件的挂载流程，而挂载流程又会回到`_render,_update`的过程。在所有的子`Vnode`递归挂载后，最终才会真正挂载根节点。




## 建立组件关联

日常开发中，我们可以通过`vm.$parent`拿到父实例，也可以在父实例中通过`vm.$children`拿到实例中的子组件。显然，`Vue`在组件和组件之间建立了一层关联。接下来的内容，我们将探索如何建立组件之间的联系。

不管是父实例还是子实例，在初始化实例阶段执行 `_init` 有一个 `initLifecycle`的 过程。这个过程会**把当前实例添加到父实例的`$children`属性中，并设置自身的`$parent`属性指向父实例。**源码解析如下:

```js
function initLifecycle (vm) {
    var options = vm.$options;
    // 子组件注册时，会把父组件的实例挂载到自身选项的parent上
    var parent = options.parent;
    // 如果是子组件，并且该组件不是抽象组件时，将该组件的实例添加到父组件的$parent属性上，如果父组件是抽象组件，则一直往上层寻找，直到该父级组件不是抽象组件，并将，将该组件的实例添加到父组件的$parent属性
    if (parent && !options.abstract) {
        while (parent.$options.abstract && parent.$parent) {
        parent = parent.$parent;
        }
        parent.$children.push(vm);
    }
    // 将自身的$parent属性指向父实例。
    vm.$parent = parent;
    vm.$root = parent ? parent.$root : vm;
    vm.$children = [];
    vm.$refs = {};
    vm._watcher = null;
    vm._inactive = null;
    vm._directInactive = false;
    // 该实例是否挂载
    vm._isMounted = false;
    // 该实例是否被销毁
    vm._isDestroyed = false;
    // 该实例是否正在被销毁
    vm._isBeingDestroyed = false;
}
```

`parent.$options.abstract` 是抽象组件的判断，在`vue`中有很多内置的抽象组件，例如`<keep-alive></keep-alive>,<transition><transition>`等，这些抽象组件并不会出现在子父级的路径上，并且它们也不会参与`DOM`的渲染。



## 函数式组件

组件除了常用的使用场景外，还提供了另外两种使用方式，分别是函数式组件和异步组件，函数式组件逻辑相对简单些，先来看看函数式组件。

函数式组件顾名思义可以理解为它是一个函数，有自己的作用域，可以实现复用，所以函数组件是无状态、无实例的。从原理上说，一般子组件都会经过实例化的过程，而单纯的函数组件并没有这个过程，它可以简单理解为一个中间层，只处理逻辑数据，不创建实例，也是由于这个行为，它的渲染开销会低很多。

**函数组件实际的应用场景**，当我们需要在多个组件中选择一个来代为渲染，或者在将`children,props,data`等数据传递给子组件前进行数据处理时，我们都可以用函数式组件来完成，它本质上也是对组件的一个外部包装。

### 使用场景

定义两个组件对象，`test1，test2`

```js
var test1 = {
props: ['msg'],
render: function (createElement, context) {
  return createElement('h1', this.msg)
}
}
var test2 = {
props: ['msg'],
render: function (createElement, context) {
  return createElement('h2', this.msg)
}
}
```

- 定义一个函数式组件，它会根据计算结果选择其中一个组件进行选项

```js
Vue.component('test3', {
// 函数式组件的标志 functional设置为true
functional: true,
props: ['msg'],
render: function (createElement, context) {
  var get = function() {
    return test1
  }
  return createElement(get(), context)
}
})
```

- 函数式组件的使用

```js
<test3 :msg="msg" id="test">
</test3>
new Vue({
el: '#app',
data: {
  msg: 'test'
}
})
```

- 最终渲染的结果为：

```js
<h2>test</h2>
```



### 函数组件源码分析

函数式组件会在组件的对象定义中，将`functional`属性设置为`true`，这个属性是区别普通组件和函数式组件的关键。同样的在遇到子组件占位符时，会进入`createComponent`进行子组件`Vnode`的创建。**由于`functional`属性的存在，代码会进入函数式组件的分支中，并返回`createFunctionalComponent`调用的结果**。注意，执行完`createFunctionalComponent`后，后续创建子`Vnode`的逻辑不会执行，这也是之后在创建真实节点过程中不会有子`Vnode`去实例化子组件的原因

```js
function createComponent(){
  ···
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children)
  }
}
```

`createFunctionalComponent`方法会对传入的数据进行检测和合并，实例化`FunctionalRenderContext`，最终调用函数式组件自定义的`render`方法执行渲染过程。

```js
function createFunctionalComponent(
  Ctor, // 函数式组件构造器
  propsData, // 传入组件的props
  data, // 占位符组件传入的attr属性
  context, // vue实例
  children// 子节点
){
  // 数据检测合并
  var options = Ctor.options;
  var props = {};
  var propOptions = options.props;
  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    // 合并attrs
    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }
    // 合并props
    if (isDef(data.props)) { mergeProps(props, data.props); }
  }
  var renderContext = new FunctionalRenderContext(data,props,children,contextVm,Ctor);
  // 调用函数式组件中自定的render函数
  var vnode = options.render.call(null, renderContext._c, renderContext)
}
```

而`FunctionalRenderContext`这个类最终的目的是定义一个和真实组件渲染不同的`render`方法。

```js
function FunctionalRenderContext() {
  // 省略其他逻辑
  this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };
}
```

执行`render`函数的过程，又会递归调用`createElement`的方法，这时的组件已经是真实的组件，开始执行正常的组件挂载流程。

```js
options.render.call(null, renderContext._c, renderContext)
```

我们知道函数式组件的 `render` 函数可以接收第二个参数，它的值就是上面的 `renderContext`



问题：为什么函数式组件需要定义一个不同的`createElement`方法？

- 函数式组件`createElement`和以往唯一的不同是，最后一个参数的不同，`createElement`会根据最后一个参数决定是否对子`Vnode`进行拍平，一般情况下，`children`编译生成结果都是`Vnode`类型，只有函数式组件比较特殊，它可以返回一个数组，这时候拍平就是有必要的。我们看下面的例子：

```js
Vue.component('test', {  
  functional: true,  
  render: function (createElement, context) {  
    return context.slots().default  
  }  
}) 
<test> 
     <p>slot1</p> 
     <p>slot</p> 
</test>
```

此时函数式组件`test`的`render`函数返回的是两个`slot`的`Vnode`，它是以数组的形式存在的,这就是需要拍平的场景。

简单总结一下函数式组件，从源码中可以看出，函数式组件并不会像普通组件那样有实例化组件的过程，因此包括组件的生命周期，组件的数据管理这些过程都没有，它只会原封不动的接收传递给组件的数据做处理，并渲染需要的内容。因此作为纯粹的函数可以也大大降低渲染的开销。



## 异步组件

### 使用背景

`Vue`作为单页面应用遇到最棘手的问题是首屏加载时间的问题，单页面应用会把页面脚本打包成一个文件，这个文件包含着所有业务和非业务的代码，而脚本文件过大也是造成首页渲染速度缓慢的原因。

作为首屏性能优化的手段，最常用的处理方法是对文件的拆分和代码的分离。按需加载的概念也是在这个前提下引入的。我们往往会把一些非首屏的组件设计成异步组件，部分不影响初次视觉体验的组件也可以设计为异步组件。这个思想就是**按需加载**。通俗点理解，按需加载的思想让应用在需要使用某个组件时才去请求加载组件代码。我们借助`webpack`打包后的结果会更加直观。

![6.1 异步组件 - 图1](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/6.1.png)

![6.1 异步组件 - 图2](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/6.2.png)

异步组件的使用场景通常定义在路由文件中，`webpack`遇到异步组件，会将其从主脚本中分离，减少脚本体积，实现**按需加载**，加快首屏加载时间



### 工厂函数

`Vue`中允许用户通过工厂函数的形式定义组件，这个工厂函数会异步解析组件定义，组件需要渲染的时候才会触发该工厂函数，加载结果会进行缓存，以供下一次调用组件时使用。具体使用：

```js
// 全局注册：
Vue.component('asyncComponent', function(resolve, reject) {
  require(['./test.vue'], resolve)
})
// 局部注册：
var vm = new Vue({
  el: '#app',
  template: '<div id="app"><asyncComponent></asyncComponent></div>',
  components: {
    asyncComponent: (resolve, reject) => require(['./test.vue'], resolve),
    // 另外写法
    asyncComponent: () => import('./test.vue'),
  }
})
```



### 异步组件流程分析

在上面组件挂载流程中，实例的挂载流程会创建`Vnode`过程，如果遇到子的占位符节点会调用`creatComponent`,而异步组件的处理逻辑也是在这个阶段处理。

```js
// 创建子组件过程
  function createComponent (
    Ctor, // 子类构造器
    data,
    context, // vm实例
    children, // 子节点
    tag // 子组件占位符
  ) {
    ···
    // 针对局部注册组件创建子类构造器
    if (isObject(Ctor)) {
      Ctor = baseCtor.extend(Ctor);
    }
    // 异步组件分支
    var asyncFactory;
    if (isUndef(Ctor.cid)) {
      // 异步工厂函数
      asyncFactory = Ctor;
      // 创建异步组件函数
      Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
      if (Ctor === undefined) {
        return createAsyncPlaceholder(
          asyncFactory,
          data,
          context,
          children,
          tag
        )
      }
    }
    ···
    // 创建子组件vnode
    var vnode = new VNode(
      ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
      data, undefined, undefined, undefined, context,
      { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },
      asyncFactory
    );
    return vnode
  }
```

**工厂函数的用法使得`Vue.component(name, options)`的第二个参数不是一个对象，因此不论是全局注册还是局部注册，都不会执行`Vue.extend`生成一个子组件的构造器**，所以`Ctor.cid`不会存在，代码会进入异步组件的分支。

异步组件分支的核心是`resolveAsyncComponent`,它的处理逻辑分支众多，我们先关心工厂函数处理部分。

```js
function resolveAsyncComponent (
    factory,
    baseCtor
  ) {
    if (!isDef(factory.owners)) {
      // 异步请求成功处理
      var resolve = function() {}
      // 异步请求失败处理
      var reject = function() {}
      // 创建子组件时会先执行工厂函数，并将resolve和reject传入
      var res = factory(resolve, reject);
      // resolved 同步返回
      return factory.loading
        ? factory.loadingComp
        : factory.resolved
    }
  }
```

针对异步组件工厂函数的写法，大致可以总结出以下三个步骤：

1. 定义异步请求成功的函数处理，定义异步请求失败的函数处理；
2. 执行组件定义的工厂函数；
3. 同步返回请求成功的函数处理。

`resolve, reject`的实现，都是`once`方法执行的结果，所以我们先关注一下高级函数`once`的原理。**为了防止当多个地方调用异步组件时，`resolve,reject`不会重复执行，`once`函数保证了函数在代码只执行一次。也就是说，`once`缓存了已经请求过的异步组件**

```js
// once函数保证了这个调用函数只在系统中调用一次
function once (fn) {
  // 利用闭包特性将called作为标志位
  var called = false;
  return function () {
    // 调用过则不再调用
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  }
}
```

成功`resolve`和失败`reject`的详细处理逻辑如下：

```javascript
// 成功处理
var resolve = once(function (res) {
  // 转成组件构造器，并将其缓存到resolved属性中。
  factory.resolved = ensureCtor(res, baseCtor);
  if (!sync) {
    //强制更新渲染视图
    forceRender(true);
  } else {
    owners.length = 0;
  }
});
// 失败处理
var reject = once(function (reason) {
  warn(
    "Failed to resolve async component: " + (String(factory)) +
    (reason ? ("\nReason: " + reason) : '')
  );
  if (isDef(factory.errorComp)) {
    factory.error = true;
    forceRender(true);
  }
});
```

异步组件加载完毕，会调用`resolve`定义的方法，方法会通过`ensureCtor`将加载完成的组件转换为组件构造器，并存储在`resolved`属性中，其中 `ensureCtor`的定义为：

```js
function ensureCtor (comp, base) {
    if (comp.__esModule ||(hasSymbol && comp[Symbol.toStringTag] === 'Module')) {
      comp = comp.default;
    }
    // comp结果为对象时，调用extend方法创建一个子类构造器
    return isObject(comp)
      ? base.extend(comp)
      : comp
  }
```

组件构造器创建完毕，会进行一次视图的重新渲染，**由于`Vue`是数据驱动视图渲染的，而组件在加载到完毕的过程中，并没有数据发生变化，因此需要手动强制更新视图。**`forceRender` 函数的内部会拿到每个调用异步组件的实例，执行原型上的`$forceUpdate`方法，更新组件

异步组件加载失败后，会调用`reject`定义的方法，方法会提示并标记错误，最后同样会强制更新视图。

回到异步组件创建的流程，执行异步过程会同步为加载中的异步组件创建一个注释节点`Vnode`

```js
  function createComponent (){
    ···
    // 创建异步组件函数
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
    if (Ctor === undefined) {
      // 创建注释节点
      return createAsyncPlaceholder(asyncFactory,data,context,children,tag)
    }
  }
```

`createAsyncPlaceholder`的定义也很简单,其中`createEmptyVNode`创建一个注释节点`vnode`，而`asyncFactory,asyncMeta`都是用来标注该节点为异步组件的临时节点和相关属性。

```js
// 创建注释Vnode
function createAsyncPlaceholder (factory,data,context,children,tag) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = { data: data, context: context, children: children, tag: tag };
  return node
}
```

执行`forceRender`触发组件的重新渲染过程时，又会再次调用`resolveAsyncComponent`,这时返回值`Ctor`不再为 `undefined`了，因此会正常走组件的`render,patch`过程。这时，旧的注释节点也会被取代。



### Promise异步组件

异步组件的第二种写法是在工厂函数中返回一个`promise`对象，我们知道`import`是`es6`引入模块加载的用法，但是`import`是一个静态加载的方法，它会优先模块内的其他语句执行。因此引入了`import()`,`import()`是一个运行时加载模块的方法，可以用来类比`require()`方法，区别在于前者是一个异步方法，后者是同步的，且`import()`会返回一个`promise`对象。

具体用法：

```js
Vue.component('asyncComponent', () => import('./test.vue'))
```

源码依然走着异步组件处理分支，并且大部分的处理过程还是工厂函数的逻辑处理，区别在于执行异步函数后会返回一个`promise`对象，成功加载则执行`resolve`,失败加载则执行`reject`

```js
var res = factory(resolve, reject);
// res是返回的promise
if (isObject(res)) {
  if (isPromise(res)) {
    if (isUndef(factory.resolved)) {
      // 核心处理
      res.then(resolve, reject);
    }
  }
}
```

其中`promise`对象的判断最简单的是判断是否有`then`和`catch`方法：

```js
 // 判断promise对象的方法
  function isPromise (val) {
    return (isDef(val) && typeof val.then === 'function' && typeof val.catch === 'function')
  }
```



### 高级异步组件

为了在操作上更加灵活，比如使用`loading`组件处理组件加载时间过长的等待问题，使用`error`组件处理加载组件失败的错误提示等，`Vue` 高级异步组件可以定义需要加载的组件`component`,加载中显示的组件`loading`,加载失败的组件`error`,以及各种延时超时设置，源码同样进入异步组件分支。

```js
Vue.component('asyncComponent', () => ({
  // 需要加载的组件 (应该是一个 `Promise` 对象)
  component: import('./MyComponent.vue'),
  // 异步组件加载时使用的组件
  loading: LoadingComponent,
  // 加载失败时使用的组件
  error: ErrorComponent,
  // 展示加载时组件的延时时间。默认值是 200 (毫秒)
  delay: 200,
  // 如果提供了超时时间且组件加载也超时了，
  // 则使用加载失败时使用的组件。默认值是：`Infinity`
  timeout: 3000
}))
```

异步组件函数执行后返回一个对象，并且对象的`component`执行会返回一个`promise`对象，因此进入高级异步组件处理分支。

```javascript
if (isObject(res)) {
  if (isPromise(res)) {}
  // 返回对象，且res.component返回一个promise对象，进入分支
  // 高级异步组件处理分支
  else if (isPromise(res.component)) {
    // 和promise异步组件处理方式相同
    res.component.then(resolve, reject);
    ···
  }
}
```

异步组件会等待响应成功失败的结果，与此同时，代码继续同步执行。高级选项设置中如果设置了`error`和`loading`组件，会同时创建两个子类的构造器,

```js
if (isDef(res.error)) {
  // 异步错误时组件的处理，创建错误组件的子类构造器，并赋值给errorComp
  factory.errorComp = ensureCtor(res.error, baseCtor);
}
if (isDef(res.loading)) {
  // 异步加载时组件的处理，创建错误组件的子类构造器，并赋值给errorComp
  factory.loadingComp = ensureCtor(res.loading, baseCtor);
}
```

如果存在`delay`属性,则通过`settimeout`设置`loading`组件显示的延迟时间。`factory.loading`属性用来标注是否是显示`loading`组件。



```js
if (res.delay === 0) {
  factory.loading = true;
} else {
  // 超过时间会成功加载，则执行失败结果
  setTimeout(function () {
    if (isUndef(factory.resolved) && isUndef(factory.error)) {
      factory.loading = true;
      forceRender(false);
    }
  }, res.delay || 200);
}
```

如果在`timeout`时间内，异步组件还未执行`resolve`的成功结果，即`resolve`没有赋值,则进行`reject`失败处理。

接下来依然是渲染注释节点或者渲染`loading`组件，等待异步处理结果，根据处理结果重新渲染视图节点，和正常的组件渲染流程一样，`Vue` 只是提供了一种更加强大和灵魂的方式调用异步组件

### wepack异步组件用法

`webpack`作为`Vue`应用构建工具的标配，我们需要知道`Vue`如何结合`webpack`进行异步组件的代码分离，并且需要关注分离后的文件名，这个名字在`webpack`中称为`chunkName`。`webpack`为异步组件的加载提供了两种写法。

- `require.ensure`:它是`webpack`传统提供给异步组件的写法，在编译时，`webpack`会静态地解析代码中的 `require.ensure()`，同时将模块添加到一个分开的 `chunk` 中，其中函数的第三个参数为分离代码块的名字。修改后的代码写法如下：

```js
Vue.component('asyncComponent', function (resolve, reject) {
   require.ensure([], function () {
     resolve(require('./test.vue'));
   }, 'asyncComponent'); // asyncComponent为chunkname
})
```

- `import(/* webpackChunkName: "asyncComponent" */, component)`: 有了`es6`,`import`的写法是现今官方最推荐的做法，其中通过注释`webpackChunkName`来指定分离后组件模块的命名。修改后的写法如下：

```js
Vue.component('asyncComponent', () => import(/* webpackChunkName: "asyncComponent" */, './test.vue'))
```

## 总结



`Vue` 组件注册有两种方式**全局注册**和**局部注册**，它们两者本质上都是调用 `Vue.extend` 方法得到一个子类构造器，区别在于执行的时机不同，所以子类构造器挂载的上下文也不一样，全局注册挂载在 `Vue` 根实例上，局部注册挂载在子组件实例对象上。接着分析组件的渲染流程，渲染流程分为两步，一是 `render` 将 `with` 函数转化为 `Vnode tree`, 二是 `patch` 将 `Vnode tree` 转化为真实的 `DOM`, 如果 patch 执行 `creatElem` 遇到子组件【安装了组件钩子】，会再次走组件渲染流程，这个过程会经过深度递归，最终生成我们熟悉的 `DOM tree`

然后介绍 `initLifecycle` 是如何建立组件和组件之前的层级关系，最后分析组件的另外两种使用场景：函数组件和异步组件





