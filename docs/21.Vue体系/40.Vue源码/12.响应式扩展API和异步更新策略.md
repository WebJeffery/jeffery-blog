---
title: 响应式扩展API和异步更新策略
date: 2021-04-16 22:45:35
permalink: /pages/seewewwwee31ef7
author: jeffery
categories: 
  - Vue 源码
tags: 
  - Vue 源码
  - Vue
---

# 响应式扩展API和异步更新策略

阅读源码的注释仓库[github](https://github.com/JefferyXZF/vue/tree/dev-doc)

## 数组检测

`Object.defineProperty`的`get,set`方法只能检测到对象属性的变化，对于数组的变化(例如插入删除数组元素等操作)，`Object.defineProperty`却无法达到目的,这也是利用`Object.defineProperty`进行数据监控的缺陷，虽然`es6`中的`proxy`可以完美解决这一问题，但毕竟有兼容性问题，所以我们还需要研究`Vue`在`Object.defineProperty`的基础上如何对数组进行监听检测。

### 数组方法的重写

既然数组已经不能再通过数据的`getter,setter`方法去监听变化了，`Vue`的做法是对数组方法进行重写，在保留原数组功能的前提下，对数组进行额外的操作处理。也就是重新定义了数组方法。

```js
var arrayProto = Array.prototype;
// 新建一个继承于Array的对象
var arrayMethods = Object.create(arrayProto);

// 数组拥有的方法
var methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
];
```

`arrayMethods`是基于原始`Array`类为原型继承的一个对象类，由于原型链的继承，`arrayMethod`拥有数组的所有方法，接下来对这个新的数组类的方法进行改写。

```js
methodsToPatch.forEach(function (method) {
  // 缓冲原始数组的方法
  var original = arrayProto[method];
  // 利用Object.defineProperty对方法的执行进行改写
  def(arrayMethods, method, function mutator () {});
});

function def (obj, key, val, enumerable) {
    Object.defineProperty(obj, key, {
      value: val,
      enumerable: !!enumerable,
      writable: true,
      configurable: true
    });
  }
```

这里对数组方法设置了代理，当执行`arrayMethods`的数组方法时，会代理执行`mutator`函数，这个函数的具体实现，我们放到数组的派发更新中介绍。

**仅仅创建一个新的数组方法合集是不够的，我们在访问数组时，如何不调用原生的数组方法，而是将过程指向这个新的类，这是下一步的重点。**

回到数据初始化过程，也就是执行`initData`阶段，`Observer`类会为每个非数组的属性进行数据拦截，重新定义`getter,setter`方法，接下来看看对于数组拦截的处理。

```js
var Observer = function Observer (value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  // 将__ob__属性设置成不可枚举属性。外部无法通过遍历获取。
  def(value, '__ob__', this);
  // 数组处理
  if (Array.isArray(value)) {
    if (hasProto) {
      protoAugment(value, arrayMethods);
    } else {
      copyAugment(value, arrayMethods, arrayKeys);
    }
    this.observeArray(value);
  } else {
  // 对象处理
    this.walk(value);
  }
}
```

数组处理的分支分为两个，`hasProto`的判断条件，`hasProto`用来判断当前环境下是否支持`__proto__`属性。而数组的处理会根据是否支持这一属性来决定执行`protoAugment, copyAugment`过程，

```js
// __proto__属性的判断
var hasProto = '__proto__' in {};
```

**当支持`__proto__`时，执行`protoAugment`会将当前数组的原型指向新的数组类`arrayMethods`,如果不支持`__proto__`，则通过代理设置，在访问数组方法时代理访问新数组类中的数组方法。**

```js
//直接通过原型指向的方式
function protoAugment (target, src) {
  target.__proto__ = src;
}

// 通过数据代理的方式
function copyAugment (target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}
```

有了这两步的处理，接下来我们在实例内部调用`push, unshift`等数组的方法时，会执行`arrayMethods`类的方法。这也是数组进行依赖收集和派发更新的前提。

### 数组依赖收集

由于数据初始化阶段会利用`Object.definePrototype`进行数据访问的改写，数组的访问同样会被`getter`所拦截。由于是数组，拦截过程会做特殊处理，后面我们再看看`dependArray`的原理。

```js
function defineReactive###1() {
  ···
  var childOb = !shallow && observe(val);

  Object.defineProperty(obj, key, {
        enumerable: true,
        configurable: true,
        get: function reactiveGetter () {
          var value = getter ? getter.call(obj) : val;
          if (Dep.target) {
            dep.depend();
            if (childOb) {
              childOb.dep.depend();
              if (Array.isArray(value)) {
                dependArray(value);
              }
            }
          }
          return value
        },
        set() {}
}
```

`childOb`是标志属性值是否为基础类型的标志，`observe`如果遇到基本类型数据，则直接返回，不做任何处理，如果遇到对象或者数组则会递归实例化`Observer`，会为每个子属性设置响应式数据，最终返回`Observer`实例。而实例化`Observer`又回到之前的老流程： **添加`__ob__`属性，如果遇到数组则进行原型重指向，遇到对象则定义`getter,setter`**

在访问到数组时，由于`childOb`的存在，会执行`childOb.dep.depend();`进行依赖收集，该`Observer`实例的`dep`属性会收集当前的`watcher`作为依赖保存，`dependArray`保证了如果数组元素是数组或者对象，需要递归去为内部的元素收集相关的依赖。

```js
function dependArray (value) {
    for (var e = (void 0), i = 0, l = value.length; i < l; i++) {
      e = value[i];
      e && e.__ob__ && e.__ob__.dep.depend();
      if (Array.isArray(e)) {
        dependArray(e);
      }
    }
  }
```

我们可以通过截图看最终依赖收集的结果。

收集前

![img](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/7.1.png)

收集后

![img](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/7.2.png)

### 数组派发更新

当调用数组的方法去添加或者删除数据时，数据的`setter`方法是无法拦截的，所以我们唯一可以拦截的过程就是调用数组方法的时候，前面介绍过，数组方法的调用会代理到新类`arrayMethods`的方法中,而`arrayMethods`的数组方法是进行重写过的。具体我们看他的定义。

```js
 methodsToPatch.forEach(function (method) {
    var original = arrayProto[method];
    def(arrayMethods, method, function mutator () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];
      // 执行原数组方法
      var result = original.apply(this, args);
      var ob = this.__ob__;
      var inserted;
      switch (method) {
        case 'push':
        case 'unshift':
          inserted = args;
          break
        case 'splice':
          inserted = args.slice(2);
          break
      }
      if (inserted) { ob.observeArray(inserted); }
      // notify change
      ob.dep.notify();
      return result
    });
  });
```

`mutator`是重写的数组方法，首先会调用原始的数组方法进行运算，这保证了与原始数组类型的方法一致性，`args`保存了数组方法调用传递的参数。之后取出数组的`__ob__`也就是之前保存的`Observer`实例，调用`ob.dep.notify();`进行依赖的派发更新，前面知道了。`Observer`实例的`dep`是`Dep`的实例，他收集了需要监听的`watcher`依赖，而`notify`会对依赖进行重新计算并更新。具体看`Dep.prototype.notify = function notify () {}`函数的分析，这里也不重复赘述。

回到代码中，`inserted`变量用来标志数组是否是增加了元素，如果增加的元素不是原始类型，而是数组对象类型，则需要触发`observeArray`方法，对每个元素进行依赖收集。

```js
Observer.prototype.observeArray = function observeArray (items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};
Copy
```

**总的来说。数组的改变不会触发`setter`进行依赖更新，所以`Vue`创建了一个新的数组类，重写了数组的方法，将数组方法指向了新的数组类。同时在访问到数组时依旧触发`getter`进行依赖收集，在更改数组时，触发数组新方法运算，并进行依赖的派发。**

现在我们回过头看看Vue的官方文档对于数组检测时的注意事项：

> `Vue` 不能检测以下数组的变动:
>
> - 当你利用索引直接设置一个数组项时，例如：`vm.items[indexOfItem] = newValue`
> - 当你修改数组的长度时，例如：`vm.items.length = newLength`

显然有了上述的分析我们很容易理解数组检测带来的弊端，即使`Vue`重写了数组的方法，以便在设置数组时进行拦截处理，但是不管是通过索引还是直接修改长度，都是无法触发依赖更新的。



## 对象检测

在实际开发中经常遇到一种场景，对象`test: { a: 1 }`要添加一个属性`b`,这时如果我们使用`test.b = 2`的方式去添加，这个过程`Vue`是无法检测到的，理由也很简单。我们在对对象进行依赖收集的时候，会为对象的每个属性都进行收集依赖，而直接通过`test.b`添加的新属性并没有依赖收集的过程，因此当之后数据`b`发生改变时也不会进行依赖的更新。

了解决这一问题，`Vue`提供了`Vue.set(object, propertyName, value)`的静态方法和`vm.$set(object, propertyName, value)`的实例方法，以及 `del` 删除方法，我们看具体怎么完成新增属性和删除属性的更新过程。

### set

`set` 方法给对象或数组添加一个 `响应式值`, 它是弥补 `Object.defineProperty` 无法监控到对象新增的值，以下是它的实现原理：

- 目标对象必须为非空的对象，可以是数组，否则抛出异常。
- 如果目标对象是数组时，调用数组的 `splice` 方法，遇到数组新增元素的场景，会调用 `ob.observeArray(inserted)` 对数组新增的元素收集依赖。
- 新增的属性值在原对象中已经存在，则手动访问新的属性值，这一过程会触发依赖收集。
- 如果目标对象不是响应式对象，直接返回。如果是响应式对象，调用`defineReactive` 方法手动定义新属性的 `getter,setter` 方法，并通过 `notify` 触发依赖更新。


```js
function set (target: Array<any> | Object, key: any, val: any): any {
  if (process.env.NODE_ENV !== 'production' &&
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(`Cannot set reactive property on undefined, null, or primitive value: ${(target: any)}`)
  }
  // 数组场景，调用重写的splice方法，对新添加属性收集依赖。
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key)
    target.splice(key, 1, val)
    return val
  }
  // 新增对象的属性存在时，直接返回新属性，触发依赖收集
  if (key in target && !(key in Object.prototype)) {
    target[key] = val
    return val
  }
  const ob = (target: any).__ob__
  // 数据是组件实例，直接返回
  if (target._isVue || (ob && ob.vmCount)) {
    process.env.NODE_ENV !== 'production' && warn(
      'Avoid adding reactive properties to a Vue instance or its root $data ' +
      'at runtime - declare it upfront in the data option.'
    )
    return val
  }
   // 目标源对象本身不是一个响应式对象，则不需要处理
  if (!ob) {
    target[key] = val
    return val
  }
  // 手动调用defineReactive，为新属性设置getter,setter
  defineReactive(ob.value, key, val)
  // 修改响应式数据派发更新
  ob.dep.notify()
  return val
}
```

### del

`del` 方法使用场景比较少，它是删除对象的属性，然后派发更新。以下是它的实现原理。

- 如果目标对象是数组时，调用数组的 `splice` 方法删除。

- 目标对象不存在属性，直接返回，否则使用 `delete` 删除属性

- 如果是响应式对象，派发更新

```js
function del (target: Array<any> | Object, key: any) {
  if (process.env.NODE_ENV !== 'production' &&
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(`Cannot delete reactive property on undefined, null, or primitive value: ${(target: any)}`)
  }
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1)
    return
  }
  const ob = (target: any).__ob__
  if (target._isVue || (ob && ob.vmCount)) {
    process.env.NODE_ENV !== 'production' && warn(
      'Avoid deleting properties on a Vue instance or its root $data ' +
      '- just set it to null.'
    )
    return
  }
  if (!hasOwn(target, key)) {
    return
  }
  delete target[key]
  if (!ob) {
    return
  }
  // 修改响应式数据派发更新
  ob.dep.notify()
}
```

## nextTick

当数据修改时会触发`setter`方法进行依赖的派发更新，而更新时会将每个`watcher`推到队列中，等待下一个`tick`到来时再执行`DOM`的渲染更新操作。这个就是异步更新的过程。异步更新需要牵扯到浏览器的事件循环机制和最优的渲染时机问题

### 事件循环机制

1. 完整的事件循环机制需要了解两种异步队列：`macro-task`宏任务和`micro-task`微任务
2. `macro-task`常见的有 `setTimeout, setInterval, setImmediate, script脚本, I/O操作，UI渲染`
3. `micro-task`常见的有 `promise, process.nextTick, MutationObserver`等
4. 完整事件循环流程为： 
   1. `micro-task`空，`macro-task`队列只有`script`脚本，推出`macro-task`的`script`任务执行，脚本执行期间产生的`macro-task，micro-task`推到对应的队列中 
   2. 执行全部`micro-task`里的微任务事件 
   3. 执行`DOM`操作，渲染更新页面 
   4. 执行`web worker`等相关任务 
   5. 循环，取出`macro-task`中一个宏任务事件执行，重复4的操作。

从上面的流程中我们可以发现，最好的渲染过程发生在微任务队列的执行过程中，此时他离页面渲染过程最近，因此我们可以借助微任务队列来实现异步更新，它可以让复杂批量的运算操作运行在JS层面，而视图的渲染只关心最终的结果，这大大降低了性能的损耗。

举一个这一做法好处的例子： 由于`Vue`是数据驱动视图更新渲染，如果我们在一个操作中重复对一个响应式数据进行计算，例如 在一个循环中执行`this.num ++`一千次，由于响应式系统的存在，数据变化触发`setter`，`setter`触发依赖派发更新，更新调用`run`进行视图的重新渲染。这一次循环，视图渲染要执行一千次，很明显这是很浪费性能的，我们只需要关注最后第一千次在界面上更新的结果而已。所以利用异步更新显得格外重要。

### 基本实现

`Vue`用一个`queue`收集依赖的执行，在下次微任务执行的时候批量执行`queue`队列中`Watcher`的`run`操作,与此同时，相同`id`的`watcher`不会重复添加到`queue`中,因此也不会重复执行多次的视图渲染。我们看`nextTick`的实现。

```js
// 原型上定义的方法
Vue.prototype.$nextTick = function (fn) {
  return nextTick(fn, this)
};
// 构造函数上定义的方法
Vue.nextTick = nextTick;

// 实际的定义
var callbacks = [];
function nextTick (cb, ctx) {
    var _resolve;
    // callbacks是维护微任务的数组。
    callbacks.push(function () {
      if (cb) {
        try {
          cb.call(ctx);
        } catch (e) {
          handleError(e, ctx, 'nextTick');
        }
      } else if (_resolve) {
        _resolve(ctx);
      }
    });
    if (!pending) {
      pending = true;
      // 将维护的队列推到微任务队列中维护
      timerFunc();
    }
    // nextTick没有传递参数，且浏览器支持Promise,则返回一个promise对象
    if (!cb && typeof Promise !== 'undefined') {
      return new Promise(function (resolve) {
        _resolve = resolve;
      })
    }
  }
```

`nextTick`定义为一个函数，使用方式为`Vue.nextTick( [callback, context] )`,当`callback`经过`nextTick`封装后，`callback`会在下一个`tick`中执行调用。从实现上，`callbacks`是一个维护了需要在下一个`tick`中执行的任务的队列，它的每个元素都是需要执行的函数。`pending`是判断是否在等待执行微任务队列的标志。而`timerFunc`是真正将任务队列推到微任务队列中的函数。我们看`timerFunc`的实现。

1.如果浏览器执行`Promise`,那么默认以`Promsie`将执行过程推到微任务队列中。

```js
var timerFunc;

if (typeof Promise !== 'undefined' && isNative(Promise)) {
  var p = Promise.resolve();
  timerFunc = function () {
    p.then(flushCallbacks);
    // 手机端的兼容代码
    if (isIOS) { setTimeout(noop); }
  };
  // 使用微任务队列的标志
  isUsingMicroTask = true;
}
```

`flushCallbacks`是异步更新的函数，他会取出callbacks数组的每一个任务，执行任务，具体定义如下：

```js
function flushCallbacks () {
  pending = false;
  var copies = callbacks.slice(0);
  // 取出callbacks数组的每一个任务，执行任务
  callbacks.length = 0;
  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
}
```

2.不支持`promise`,支持`MutataionObserver`

```js
else if (!isIE && typeof MutationObserver !== 'undefined' && (
    isNative(MutationObserver) ||
    // PhantomJS and iOS 7.x
    MutationObserver.toString() === '[object MutationObserverConstructor]'
  )) {
    var counter = 1;
    var observer = new MutationObserver(flushCallbacks);
    var textNode = document.createTextNode(String(counter));
    observer.observe(textNode, {
      characterData: true
    });
    timerFunc = function () {
      counter = (counter + 1) % 2;
      textNode.data = String(counter);
    };
    isUsingMicroTask = true;
  }
```

3.如果不支持微任务方法，则会使用宏任务方法，`setImmediate`会先被使用

```js
 else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
    // Fallback to setImmediate.
    // Techinically it leverages the (macro) task queue,
    // but it is still a better choice than setTimeout.
    timerFunc = function () {
      setImmediate(flushCallbacks);
    };
  }
```

4.所有方法都不适合，会使用宏任务方法中的`setTimeout`

```js
else {
  timerFunc = function () {
    setTimeout(flushCallbacks, 0);
  };
}
```

**当`nextTick`不传递任何参数时，可以作为一个`promise`用**，例如：

```js
nextTick().then(() => {})
```

### 使用场景

说了这么多原理性的东西，回过头来看看`nextTick`的使用场景，由于异步更新的原理，我们在某一时间改变的数据并不会触发视图的更新，而是需要等下一个`tick`到来时才会更新视图，下面是一个典型场景：

```js
<input v-if="show" type="text" ref="myInput">

// js
data() {
  show: false
},
mounted() {
  this.show = true;
  this.$refs.myInput.focus();// 报错
}
```

数据改变时，视图并不会同时改变，因此需要使用`nextTick`

```js
mounted() {
  this.show = true;
  this.$nextTick(function() {
    this.$refs.myInput.focus();// 正常
  })
}
```