---
title: Virtual DOM
date: 2021-04-18 20:45:35
permalink: /pages/sssesess31ef7
author: jeffery
categories: 
  - Vue 源码
tags: 
  - Vue 源码
---

# Virtual DOM

## 前言

当浏览器接收到一个`Html`文件时，`JS`引擎和浏览器的渲染引擎便开始工作了。从渲染引擎的角度，它首先会将`html`文件解析成一个`DOM`树，与此同时，浏览器将识别并加载`CSS`样式，并和`DOM`树一起合并为一个渲染树。有了渲染树后，渲染引擎将计算所有元素的位置信息，最后通过绘制，在屏幕上打印最终的内容。`JS`引擎和渲染引擎虽然是两个独立的线程，但是JS引擎却可以触发渲染引擎工作，当我们通过脚本去修改元素位置或外观时，`JS`引擎会利用`DOM`相关的`API`方法去操作`DOM`对象,此时渲染引擎变开始工作，渲染引擎会触发回流或者重绘。下面是回流重绘的两个概念：

- 回流： 当我们对`DOM`的修改引发了元素尺寸的变化时，浏览器需要重新计算元素的大小和位置，最后将重新计算的结果绘制出来，这个过程称为回流。
- 重绘： 当我们对`DOM`的修改只单纯改变元素的颜色时，浏览器此时并不需要重新计算元素的大小和位置，而只要重新绘制新样式。这个过程称为重绘。

**很显然回流比重绘更加耗费性能**。

通过了解浏览器基本的渲染机制，我们很容易联想到当不断的通过`JS`修改`DOM`时，不经意间会触发到渲染引擎的回流或者重绘，这个性能开销是非常巨大的。因此为了降低开销，我们需要做的是尽可能减少`DOM`操作。接下来我们介绍虚拟DOM解决以上的问题。

## 虚拟DOM简介

1. 什么是虚拟DOM？

   所谓虚拟DOM，就是用一个`JS`对象来描述一个`DOM`节点，像如下示例：

   ```javascript
   <div class="a" id="b">我是内容</div>
   
   {
     tag:'div',        // 元素标签
     attrs:{           // 属性
       class:'a',
       id:'b'
     },
     text:'我是内容',  // 文本内容
     children:[]       // 子元素
   }
   ```

   我们把组成一个`DOM`节点的必要东西通过一个`JS`对象表示出来，那么这个`JS`对象就可以用来描述这个`DOM`节点，我们把这个`JS`对象就称为是这个真实`DOM`节点的虚拟`DOM`节点。

2. 为什么要有虚拟DOM？

   我们知道，`Vue`是数据驱动视图的，数据发生变化视图就要随之更新，在更新视图的时候难免要操作`DOM`,而操作真实`DOM`又是非常耗费性能的，这是因为浏览器的标准就把 `DOM` 设计的非常复杂，所以一个真正的 `DOM` 元素是非常庞大的，如下所示：

   ```javascript
   let div = document.createElement('div')
   let str = ''
   for (const key in div) {
     str += key + ''
   }
   console.log(str)
   ```

   

![img](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/1.a052465d.png)

上图中我们打印一个简单的空`div`标签，就打印出这么多东西，更不用说复杂的、深嵌套的`DOM`节点了。由此可见，直接操作真实`DOM`是非常消耗性能的。

那么有没有什么解决方案呢？当然是有的。我们可以用`JS`的计算性能来换取操作`DOM`所消耗的性能。

既然我们逃不掉操作`DOM`这道坎,但是我们可以尽可能少的操作`DOM`。那如何在更新视图的时候尽可能少的操作`DOM`呢？最直观的思路就是我们不要盲目的去更新视图，而是通过对比数据变化前后的状态，计算出视图中哪些地方需要更新，只更新需要更新的地方，而不需要更新的地方则不需关心，这样我们就可以尽可能少的操作`DOM`了。这也就是上面所说的用`JS`的计算性能来换取操作`DOM`的性能。

我们可以用`JS`模拟出一个`DOM`节点，称之为虚拟`DOM`节点。当数据发生变化时，我们对比变化前后的虚拟`DOM`节点，通过`DOM-Diff`算法计算出需要更新的地方，然后去更新需要更新的视图。

这就是虚拟`DOM`产生的原因以及最大的用途。

## Vue中的虚拟DOM

### VNode类

我们说了，虚拟`DOM`就是用`JS`来描述一个真实的`DOM`节点。而在`Vue`中就存在了一个`VNode`类，通过这个类，我们就可以实例化出不同类型的虚拟`DOM`节点，源码如下：

```javascript
// 源码位置：src/core/vdom/vnode.js

export default class VNode {
  constructor (
    tag?: string,
    data?: VNodeData,
    children?: ?Array<VNode>,
    text?: string,
    elm?: Node,
    context?: Component,
    componentOptions?: VNodeComponentOptions,
    asyncFactory?: Function
  ) {
    this.tag = tag                                /*当前节点的标签名*/
    this.data = data        /*当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息*/
    this.children = children  /*当前节点的子节点，是一个数组*/
    this.text = text     /*当前节点的文本*/
    this.elm = elm       /*当前虚拟节点对应的真实dom节点*/
    this.ns = undefined            /*当前节点的名字空间*/
    this.context = context          /*当前组件节点对应的Vue实例*/
    this.fnContext = undefined       /*函数式组件对应的Vue实例*/
    this.fnOptions = undefined
    this.fnScopeId = undefined
    this.key = data && data.key           /*节点的key属性，被当作节点的标志，用以优化*/
    this.componentOptions = componentOptions   /*组件的option选项*/
    this.componentInstance = undefined       /*当前节点对应的组件的实例*/
    this.parent = undefined           /*当前节点的父节点*/
    this.raw = false         /*简而言之就是是否为原生HTML或只是普通文本，innerHTML的时候为true，textContent的时候为false*/
    this.isStatic = false         /*静态节点标志*/
    this.isRootInsert = true      /*是否作为跟节点插入*/
    this.isComment = false             /*是否为注释节点*/
    this.isCloned = false           /*是否为克隆节点*/
    this.isOnce = false                /*是否有v-once指令*/
    this.asyncFactory = asyncFactory
    this.asyncMeta = undefined
    this.isAsyncPlaceholder = false
  }

  get child (): Component | void {
    return this.componentInstance
  }
}
```



从上面的代码中可以看出：`VNode`类中包含了描述一个真实`DOM`节点所需要的一系列属性，如`tag`表示节点的标签名，`text`表示节点中包含的文本，`children`表示该节点包含的子节点等。通过属性之间不同的搭配，就可以描述出各种类型的真实`DOM`节点。

### VNode的类型

`VNode`类可以描述出各种类型的真实`DOM`节点。那么它都可以描述出哪些类型的节点呢？通过阅读源码，可以发现通过不同属性的搭配，可以描述出以下几种类型的节点。

- 注释节点
- 文本节点
- 元素节点
- 组件节点
- 函数式组件节点
- 克隆节点

接下来，我们就把这几种类型的节点描述方式从源码中一一对应起来。

#### 注释节点

注释节点描述起来相对就非常简单了，它只需两个属性就够了，源码如下：

```javascript
// 创建注释节点
export const createEmptyVNode = (text: string = '') => {
  const node = new VNode()
  node.text = text
  node.isComment = true
  return node
}
```

从上面代码中可以看到，描述一个注释节点只需两个属性，分别是：`text`和`isComment`。其中`text`属性表示具体的注释信息，`isComment`是一个标志，用来标识一个节点是否是注释节点。

#### 文本节点

文本节点描述起来比注释节点更简单，因为它只需要一个属性，那就是`text`属性，用来表示具体的文本信息。源码如下：

```javascript
// 创建文本节点
export function createTextVNode (val: string | number) {
  return new VNode(undefined, undefined, undefined, String(val))
}
```



#### 克隆节点

克隆节点就是把一个已经存在的节点复制一份出来，它主要是为了做模板编译优化时使用，这个后面我们会说到。关于克隆节点的描述，源码如下：

```javascript
// 创建克隆节点
export function cloneVNode (vnode: VNode): VNode {
  const cloned = new VNode(
    vnode.tag,
    vnode.data,
    vnode.children,
    vnode.text,
    vnode.elm,
    vnode.context,
    vnode.componentOptions,
    vnode.asyncFactory
  )
  cloned.ns = vnode.ns
  cloned.isStatic = vnode.isStatic
  cloned.key = vnode.key
  cloned.isComment = vnode.isComment
  cloned.fnContext = vnode.fnContext
  cloned.fnOptions = vnode.fnOptions
  cloned.fnScopeId = vnode.fnScopeId
  cloned.asyncMeta = vnode.asyncMeta
  cloned.isCloned = true
  return cloned
}
```



从上面代码中可以看到，克隆节点就是把已有节点的属性全部复制到新节点中，而现有节点和新克隆得到的节点之间唯一的不同就是克隆得到的节点`isCloned`为`true`。

#### 元素节点

相比之下，元素节点更贴近于我们通常看到的真实`DOM`节点，它有描述节点标签名词的`tag`属性，描述节点属性如`class`、`attributes`等的`data`属性，有描述包含的子节点信息的`children`属性等。由于元素节点所包含的情况相比而言比较复杂，源码中没有像前三种节点一样直接写死（当然也不可能写死），那就举个简单例子说明一下：

```javascript
// 真实DOM节点
<div id='a'><span>难凉热血</span></div>

// VNode节点
{
  tag:'div',
  data:{},
  children:[
    {
      tag:'span',
      text:'难凉热血'
    }
  ]
}
```



我们可以看到，真实`DOM`节点中:`div`标签里面包含了一个`span`标签，而`span`标签里面有一段文本。反应到`VNode`节点上就如上所示:`tag`表示标签名，`data`表示标签的属性`id`等，`children`表示子节点数组。

#### 组件节点

组件节点除了有元素节点具有的属性之外，它还有两个特有的属性：

- componentOptions :组件的option选项，如组件的`props`等
- componentInstance :当前组件节点对应的`Vue`实例

#### 函数式组件节点

函数式组件节点相较于组件节点，它又有两个特有的属性：

- fnContext:函数式组件对应的Vue实例
- fnOptions: 组件的option选项

### VNode的作用

那么`VNode`在`Vue`的整个虚拟`DOM`过程起了什么作用呢？

其实`VNode`的作用是相当大的。我们在视图渲染之前，把写好的`template`模板先编译成`VNode`并缓存下来，等到数据发生变化页面需要重新渲染的时候，我们把数据发生变化后生成的`VNode`与前一次缓存下来的`VNode`进行对比，找出差异，然后有差异的`VNode`对应的真实`DOM`节点就是需要重新渲染的节点，最后根据有差异的`VNode`创建出真实的`DOM`节点再插入到视图中，最终完成一次视图更新。



## Virtual DOM的创建

先简单回顾一下挂载的流程，挂载的过程是调用`Vue`实例上`$mount`方法，而`$mount`的核心是`mountComponent`函数。如果我们传递的是`template`模板，模板会先经过编译器的解析，并最终根据不同平台生成对应代码，此时对应的就是将`with`语句封装好的`render`函数;如果传递的是`render`函数，则跳过模板编译过程，直接进入下一个阶段。下一阶段是拿到`render`函数，调用`vm._render()`方法将`render`函数转化为`Virtual DOM`，并最终通过`vm._update()`方法将`Virtual DOM`渲染为真实的`DOM`节点。

```js
Vue.prototype.$mount = function(el, hydrating) {
    ···
    return mountComponent(this, el)
}
function mountComponent() {
    ···
    updateComponent = function () {
        vm._update(vm._render(), hydrating);
    };
}
```

我们先看看`vm._render()`方法是如何**将render函数转化为Virtual DOM**的。

`_render`函数是一个原型方法，在`renderMixin`时候添加

```js
// 引入Vue时，执行renderMixin方法，该方法定义了Vue原型上的几个方法，其中一个便是 _render函数
renderMixin();//
function renderMixin() {
    Vue.prototype._render = function() {
        var ref = vm.$options;
        var render = ref.render;
        ···
        try {
            vnode = render.call(vm._renderProxy, vm.$createElement);
        } catch (e) {
            ···
        }
        ···
        return vnode
    }
}
```

抛开其他代码，_render函数的核心是`render.call(vm._renderProxy, vm.$createElement)`部分，`vm._renderProxy`在数据代理分析过，本质上是为了做数据过滤检测，它也绑定了`render`函数执行时的`this`指向。`vm.$createElement`方法会作为`render`函数的参数传入。**回忆一下，在手写`render`函数时，我们会利用`render`函数的第一个参数`createElement`进行渲染函数的编写，这里的`createElement`参数就是定义好的`$createElement`方法。**

```js
new Vue({
    el: '#app',
    render: function(createElement) {
        return createElement('div', {}, this.message)
    },
    data() {
        return {
            message: 'dom'
        }
    }
})
```

初始化`_init`时，有一个`initRender`函数，它就是用来定义渲染函数方法的，其中就有`vm.$createElement`方法的定义，除了`$createElement`，`_c`方法的定义也类似。其中 `vm._c` 是`template`内部编译成`render`函数时调用的方法，`vm.$createElement`是手写`render`函数时调用的方法。**两者的唯一区别仅仅是最后一个参数的不同。通过模板生成的`render`方法可以保证子节点都是`Vnode`，而手写的`render`需要一些检验和转换。**

```js
function initRender(vm) {
    vm._c = function(a, b, c, d) { return createElement(vm, a, b, c, d, false); }
    vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };
}
```

`createElement` 方法实际上是对 `_createElement` 方法的封装，在调用`_createElement`前，它会先对传入的参数进行处理，毕竟手写的`render`函数参数规格不统一。举一个简单的例子。

```js
// 没有data
new Vue({
    el: '#app',
    render: function(createElement) {
        return createElement('div', this.message)
    },
    data() {
        return {
            message: 'dom'
        }
    }
})
// 有data
new Vue({
    el: '#app',
    render: function(createElement) {
        return createElement('div', {}, this.message)
    },
    data() {
        return {
            message: 'dom'
        }
    }
})
```

这里如果第二个参数是变量或者数组，则默认是没有传递`data`,因为`data`一般是对象形式存在。

```js
function createElement (
    context, // vm 实例
    tag, // 标签
    data, // 节点相关数据，属性
    children, // 子节点
    normalizationType,
    alwaysNormalize // 区分内部编译生成的render还是手写render
  ) {
    // 对传入参数做处理，如果没有data，则将第三个参数作为第四个参数使用，往上类推。
    if (Array.isArray(data) || isPrimitive(data)) {
      normalizationType = children;
      children = data;
      data = undefined;
    }
    // 根据是alwaysNormalize 区分是内部编译使用的，还是用户手写render使用的
    if (isTrue(alwaysNormalize)) {
      normalizationType = ALWAYS_NORMALIZE;
    }
    return _createElement(context, tag, data, children, normalizationType) // 真正生成Vnode的方法
  }
```

### 数据规范检测

`Vue`既然暴露给用户用`render`函数去手写渲染模板，就需要考虑用户操作带来的不确定性，因此`_createElement`在创建`Vnode`前会先数据的规范性进行检测，将不合法的数据类型错误提前暴露给用户。接下来将列举几个在实际场景中容易犯的错误，也方便我们理解源码中对这类错误的处理。

1. 用响应式对象做 `data` 属性

```js
new Vue({
 el: '#app',
 render: function (createElement, context) {
    return createElement('div', this.observeData, this.show)
 },
 data() {
     return {
         show: 'dom',
         observeData: {
             attr: {
                 id: 'test'
             }
         }
     }
 }
})
```

2. 当特殊属性key的值为非字符串，非数字类型时

```js
new Vue({
 el: '#app',
 render: function(createElement) {
     return createElement('div', { key: this.lists }, this.lists.map(l => {
        return createElement('span', l.name)
     }))
 },
 data() {
     return {
         lists: [{
           name: '111'
         },
         {
           name: '222'
         }
       ],
     }
 }
})
```

这些规范都会在创建 `Vnode` 节点之前发现并报错，源代码如下：

```js
function _createElement (context,tag,data,children,normalizationType) {
 // 1. 数据对象不能是定义在Vue data属性中的响应式数据。
 if (isDef(data) && isDef((data).__ob__)) {
   warn(
     "Avoid using observed data object as vnode data: " + (JSON.stringify(data)) + "\n" +
     'Always create fresh vnode data objects in each render!',
     context
   );
   return createEmptyVNode() // 返回注释节点
 }
 if (isDef(data) && isDef(data.is)) {
   tag = data.is;
 }
 if (!tag) {
   // 防止动态组件 :is 属性设置为false时，需要做特殊处理
   return createEmptyVNode()
 }
 // 2. key值只能为string，number这些原始数据类型
 if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)
 ) {
   {
     warn(
       'Avoid using non-primitive value as key, ' +
       'use string/number value instead.',
       context
     );
   }
 }
 ···
}
```

这些规范性检测保证了后续 `Virtual DOM tree` 的完整生成。

### 子节点children规范化

`Virtual DOM tree`是由每个`Vnode`以树状形式拼成的虚拟`DOM`树，我们在转换真实节点时需要的就是这样一个完整的`Virtual DOM tree`，因此我们需要保证每一个子节点都是`Vnode`类型,这里分两种场景分析。

- 模板编译`render`函数，理论上`template`模板通过编译生成的`render`函数都是`Vnode`类型，但是有一个例外，函数式组件返回的是一个数组,这个时候`Vue`的处理是将整个`children`拍平成一维数组。
- 用户定义`render`函数，这个时候又分为两种情况，一个是当`chidren`为文本节点时，这时候通过前面介绍的`createTextVNode` 创建一个文本节点的 `VNode`; 另一种相对复杂，当`children`中有`v-for`的时候会出现嵌套数组，这时候的处理逻辑是，遍历`children`，对每个节点进行判断，如果依旧是数组，则继续递归调用，直到类型为基础类型时，调用`createTextVnode`方法转化为`Vnode`。这样经过递归，`children`也变成了一个类型为`Vnode`的数组。

```js
function _createElement() {
    ···
    if (normalizationType === ALWAYS_NORMALIZE) {
      // 用户定义render函数
      children = normalizeChildren(children);
    } else if (normalizationType === SIMPLE_NORMALIZE) {
      // 模板编译生成的的render函数
      children = simpleNormalizeChildren(children);
    }
}
// 处理编译生成的render 函数
function simpleNormalizeChildren (children) {
    for (var i = 0; i < children.length; i++) {
        // 子节点为数组时，进行开平操作，压成一维数组。
        if (Array.isArray(children[i])) {
        return Array.prototype.concat.apply([], children)
        }
    }
    return children
}
// 处理用户定义的render函数
function normalizeChildren (children) {
    // 递归调用，直到子节点是基础类型，则调用创建文本节点Vnode
    return isPrimitive(children)
      ? [createTextVNode(children)]
      : Array.isArray(children)
        ? normalizeArrayChildren(children)
        : undefined
  }
// 判断是否基础类型
function isPrimitive (value) {
    return (
      typeof value === 'string' ||
      typeof value === 'number' ||
      typeof value === 'symbol' ||
      typeof value === 'boolean'
    )
  }
```

### 实际场景

在数据检测和组件规范化后，接下来通过`new VNode()`便可以生成一棵完整的`VNode`树，注意在`_render`过程中会遇到子组件，这个时候会优先去做子组件的初始化, 我们用一个实际的例子，结束`render`函数到`Virtual DOM`的分析。

- `template`模板形式

```js
var vm = new Vue({
el: '#app',
template: '<div><span>virtual dom</span></div>'
})
```

- 模板编译生成 `render` 函数

```js
(function() {
with(this){
  return _c('div',[_c('span',[_v("virual dom")])])
}
})
```

- `Virtual DOM tree`的结果(省略版)

```js
{
tag: 'div',
children: [{
  tag: 'span',
  children: [{
    tag: undefined,
    text: 'virtual dom'
  }]
}]
}
```

## 虚拟Vnode映射成真实DOM

回到 `updateComponent`的最后一个过程,虚拟的`DOM`树在生成`virtual dom`后，会调用`Vue`原型上`_update`方法，将虚拟`DOM`映射成为真实的`DOM`。从源码上可以知道，`_update`的调用时机有两个，一个是发生在初次渲染阶段，另一个发生数据更新阶段。

```js
updateComponent = function () {
    // render生成虚拟DOM，update渲染真实DOM
    vm._update(vm._render(), hydrating);
};
```

`vm._update`方法的定义在`lifecycleMixin`中。

```js
lifecycleMixin()
function lifecycleMixin() {
    Vue.prototype._update = function (vnode, hydrating) {
        var vm = this;
        var prevEl = vm.$el;
        var prevVnode = vm._vnode; // prevVnode为旧vnode节点
        // 通过是否有旧节点判断是初次渲染还是数据更新
        if (!prevVnode) {
            // 初次渲染
            vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false)
        } else {
            // 数据更新
            vm.$el = vm.__patch__(prevVnode, vnode);
        }
}
```

`_update`的核心是`__patch__`方法，如果是服务端渲染，由于没有`DOM`，`_patch`方法是一个空函数，在有`DOM`对象的浏览器环境下，`__patch__`是`patch`函数的引用。

```js
// 浏览器端才有DOM，服务端没有dom，所以patch为一个空函数
  Vue.prototype.__patch__ = inBrowser ? patch : noop;
```

而`patch`方法又是`createPatchFunction`方法的返回值，`createPatchFunction`方法传递一个对象作为参数，对象拥有两个属性，`nodeOps`和`modules`，`nodeOps`封装了一系列操作原生`DOM`对象的方法。而`modules`定义了模块的钩子函数。

```js
 var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });
// 将操作dom对象的方法合集做冻结操作
 var nodeOps = /*#__PURE__*/Object.freeze({
    createElement: createElement$1,
    createElementNS: createElementNS,
    createTextNode: createTextNode,
    createComment: createComment,
    insertBefore: insertBefore,
    removeChild: removeChild,
    appendChild: appendChild,
    parentNode: parentNode,
    nextSibling: nextSibling,
    tagName: tagName,
    setTextContent: setTextContent,
    setStyleScope: setStyleScope
  });
// 定义了模块的钩子函数
  var platformModules = [
    attrs,
    klass,
    events,
    domProps,
    style,
    transition
  ];
var modules = platformModules.concat(baseModules);
```

真正的`createPatchFunction`函数内部首先定义了一系列辅助的方法，而核心是通过调用`createElm`方法进行`dom`操作，创建节点，插入子节点，递归创建一个完整的`DOM`树并插入到`Body`中。并且在产生真实阶段阶段，会有`diff`算法来判断前后`Vnode`的差异，以求最小化改变真实阶段。`createPatchFunction`的过程只需要先记住一些结论，函数内部会调用封装好的`DOM api`，根据`Virtual DOM`的结果去生成真实的节点。其中如果遇到组件`Vnode`时，会递归调用子组件的挂载过程。

## 小结

`mountComponent`的两个核心方法，`render`和`update`,在分析前重点介绍了存在于`JS`操作和`DOM`渲染的桥梁：`Virtual DOM`。`JS`对`DOM`节点的批量操作会先直接反应到`Virtual DOM`这个描述对象上,最终的结果才会直接作用到真实节点上。可以说，`Virtual DOM`很大程度提高了渲染的性能。其中，重点介绍了`render`函数转换成`Virtual DOM`的过程，并大致描述了`_update`函数的实现思路。其实这两个过程都牵扯到组件，所以这一节对很多环节都无法深入分析，下一节开始会进入组件的专题。我相信分析完组件后，读者会对整个渲染过程会有更深刻的理解和思考。