---
title: 数据响应式原理
date: 2020-04-16 19:45:35
permalink: /pages/sswlwess31ef7
author: jeffery
categories: 
  - Vue 源码
tags: 
  - Vue 源码
  - Vue
---

# 数据响应式原理


## 思考

- `Observer`，` Watcher`， `Dep` 3个类具体的作用、以及他们之间的关系。
- `props`,  `data`，`watch`，`computed` 响应式原理的实现？
- `Dep` 作为依赖管理的类，在什么时候进行实例化收集依赖？
- `Dep` 收集了什么类型的依赖？即 `watcher` 作为依赖的分类有哪些，分别是什么场景，以及区别在哪里？
- `Observer` 这个类具体对 `getter`, `setter` 方法做了哪些事情？
- 手写的 `watch` 和页面数据渲染监听的 `watch` 如果同时监听到数据的变化，优先级怎么排？
- 有了依赖的收集是不是还有依赖的解除，依赖解除的意义在哪里？

带着这些问题，来分析 `Vue` 响应式实现原理

## 响应式原理流程图分析

先从全局了解整个响应式原理的流程，再从局部分析`props`、 `data`、`watcher`、`computed` 响应式的实现，由浅入深，逐渐深入

<a data-fancybox href="https://gitee.com/FIF/pic-beg/raw/master/images/vue/1620094396058-reactive-vue.png">![组件化源码分析](https://gitee.com/FIF/pic-beg/raw/master/images/vue/1620094396058-reactive-vue.png)</a>

从上面流程图，我们可以了解到 `Observer`、`Watcher`、`Dep` 三者的作用已经关系：

- `Observer` 类：实例化 `Observer` 类通过 `Object.defineProperty` 对数据的`getter`, `setter` 方法进行劫持改写，在 `getter` 阶段进行依赖的收集, 在数据发生更新阶段，触发 `setter` 进行依赖的更新

- `Watcher` 类：实例化 `watcher` 类相当于创建一个依赖，简单的理解是数据在哪里被使用就需要产生了一个依赖。当数据发生改变时，会通知到每个依赖进行更新


- `Dep` 类：`watcher` 理解为每个数据需要监听的依赖，对这些依赖的收集和通知则需要另一个类来管理，这个类便是 `Dep` , `Dep` 需要做的只有两件事，收集依赖和派发更新依赖。



## vue 常用实例 

通过一个常用的事例，分析 `props`,  `data`,  `watch` 和 `computed` 响应式，了解 `vue` 的响应式系统

```html
<template>
  <div id="app">
      <p>计数 {{ num }}</p><button @click="change">add</button>
      <p> {{ computedNum }}</p>
    </div>
</template>

<script>
    var app = new Vue({
    data: {
      num: 0,
    },
    computed: {
      computedNum () {
        return this.num + 2
      }
    },
    watch: {
      num (value) {
        console.log(value)
      }
    },
    methods: {
      change () {
        this.num++
        this.computedNum++
      }
    },
    
  })
</script>
```

## 初始化响应式

从 实例化 `Vue` 开始, 实例化执行 `_init` 方法

```js
function Vue (options) {
  this._init(options)
}
```

`_init` 方法定义，它初始化我们的实例对象数据

```js
Vue.prototype._init = function (options?: Object) {
    // ...
    initState(vm)
    // ...
    // 有 el, 执行 $mount 方法
    if (vm.$options.el) {
      vm.$mount(vm.$options.el)
    }
  }
```

 `initState(vm)` 方法，它是构造响应式系统的核心，定义在 `src/core/instance/state.js` 中。

```js
function initState (vm) {
  vm._watchers = [];
  var opts = vm.$options;
  // 初始化 props
  if (opts.props) { initProps(vm, opts.props); }
  // 初始化 methods
  if (opts.methods) { initMethods(vm, opts.methods); }
  // 初始化 data
  if (opts.data) {
    initData(vm);
  } else {
    // 如果没有定义data，则创建一个空对象，并设置为响应式
    observe(vm._data = {}, true /* asRootData */);
  }
  // 初始化 computed
  if (opts.computed) { initComputed(vm, opts.computed); }
  // 初始化 watch
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}
```

`initState` 方法主线很清晰，分别对 `props`、`methods`、`data`、`computed` 和 `wathcer` 定义的对象做了初始化操作，我们接下来依依分析。



## initProps - 初始化props

在初始化 `props` 之前，`vue` 已经做了两件事情，一是在选项合并的时候规范 `props`  ，二是接收父组件传递的值放在`propsData` 中。

最终调用 `defineReactive` 对 `props`的值做响应式处理

```js
function initProps (vm: Component, propsOptions: Object) {
  // 接收父组件的值
  const propsData = vm.$options.propsData || {}
  const props = vm._props = {}
  const keys = vm.$options._propKeys = []
  const isRoot = !vm.$parent
  // 有父组件，props 嵌套对象不做响应式处理
  if (!isRoot) {
    toggleObserving(false)
  }
  // 遍历 props
  for (const key in propsOptions) {
    keys.push(key)
    // 校验 props 属性 ，并取得 props 属性值
    const value = validateProp(key, propsOptions, propsData, vm)
    // 对 props 进行赋值，会执行回调报错
    defineReactive(props, key, value, () => {
      if (!isRoot && !isUpdatingChildComponent) {
        warn(
          `Avoid mutating a prop directly since the value will be ` +
          `overwritten whenever the parent component re-renders. ` +
          `Instead, use a data or computed property based on the prop's ` +
          `value. Prop being mutated: "${key}"`,
          vm
        )
      }
    })
    if (!(key in vm)) {
      proxy(vm, `_props`, key)
    }
  }
  toggleObserving(true)
}

```



初始化 `props` 流程

- 如果是子组件，执行`toggleObserving(false)` ，`props` 的嵌套对象不会进行响应式处理，因为父组件传递对象的时候已经实现了响应式

- 遍历定义的 `props` 对象，执行 `validateProp` 方法检验 `props` 属性并取得它的值，
-  `defineReactive` 方法把每个 `prop` 对应的值变成响应式；如果 `props` 赋值触发 `setter` 方法，执行第四个参数的回调函数控制台报错，这也是我们常说的单向数据流
- 通过 `proxy` 把 `vm._props.xxx` 的访问代理到 `vm.xxx` 上。



## initMethods - 初始化 methods

`initMethod`方法和介绍的响应式没有任何的关系，他的实现也相对简单，主要是保证 `methods`  方法定义必须是函数，且命名不能和`props` 以及 `vm` 实例属性方法重复，最终会将定义的方法都挂载到实例上。



```js
function initMethods (vm, methods) {
    var props = vm.$options.props;
    for (var key in methods) {
      {
        // method必须为函数形式
        if (typeof methods[key] !== 'function') {
          warn(
            "Method \"" + key + "\" has type \"" + (typeof methods[key]) + "\" in the component definition. " +
            "Did you reference the function correctly?",
            vm
          );
        }
        // methods方法名不能和props重复
        if (props && hasOwn(props, key)) {
          warn(
            ("Method \"" + key + "\" has already been defined as a prop."),
            vm
          );
        }
        //  不能以_ or $.这些Vue保留标志开头
        if ((key in vm) && isReserved(key)) {
          warn(
            "Method \"" + key + "\" conflicts with an existing Vue instance method. " +
            "Avoid defining component methods that start with _ or $."
          );
        }
      }
      // 直接挂载到实例的属性上,可以通过vm[method]访问。
      vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);
    }
  }
```



## initData - 初始化 data



`initData` 遍历 `data` 对象，保证它的属性不能和 `props，methods` 重复，接着调用`proxy` 代理属性到 `vm` 实例上，最后调用 `observe` 实现 `data` 响应式

```js
function initData(vm) {
  var data = vm.$options.data;
  // 根实例时，data是一个对象，子组件的data是一个函数，其中getData会调用函数返回data对象
  data = vm._data = typeof data === 'function'? getData(data, vm): data || {};
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;
  while (i--) {
    var key = keys[i];
    {
      // 命名不能和方法重复
      if (methods && hasOwn(methods, key)) {
        warn(("Method \"" + key + "\" has already been defined as a data property."),vm);
      }
    }
    // 命名不能和props重复
    if (props && hasOwn(props, key)) {
      warn("The data property \"" + key + "\" is already declared as a prop. " + "Use prop default value instead.",vm);
    } else if (!isReserved(key)) {
      // 数据代理，用户可直接通过vm实例返回data数据
      proxy(vm, "_data", key);
    }
  }
  // observe data
  observe(data, true /* asRootData */);
}
```



### data 依赖收集

`observe` 执行会实例化一个 `Observer`类，这个类的定义如下(忽略数组类型的`data`):

```js
// initData 
function initData(data) {
  ···
  observe(data, true)
}
// observe
function observe(value, asRootData) {
  ···
  ob = new Observer(value);
  return ob
}
```



`Observer` 观察者类，定义对象或数组getter和setter方法

```js
var Observer = function Observer (value) {
    this.value = value
    this.dep = new Dep() // 依赖收集
    // 将__ob__属性设置成不可枚举属性。外部无法通过遍历获取。
    def(value, '__ob__', this);
    // 数组处理
    if (Array.isArray(value)) {
        ···
    } else {
      // 对象处理
      this.walk(value);
    }
  };
function def (obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable, // 是否可枚举
    writable: true,
    configurable: true
  });
}
```



`Observer`会为`data`添加一个`__ob__`属性， `__ob__`属性是作为响应式对象的标志，`data` 是一个对象调用`walk`方法，遍历对象上每个属性执行 `defineReactive`, 它进行`getter,setter`的改写。

```js
Observer.prototype.walk = function walk (obj) {
    // 获取对象所有属性，遍历调用defineReactive###1进行改写
    var keys = Object.keys(obj);
    for (var i = 0; i < keys.length; i++) {
        defineReactive(obj, keys[i]);
    }
};
```



 `defineReactive `是响应式构建的核心，它会先**实例化一个`Dep`类，即为每个数据都创建一个依赖的管理**，之后利用 `Object.defineProperty` 重写 `getter,setter` 方法。

```js
function defineReactive (obj,key,val,customSetter,shallow) {
    // 每个数据实例化一个Dep类，创建一个依赖的管理
    var dep = new Dep();
    var property = Object.getOwnPropertyDescriptor(obj, key);
    // 属性必须满足可配置
    if (property && property.configurable === false) {
      return
    }
    // cater for pre-defined getter/setters
    var getter = property && property.get;
    var setter = property && property.set;
    // 这一部分的逻辑是针对深层次的对象，如果对象的属性是一个对象，则会递归调用实例化Observe类，让其属性值也转换为响应式对象
    var childOb = !shallow && observe(val);
    Object.defineProperty(obj, key, {
      enumerable: true,
      configurable: true,s
      get: function reactiveGetter () {
        var value = getter ? getter.call(obj) : val;
        if (Dep.target) {
          // 为当前watcher添加dep数据
          dep.depend();
          if (childOb) {
            childOb.dep.depend();
            if (Array.isArray(value)) {
              dependArray(value);
            }
          }
        }
        return value
      },
      set: function reactiveSetter (newVal) {}
    });
  }
```



### dep 实例化

从上面分析，我们得知 `Dep` 实例化有两处：

- `defineReactive` 方法`new Dep`

- 在实例化 `Observer` 执行构造器，`new Dep`

  

其实 `Vue` 这样设计是有依据的，第一处实例化 `Dep` 是为了访问对象属性时进行收集依赖。第二处实例化是为了数组响应式处理，数据响应式重写了数组的7个方法，调用数组方法更新，需要拿到数组 `dep` 实例进行派发更新，只有挂载在数组值身上才能拿到。但不管是数组还是对象，最终都是在 `getter` 方法进行依赖收集



### data 派发更新

在数据发生改变时，会执行定义好的`setter`方法，我们先看源码。

```js
Object.defineProperty(obj,key, {
  ···
  set: function reactiveSetter (newVal) {
      var value = getter ? getter.call(obj) : val;
      // 新值和旧值相等时，跳出操作
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      ···
      // 新值为对象时，会为新对象进行依赖收集过程
      childOb = !shallow && observe(newVal);
      dep.notify();
    }
})
```



派发更新阶段会做以下几件事：

- 判断数据更改前后是否一致，如果数据相等则不进行任何派发更新操作。
- 赋值 `newVal`，调用 `observe`，对新值做响应式处理。
- 调用该数据依赖收集器的`dep.notify`方法进行派发更新。

```js
Dep.prototype.notify = function notify () {
  var subs = this.subs.slice();
  if (!config.async) {
    // 根据依赖的id进行排序
    subs.sort(function (a, b) { return a.id - b.id; });
  }
  for (var i = 0, l = subs.length; i < l; i++) {
    // 遍历每个依赖，进行更新数据操作。
    subs[i].update();
  }
};
```



`update` 更新时会将`watcher`推到队列中，等待下一个`nextTick`到来时可以拿到更新的依赖 `watcher`

```js
Watcher.prototype.update = function update () {
  ···
  queueWatcher(this);
};
```



`queueWatcher`方法的调用，会将数据所收集的依赖依次推到`queue`数组中,数组会在下一个事件循环`nextTick`执行

```js
function queueWatcher (watcher) {
  var id = watcher.id;
  // 保证同一个watcher只执行一次
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      var i = queue.length - 1;
      while (i > index && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(i + 1, 0, watcher);
    }
    ···
    nextTick(flushSchedulerQueue);
  }
}
```



当下一个`nextTick`到来时，会执行`flushSchedulerQueue`方法，它会拿到收集的`queue`数组(这是一个`watcher`的集合),并对数组依赖进行排序。为什么进行排序呢？源码中解释了三点：



>组件创建是先父后子，所以组件的更新也是先父后子，因此需要保证父的渲染`watcher`优先于子的渲染`watcher`更新。
>
>**用户自定义的`watcher`,称为`user watcher`。 `user watcher`和`render watcher`执行也有先后，由于`user watchers`比`render watcher`要先创建，所以`user watcher`要优先执行**。
>
>如果一个组件在父组件的 `watcher` 执行阶段被销毁，那么它对应的 `watcher` 执行都可以被跳过。



```js
function flushSchedulerQueue () {
    currentFlushTimestamp = getNow();
    flushing = true;
    var watcher, id;
    // 对queue的watcher进行排序
    queue.sort(function (a, b) { return a.id - b.id; });
    // 循环执行queue.length，为了确保由于渲染时添加新的依赖导致queue的长度不断改变。
    for (index = 0; index < queue.length; index++) {
      watcher = queue[index];
      // 如果watcher定义了before的配置，则优先执行before方法
      if (watcher.before) {
        watcher.before();
      }
      id = watcher.id;
      has[id] = null;
      watcher.run();
      //...
  }
```



`flushSchedulerQueue`阶段，重要的过程可以总结为四点：

> 对`queue`中的`watcher`进行排序，原因上面已经总结。
>
> 遍历`watcher`,如果当前`watcher`有`before`配置，则执行`before`方法，对应前面的渲染`watcher`:在渲染`watcher`实例化时，我们传递了`before`函数，即在下个`tick`更新视图前，会调用`beforeUpdate`生命周期钩子。
>
> 执行`watcher.run`进行修改的操作。
>
> 重置恢复状态，这个阶段会将一些流程控制的状态变量恢复为初始值，并清空记录`watcher`的队列。



`beforeUpdate` 定义

```js
new Watcher(vm, updateComponent, noop, {
  before: function before () {
    if (vm._isMounted && !vm._isDestroyed) {
      callHook(vm, 'beforeUpdate');
    }
  }
}, true /* isRenderWatcher */);
```



重点看看`watcher.run()`的操作。

```js
Watcher.prototype.run = function run () {
    if (this.active) {
      var value = this.get();
      if ( value !== this.value || isObject(value) || this.deep ) {
        // 设置新值
        var oldValue = this.value;
        this.value = value;
        // 针对user watcher，暂时不分析
        if (this.user) {
          try {
            this.cb.call(this.vm, value, oldValue);
          } catch (e) {
            handleError(e, this.vm, ("callback for watcher \"" + (this.expression) + "\""));
          }
        } else {
          this.cb.call(this.vm, value, oldValue);
        }
      }
    }
  };
```



首先会执行`watcher.prototype.get`的方法，得到数据变化后的当前值，之后会对新值做判断，如果判断满足条件，则执行`cb`，`cb`为实例化`watcher`时传入的回调。

在分析`get`方法前，回头看看`watcher`构造函数的几个属性定义

```js
var watcher = function Watcher(
  vm, // 组件实例
  expOrFn, // 执行函数
  cb, // 回调
  options, // 配置
  isRenderWatcher // 是否为渲染watcher
) {
  this.vm = vm;
    if (isRenderWatcher) {
      vm._watcher = this;
    }
    vm._watchers.push(this);
    // options
    if (options) {
      this.deep = !!options.deep;
      this.user = !!options.user;
      this.lazy = !!options.lazy;
      this.sync = !!options.sync;
      this.before = options.before;
    } else {
      this.deep = this.user = this.lazy = this.sync = false;
    }
    this.cb = cb;
    this.id = ++uid$2; // uid for batching
    this.active = true;
    this.dirty = this.lazy; // for lazy watchers
    this.deps = [];
    this.newDeps = [];
    this.depIds = new _Set();
    this.newDepIds = new _Set();
    this.expression = expOrFn.toString();
    // parse expression for getter
    if (typeof expOrFn === 'function') {
      this.getter = expOrFn;
    } else {
      this.getter = parsePath(expOrFn);
      if (!this.getter) {
        this.getter = noop;
        warn(
          "Failed watching path: \"" + expOrFn + "\" " +
          'Watcher only accepts simple dot-delimited paths. ' +
          'For full control, use a function instead.',
          vm
        );
      }
    }
    // lazy为计算属性标志，当watcher为计算watcher时，不会理解执行get方法进行求值
    this.value = this.lazy
      ? undefined
      : this.get();
}
```



方法`get`的定义如下：

```js
Watcher.prototype.get = function get () {
    pushTarget(this);
    var value;
    var vm = this.vm;
    try {
      value = this.getter.call(vm, vm);
    } catch (e) {
     ···
    } finally {
      ···
      // 把Dep.target恢复到上一个状态，依赖收集过程完成
      popTarget();
      this.cleanupDeps();
    }
    return value
  };

```



`get`方法会执行`this.getter`进行求值，在当前渲染`watcher`的条件下,`getter`会执行视图更新的操作。这一阶段会**重新渲染页面组件**

```js
new Watcher(vm, updateComponent, noop, { before: () => {} }, true);
updateComponent = function () {
  vm._update(vm._render(), hydrating);
};
```



### 依赖清除



执行完`getter`方法后，最后一步会进行依赖的清除，也就是`cleanupDeps`的过程。

> 关于依赖清除的作用，我们列举一个场景： 我们经常会使用`v-if`来进行模板的切换，切换过程中会执行不同的模板渲染，如果A模板监听a数据，B模板监听b数据，当渲染模板B时，如果不进行旧依赖的清除，在B模板的场景下，a数据的变化同样会引起依赖的重新渲染更新，这会造成性能的浪费。因此旧依赖的清除在优化阶段是有必要。

```js
// 依赖清除的过程
  Watcher.prototype.cleanupDeps = function cleanupDeps () {
    var i = this.deps.length;
    while (i--) {
      var dep = this.deps[i];
      if (!this.newDepIds.has(dep.id)) {
        dep.removeSub(this);
      }
    }
    var tmp = this.depIds;
    this.depIds = this.newDepIds;
    this.newDepIds = tmp;
    this.newDepIds.clear();
    tmp = this.deps;
    this.deps = this.newDeps;
    this.newDeps = tmp;
    this.newDeps.length = 0;
  };
```



总结成依赖派发更新的最后两个点

- **执行`run`操作会执行`getter`方法,也就是重新计算新值，针对渲染`watcher`而言，会重新执行`updateComponent`进行视图更新**
- **重新计算`getter`后，会进行依赖的清除**



## initComputed - 初始化 compouted

`initComputed` 是 `computed` 数据的初始化, 源码实现逻辑：

- `computed` 可以是对象，也可以是函数，但是对象必须有 `getter` 方法, 如果 `computed` 中的属性值是对象时需要进行验证。

- 针对 `computed` 的每个属性，要创建一个监听的依赖，也就是实例化一个 `watcher`， `watcher`的定义，可以暂时理解为数据使用的依赖本身，一个 `watcher` 实例代表了一个需要被监听的数据依赖。

- `initComputed`  将每个 `computed` 属性设置成响应式的数据，同样的，也会对`computed`的命名做检测，防止与 `props,data` 冲突。



```js
// computed watcher的标志，lazy属性为true
var computedWatcherOptions = { lazy: true };

function initComputed (vm, computed) {
  ···
  for (var key in computed) {
      var userDef = computed[key];
      var getter = typeof userDef === 'function' ? userDef : userDef.get;
      // computed属性为对象时，要保证有getter方法
      if (getter == null) {
        warn(("Getter is missing for computed property \"" + key + "\"."),vm);
      }
      if (!isSSR) {
        // 创建computed watcher
        watchers[key] = new Watcher(vm,getter || noop,noop,computedWatcherOptions);
      }
      if (!(key in vm)) {
        // 设置为响应式数据
        defineComputed(vm, key, userDef);
      } else {
        // 不能和props，data命名冲突
        if (key in vm.$data) {
          warn(("The computed property \"" + key + "\" is already defined in data."), vm);
        } else if (vm.$options.props && key in vm.$options.props) {
          warn(("The computed property \"" + key + "\" is already defined as a prop."), vm);
        }
      }
    }
}
```

`defineComputed`的逻辑和分析`data`的逻辑相似，最终调用 `Object.defineProperty` 进行数据拦截。具体的定义如下：

```js
function defineComputed (target,key,userDef) {
  // 非服务端渲染会对getter进行缓存
  var shouldCache = !isServerRendering();
  if (typeof userDef === 'function') {
    // 
    sharedPropertyDefinition.get = shouldCache
      ? createComputedGetter(key)
      : createGetterInvoker(userDef);
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get
      ? shouldCache && userDef.cache !== false
        ? createComputedGetter(key)
        : createGetterInvoker(userDef.get)
      : noop;
    sharedPropertyDefinition.set = userDef.set || noop;
  }
  if (sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function () {
      warn(
        ("Computed property \"" + key + "\" was assigned to but it has no setter."),
        this
      );
    };
  }
  Object.defineProperty(target, key, sharedPropertyDefinition);
}
```



在非服务端渲染的情形，计算属性的计算结果会被缓存，缓存的意义在于，**只有在相关响应式数据发生变化时，`computed`才会重新求值，其余情况多次访问计算属性的值都会返回之前计算的结果，这就是缓存的优化**

`computed`属性有两种写法，一种是函数，另一种是对象，其中对象的写法需要提供 `getter` 和 `setter` 方法。

当访问到 `computed` 属性时，会触发 `getter` 方法进行依赖收集，看看`createComputedGetter`的实现。



```js
function createComputedGetter (key) {
  return function computedGetter () {
    const watcher = this._computedWatchers && this._computedWatchers[key]
    if (watcher) {
      // dirty是标志是否已经执行过计算结果，如果执行过则不会执行watcher.evaluate重复计算，这也是缓存的原理
      if (watcher.dirty) {
        watcher.evaluate()
      }
      if (Dep.target) {
        watcher.depend()
      }
      return watcher.value
    }
  }
}
```



`createComputedGetter`返回的函数在执行过程中会先拿到属性的`computed watcher`, `dirty` 标志是否已经执行过计算结果，如果执行过则不会执行`watcher.evaluate`重复计算，这也是缓存的原理。

```js
Watcher.prototype.evaluate = function evaluate () {
    // 对于计算属性而言 evaluate的作用是执行计算回调
    this.value = this.get();
    this.dirty = false;
  };
```



### computed 依赖收集

和 `data` 分析一样，当访问 `computed` 属性会触发 `computedGetter` 方法，`watcher.dirty` 为 `true` 执行 `watcher.evaluate()` 从而调用 `get` 方法，如果 computed 计算访问 `data` 数据的属性值，会触发 `data` 数据的`getter`方法进行依赖收集，根据前面分析，`data`的`Dep`收集器会将当前 `watcher` 作为依赖进行收集，而这个`watcher`就是 `computed watcher`，并且会为当前的 `watcher` 添加访问的数据`Dep`



回到计算执行函数的`this.get()`方法，`getter`执行完成后同样会进行依赖的清除，原理和目的参考`data`阶段的分析。`get`执行完毕后会进入`watcher.depend`进行依赖的收集。收集过程和`data`一致,将当前的`computed watcher`作为依赖收集到数据的依赖收集器`Dep`中。

这就是`computed`依赖收集的完整过程，对比`data`的依赖收集，`computed`会对运算的结果进行缓存，避免重复执行运算过程。



### computed 派发更新

- 当计算属性依赖的数据发生更新时，由于数据的`Dep`收集过`computed watch`这个依赖，所以会调用`dep`的`notify`方法，对依赖进行状态更新。
- 此时`computed watcher`和之前介绍的`watcher`不同，它不会立刻执行依赖的更新操作，而是通过一个`dirty`进行标记。我们再回头看`依赖更新`的代码。



```js
Dep.prototype.notify = function() {
  ···
   for (var i = 0, l = subs.length; i < l; i++) {
      subs[i].update();
    }
}
Watcher.prototype.update = function update () {
  // 计算属性分支  
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};
```



由于`lazy`属性的存在，`update`过程不会执行状态更新的操作，只会将`dirty`标记为`true`。

- 由于 `data` 数据拥有渲染 `watcher` 这个依赖，所以同时会执行`updateComponent`进行视图重新渲染,而`render`过程中会访问到计算属性,此时由于`this.dirty`值为`true`,又会对计算属性重新求值。



## initWatch - 初始化 watch



初始化 `watch` ，遍历 `watch`, 如果 watch 属性值是一个数组，则递归处理。`initWatch`的核心是`createWatcher`

```js
function initWatch (vm: Component, watch: Object) {
  for (const key in watch) {
    const handler = watch[key]
    if (Array.isArray(handler)) {
      for (let i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i])
      }
    } else {
      createWatcher(vm, key, handler)
    }
  }
}

function createWatcher (vm,expOrFn,handler,options) {
    // 针对watch是对象的形式，此时回调回选项中的handler
    if (isPlainObject(handler)) {
      options = handler;
      handler = handler.handler;
    }
    if (typeof handler === 'string') {
      handler = vm[handler];
    }
    return vm.$watch(expOrFn, handler, options)
  }
```



### watch 依赖收集

无论是选项的形式，还是`api`的形式，最终都会调用实例的`$watch`方法，其中`expOrFn`是监听的字符串，`handler`是监听的回调函数，`options`是相关配置。我们重点看看`$watch`的实现



```js
Vue.prototype.$watch = function (expOrFn,cb,options) {
    var vm = this;
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options)
    }
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    // 当watch有immediate选项时，立即执行cb方法，即不需要等待属性变化，立刻执行回调。
    if (options.immediate) {
      try {
        cb.call(vm, watcher.value);
      } catch (error) {
        handleError(error, vm, ("callback for immediate watcher \"" + (watcher.expression) + "\""));
      }
    }
    return function unwatchFn () {
      watcher.teardown();
    }
  };
}
```



`$watch`的核心是创建一个`user watcher`, `user`是当前用户定义`watcher`的标志。如果有`immediate`属性，则立即执行回调函数。而实例化`watcher`时会执行一次`getter`求值，这时，`user watcher`会作为依赖被数据所收集。这个过程可以参考`data`的分析。

```js
var Watcher = function Watcher() {
  ···
  if (typeof expOrFn === 'function') {
      this.getter = expOrFn
    } else {
      this.getter = parsePath(expOrFn)
      if (!this.getter) {
        this.getter = noop
        process.env.NODE_ENV !== 'production' && warn(
          `Failed watching path: "${expOrFn}" ` +
          'Watcher only accepts simple dot-delimited paths. ' +
          'For full control, use a function instead.',
          vm
        )
      }
    }
  this.value = this.lazy
      ? undefined
      : this.get();
}

// 解析字符串
function parsePath (path: string): any {
  if (bailRE.test(path)) {
    return
  }
  const segments = path.split('.')
  return function (obj) {
    for (let i = 0; i < segments.length; i++) {
      if (!obj) return
      obj = obj[segments[i]]
    }
    return obj
  }
}

Watcher.prototype.get = function get() {
  ···
  try {
    // getter回调函数，触发依赖收集
    value = this.getter.call(vm, vm);
  } 
}
```



### watch 派发更新

`watch` 派发更新，当数据发生改变时，`setter`拦截对依赖进行更新，而此前`user watcher`已经被当成依赖收集了。这个时候依赖的更新就是回调函数的执行。



## Watcher 

从上面分析，我们知道在初始化 `computed` 和 `watch` 都会实例化 `Watcher` 类，实际上 `watcher` 实例化总共分为三类，分别是 `render watcher`, `user watcher`, `computed watcher`, 它们对应的场景是渲染时要收集的依赖，用户定义的 `watch`, 以及用户定义的 `computed`。通过`isRenderWatcher`, `user`, `lazy` 区分

```js
var watcher = function Watcher(
  vm, // 组件实例
  expOrFn, // 执行函数
  cb, // 回调
  options, // 配置
  isRenderWatcher // 是否为渲染watcher
) {
  this.vm = vm;
    if (isRenderWatcher) { // 渲染
      vm._watcher = this;
    }
    vm._watchers.push(this);
    // options
    if (options) {
      this.user = !!options.user; // watch 用户定义
      this.lazy = !!options.lazy; // computed 定义
    } else {
      this.deep = this.user = this.lazy = this.sync = false;
    }
    this.cb = cb;
    this.dirty = this.lazy; // for lazy watchers

}
```



## 响应式 API

### set

`set` 方法给对象或数组添加一个 `响应式值`, 它是弥补 `Object.defineProperty` 无法监控到对象新增的值，以下是它的实现原理：

- 目标对象必须为非空的对象，可以是数组，否则抛出异常。
- 如果目标对象是数组时，调用数组的 `splice` 方法，遇到数组新增元素的场景，会调用 `ob.observeArray(inserted)` 对数组新增的元素收集依赖。
- 新增的属性值在原对象中已经存在，则手动访问新的属性值，这一过程会触发依赖收集。
- 如果目标对象不是响应式对象，直接返回。如果是响应式对象，调用`defineReactive` 方法手动定义新属性的 `getter,setter` 方法，并通过 `notify` 触发依赖更新。


```js
function set (target: Array<any> | Object, key: any, val: any): any {
  if (process.env.NODE_ENV !== 'production' &&
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(`Cannot set reactive property on undefined, null, or primitive value: ${(target: any)}`)
  }
  // 数组场景，调用重写的splice方法，对新添加属性收集依赖。
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key)
    target.splice(key, 1, val)
    return val
  }
  // 新增对象的属性存在时，直接返回新属性，触发依赖收集
  if (key in target && !(key in Object.prototype)) {
    target[key] = val
    return val
  }
  const ob = (target: any).__ob__
  // 数据是组件实例，直接返回
  if (target._isVue || (ob && ob.vmCount)) {
    process.env.NODE_ENV !== 'production' && warn(
      'Avoid adding reactive properties to a Vue instance or its root $data ' +
      'at runtime - declare it upfront in the data option.'
    )
    return val
  }
   // 目标源对象本身不是一个响应式对象，则不需要处理
  if (!ob) {
    target[key] = val
    return val
  }
  // 手动调用defineReactive，为新属性设置getter,setter
  defineReactive(ob.value, key, val)
  // 修改响应式数据派发更新
  ob.dep.notify()
  return val
}
```

### del

`del` 方法使用场景比较少，它是删除对象的属性，然后派发更新。以下是它的实现原理。

- 如果目标对象是数组时，调用数组的 `splice` 方法删除。

- 目标对象不存在属性，直接返回，否则使用 `delete` 删除属性

- 如果是响应式对象，派发更新

```js
function del (target: Array<any> | Object, key: any) {
  if (process.env.NODE_ENV !== 'production' &&
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(`Cannot delete reactive property on undefined, null, or primitive value: ${(target: any)}`)
  }
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1)
    return
  }
  const ob = (target: any).__ob__
  if (target._isVue || (ob && ob.vmCount)) {
    process.env.NODE_ENV !== 'production' && warn(
      'Avoid deleting properties on a Vue instance or its root $data ' +
      '- just set it to null.'
    )
    return
  }
  if (!hasOwn(target, key)) {
    return
  }
  delete target[key]
  if (!ob) {
    return
  }
  // 修改响应式数据派发更新
  ob.dep.notify()
}
```

## 响应式过程

<a data-fancybox href="http://assets.processon.com/chart_image/6039bd87f346fb1149000367.png">![挂载流程图](http://assets.processon.com/chart_image/6039bd87f346fb1149000367.png)</a>

## 手动实现一个响应式

以下是手动实现一个响应式的简约版

```js
function noop () {}
const sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
}

function proxy (target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  }
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val
  }
  Object.defineProperty(target, key, sharedPropertyDefinition)
}

const defaultTagRE = /\{\{(\w+?)\}\}/g

function parseText (vm, html) {
  const tagRE = defaultTagRE
  if (!tagRE.test(html)) {
    return
  }

  let match
  while ((match = tagRE.exec(html))) {
    html = html.replace(match[0], vm[match[1]])
  }
  return html
}


class Vue {
  constructor(options) {
    this._init(options)
  }

  _init (options) {
    const vm = this
    this.$options = options;
    this.initState(vm)
    // 有 el, 执行 $mount 方法
    if (vm.$options.el) {
      vm.$mount(vm.$options.el)
    }
  }

  initState(vm) {
    vm._watchers = []
    const opts = vm.$options
    // 调用 observe 方法设置 data 为响应式，并且避免和 props、methods 重名
    if (opts.data) {
      initData(vm)
    } else {
      observe(vm._data = {})
    }

    // 初始化 computed
    if (opts.computed) {
      initComputed(vm, opts.computed)
    }
    // 初始化 watch
    if (opts.watch) {
      initWatch(vm, opts.watch)
    }
    }

    // 对外暴露调用订阅者的接口，内部主要在指令中使用订阅者
    $watch(expOrFn, cb, options) {
      const watcher = new Watcher(this, expOrFn, cb, {user: true});
      // 立即执行
      if (options.immediate) {
        try {
          cb.call(this, watcher.val)
        } catch (error) {
          console.error(`callback for immediate watcher "${watcher.expression}"`)
        }
      }
      
    }

    $mount(el) {
      // 直接改写innerHTML
      const vm = this
      let innerHtml = el && document.querySelector(el)
      
      const updateComponent = () => {
        if (innerHtml) {
          let template = ''
          if (this.$options.template) {
            template = this.$options.template
          }
          innerHtml = compileText(this, template)
          
          document.querySelector(el).innerHTML = innerHtml

          setTimeout(() => {
            document.querySelector('#change').addEventListener('click', () => {
              console.log('333')
              vm.age = vm.age + 1
            })
          }, 0)
        }
      }
      // 创建一个渲染的依赖。
      new Watcher(this, updateComponent, noop, {
        before () {
          // beforeUpdate 钩子函数
        }
      }, true)
    }
  }

  function compileText (vm, html) {
    html = parseText(vm, html)
    return html
  }

/**
 * 初始化 data
 * @param {*} vm
 */
function initData(vm) {
  let data = vm.$options.data
  // 定义私有属性 _data, 根实例时，data是一个对象，子组件的data是一个函数
  data = vm._data = typeof data === 'function'
    ? data.call(vm, vm)
    : data || {}

  const keys = Object.keys(data)
  let i = keys.length
  while (i--) {
    const key = keys[i]
    proxy(vm, `_data`, key)
  }
  observe(data)
}

const computedWatcherOptions = { lazy: true }
function initComputed(vm, computed) {
  const watchers = vm._computedWatchers = Object.create(null)

  for (const key in computed) {
    const userDef = computed[key]
    const getter = typeof userDef === 'function' ? userDef : userDef.get
    // 要保证有getter方法
    if (getter == null) {
      console.error(
        `Getter is missing for computed property "${key}".`
      )
    }

    watchers[key] = new Watcher(
      vm,
      getter || noop,
      noop,
      computedWatcherOptions
    )

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      // 设置为响应式数据
      defineComputed(vm, key, userDef)
    } else if (process.env.NODE_ENV !== 'production') {
      // 不能和props，data命名冲突
      if (key in vm.$data) {
        console.error(`The computed property "${key}" is already defined in data.`)
      } else if (vm.$options.props && key in vm.$options.props) {
        console.error(`The computed property "${key}" is already defined as a prop.`)
      }
    }
  }
}

function defineComputed (
  target,
  key,
  // userDef
) {

  sharedPropertyDefinition.get = createComputedGetter(key)
  sharedPropertyDefinition.set = noop
  
  Object.defineProperty(target, key, sharedPropertyDefinition)
}

function createComputedGetter (key) {
  return function computedGetter () {
    const watcher = this._computedWatchers && this._computedWatchers[key]
    if (watcher) {
      // dirty是标志是否已经执行过计算结果，如果执行过则不会执行watcher.evaluate重复计算，这也是缓存的原理
      if (watcher.dirty) {
        watcher.evaluate()
      }
      // 将 computed watch 收集到当前 watch 实例下所有的 deps
      if (Dep.target) {
        watcher.depend()
      }
      return watcher.val
    }
  }
}

/**
 *初始化 watch
 * @param {*} vm
 * @param {*} watch
 */
function initWatch(vm, watch) {
  if (!watch || typeof watch !== 'object') {
    return
  }

  for (const key in watch) {
    const handler = watch[key]
    if (Array.isArray(handler)) {
      for (let i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i])
      }
    } else {
      createWatcher(vm, key, handler)
    }
  }
}

function createWatcher (
  vm,
  expOrFn,
  handler,
  options
) {
  if (typeof handler === 'object') {
    options = handler
    handler = handler.handler
  }
  if (typeof handler === 'string') {
    handler = vm[handler]
  }
  return vm.$watch(expOrFn, handler, options)
}

let uid = 0;
// 发布中心 存储订阅者 -发布订阅
class Dep {
  constructor() {
    // 设置id,用于区分新Watcher和只改变属性值后新产生的Watcher
    this.id = uid++;
    // 储存订阅者的数组
    this.subs = [];
  }

  // 添加订阅者
  addSub(sub) {
    this.subs.push(sub);
  }

  // 监测是否已经存在sub中
  depend() {
    if (Dep.target) {
      Dep.target.addDep(this);
    }
  }
  
  notify() {
    // 通知所有的订阅者(Watcher)
    this.subs.forEach(sub => sub.update());
  }
}

function parsePath (path) {
  if (!path) return

  const segments = path.split('.')
  return function (obj) {
    for (let i = 0; i < segments.length; i++) {
      if (!obj) return
      obj = obj[segments[i]]
    }
    return obj
  }
}

/**
 * 订阅者对象
 * @class Watcher
 */
class Watcher {
  constructor(vm, expOrFn, cb, options, isRenderWatcher) {
    this.depIds = {}; // hash储存订阅者的id,避免重复的订阅者
    this.vm = vm; // 被订阅的数据一定来自于当前Vue实例
    if (isRenderWatcher) {
      this.vm._watcher = isRenderWatcher
    }
    if (options) {
      if (options.user) {
        this.user = options.user
      }
      if (options.lazy) {
        this.lazy = options.lazy
      }
    }
    this.cb = cb
    this.dirty = this.lazy
    this.deps = []
    if (typeof expOrFn === 'function') {
      this.getter = expOrFn; // 当数据更新时想要做的事情
    } else {
      this.getter = parsePath(expOrFn)
    }
    
    this.val = this.get(); // 维护更新之前的数据
  }
  // 对外暴露的接口，用于在订阅的数据被更新时，由订阅者管理员(Dep)调用
  update() {
    this.run();
  }
  addDep(dep) {
    // 如果在depIds的hash中没有当前的id,可以判断是新Watcher,因此可以添加到dep的数组中储存
    // 此判断是避免同id的Watcher被多次储存
    if (!this.depIds.hasOwnProperty(dep.id)) {
      //   console.log(this.depIds,dep.id);
      this.depIds[dep.id] = dep;
      this.deps.push(dep)

      dep.addSub(this);
      console.log(dep)
    }else {
      //   console.log(dep.id,'重复订阅')
        return;
    }
  }
  run() {
    const val = this.get();
  
    if (val !== this.val) {
      const oldVal = this.val
      this.val = val;
      this.cb.call(this.vm, val, oldVal);
    }
  }
  get() {
    // 当前订阅者(Watcher)读取被订阅数据的最新更新后的值时，通知订阅者管理员收集当前订阅者
    pushTarget(this)
    const vm = this.vm
    const val = this.getter.call(vm, vm)
    // 置空，用于下一个Watcher使用
    popTarget()
    return val;
  }

  /**
   * 专门为 computed watch 设计的方法
   * @memberof Watcher
   */
  evaluate () {
    this.val = this.get()
    this.dirty = false
  }

  /**
   * Depend on all deps collected by this watcher.
   * 收集所有的 watch
   */
  depend () {
    let i = this.deps.length
    while (i--) {
      this.deps[i].depend()
    }
  }
}
// 为Dep类设置一个静态属性,默认为null,工作时指向当前的Watcher
Dep.target = null
const targetStack = []

function pushTarget (target) {
  targetStack.push(target)
  Dep.target = target
}

function popTarget () {
  targetStack.pop()
  Dep.target = targetStack[targetStack.length - 1]
}
// 监听者,监听对象属性值的变化
class Observer {
  constructor(value) {
    this.value = value;
      // 遍历属性值
    if (Array.isArray(value)) {

    } else {
      this.walk(value)
    }
  }

  walk(obj) {
    const keys = Object.keys(obj);
    for(let i = 0;i< keys.length; i++) {
      // Object.defineProperty的处理逻辑
      defineReactive(obj, keys[i], obj[keys[i]])
    }
  }
}

function defineReactive(obj, key, val) {
  const dep = new Dep();
  // 给当前属性的值添加监听
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: () => {
      // 如果Dep类存在target属性，将其添加到dep实例的subs数组中
      // target指向一个Watcher实例，每个Watcher都是一个订阅者
      // Watcher实例在实例化过程中，会读取data中的某个属性，从而触发当前get方法
      if (Dep.target) {
        dep.depend();
      }
      return val;
    },
    set: newVal => {
      if (val === newVal) return;
      val = newVal;
      // 对新值进行监听
      // 通知所有订阅者，数值被改变了
      dep.notify();
    },
  });
}

function observe(value) {
  // 不考虑复杂类型  源码递归实现
  if (!value || typeof value !== 'object') {
    return;
  }
  return new Observer(value);
}




let vm = new Vue({
  data: {
    hello: 'hello world',
    age:222,
    sex: '22'
  },
  template: `
    <!-- <h1> {{hello}}</h1> -->
    <h1> {{showAge}}</h1>
    <h1> {{sex}}</h1>
    <button id="change">change</button>
  `,
  watch: {
    age: {
      handler: function (newVal, oldVal) {
        console.log(newVal, oldVal)
      },
      immediate: true
    }
  },
  computed: {
    showAge() {
      return '年龄是' + this.age
    }
  }
});

vm.$mount('#app')

```

