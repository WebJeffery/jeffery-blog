---
title: 元素尺寸
date: 2021-04-12 19:33:10
permalink: /pages/azdweweweew
author: 
  name: jeffery
categories: 
  - javascript
tags: 
  - javascript
---

# 元素尺寸

## 偏移 offset

偏移量包括 `offsetLeft`、`offsetTop`、`offsetHeight`、`offsetWidth` 这四个属性。还有一个偏移参照——定位父级 `offsetParent`

![offset](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_DOM_size_offset.jpg)

### 定位父级

定位父级 `offsetParent` 的定义：与当前元素最近的经过定位( `position` 不等于 `static` )的父级元素，主要分为下列几种情况 

【1】元素自身有 `fixed` 定位，`offsetParent` 的结果为 `null`

当元素自身有 `fixed` 固定定位时，固定定位的元素相对于视口进行定位，此时没有定位父级，`offsetParent` 的结果为 `null`

[注意]firefox浏览器有兼容性问题

```html
<div id="test" style="position:fixed"></div>    
<script>
//firefox并没有考虑固定定位的问题，返回<body>，其他浏览器都返回null
console.log(test.offsetParent);
</script>
```

【2】元素自身无 `fixed` 定位，且父级元素都未经过定位，`offsetParent` 的结果为 `<body>`

```html
<div id="test"></div>    
<script>
console.log(test.offsetParent);//<body>
</script>
```

【3】元素自身无 `fixed` 定位，且父级元素存在经过定位的元素，`offsetParent` 的结果为离自身元素最近的经过定位的父级元素

```html
<div id="div0" style="position:absolute;">
    <div id="div1" style="position:absolute;">
        <div id='test'></div>    
    </div>    
</div>
<script>
console.log(test.offsetParent);    //<div id="div1">
</script>
```

【4】`<body>` 元素的 `parentNode` 是`null`

```js
console.log(document.body.offsetParent);//null
```
### 偏移量

**offsetWidth**

`offsetWidth` 表示元素在水平方向上占用的空间大小，无单位(以像素px计)

```js
offsetWidth =  border-left-width + padding-left + width + padding-right + border-right-width; 
```

**offsetHeight**

`offsetHeight` 表示元素在垂直方向上占用的空间大小，无单位(以像素px计)

```html
<!-- offsetHeight =  border-top-width + padding-top + height + padding-bottom + border-bottom-width -->
<div id="test" style="width:100px; height:100px; padding:10px; margin:10px; border:1px solid black;"></div>    
<script>
//122=1+10+100+10+1
console.log(test.offsetWidth);
console.log(test.offsetHeight);
</script>
```

[注意]如果存在垂直滚动条，`offsetWidth` 也包括垂直滚动条的宽度；如果存在水平滚动条，`offsetHeight` 也包括水平滚动条的高度

```html
<div id="test" style="width:100px; height:100px; padding:10px; margin:10px; border:1px solid black; overflow: scroll;"></div>    
<script>
//IE8-浏览器将垂直滚动条的宽度计算在width宽度和height高度中，width和height的值仍然是100px；
//而其他浏览器则把垂直滚动条的宽度从width宽度中移出，把水平滚动条的高度从height高度中移出，则滚动条宽度为17px，width宽度和height高度为剩下的83px

if(window.getComputedStyle){
    console.log(getComputedStyle(test).width,getComputedStyle(test).height)//83px
}else{
    console.log(test.currentStyle.width,test.currentStyle.height);//100px
}
//122=1+10+100+10+1
console.log(test.offsetWidth,test.offsetHeight);
</script>
```

**offsetTop**

`offsetTop` 表示元素的上外边框至 `offsetParent` 元素的上内边框之间的像素距离

**offsetLeft**

`offsetLeft` 表示元素的左外边框至 `offsetParent`元素的左内边框之间的像素距离

```html
<div id="out" style="padding: 5px;position: relative;background-color: pink;margin: 6px;border:1px solid black">
    <div id="test" style="width:100px; height:100px; margin:10px;background-color:green;"></div>        
</div>
<script>
//15=test.marginTop(10) + out.paddingTop(5)
alert(test.offsetTop);
//15=test.marginLeft(10) + out.paddingLeft(5)
alert(test.offsetLeft);
</script>    
```

### 页面偏移

要知道某个元素在页面上的偏移量，将这个元素的 `offsetLeft` 和 `offsetTop`与其 `offsetParent` 的相同属性相加，并加上 `offsetParent`的相应方向的边框，如此循环直到根元素，就可以得到元素到页面的偏移量

```html
<style>
html,body{border: 0;}
body{margin:0;}
</style>
<div style="padding: 20px;border:1px solid black;position:absolute;">
    <div id="test" style="width:100px; height:100px; margin:10px;"></div>        
</div>        
<script>
function getElementLeft(element){
    var actualLeft = element.offsetLeft;
    var current = element.offsetParent;
    while(current != null){
        actualLeft += current.offsetLeft + current.clientLeft;
        current = current.offsetParent;
    }
    return actualLeft + 'px';
}
function getElementTop(element){
    var actualTop = element.offsetTop;
    var current = element.offsetParent;
    while(current != null){
        actualTop += current.offsetTop + current.clientTop;
        current = current.offsetParent;
    }
    return actualTop + 'px';
} 
//其他浏览器返回31(10+20+1)，而IE7-浏览器返回21((20和10的较大值)+1)
console.log(getElementTop(test));
//所有浏览器返回31(10+20+1)
console.log(getElementLeft(test));
</script>
```
### 注意事项

【1】所有偏移量属性都是只读的

```html
<div id="test" style="width:100px; height:100px; margin:10px;"></div>        
<script>
console.log(test.offsetWidth);//100
//IE8-浏览器会报错，其他浏览器则静默失败
test.offsetWidth = 10;
console.log(test.offsetWidth);//100
</script>
```

【2】如果给元素设置了 `display:none`，则它的偏移量属性都为 `0`

```html
<div id="test" style="width:100px; height:100px; margin:10px;display:none"></div>
<script>
console.log(test.offsetWidth);//0
console.log(test.offsetTop);//0
</script>
```

【3】每次访问偏移量属性都需要重新计算

```html
<div id="test" style="width:100px; height:100px; margin:10px;"></div>        
<script>
console.time("time");
for(var i = 0; i < 100000; i++){
    var a = test.offsetWidth;
}
console.timeEnd('time');//65.129ms
</script>
<div id="test" style="width:100px; height:100px; margin:10px;"></div>        
<script>
console.time("time");
var a = test.offsetWidth;
for(var i = 0; i < 100000; i++){
    var b = a;
}
console.timeEnd('time');//1.428ms
</script>
```

由上面代码对比可知，重复访问偏移量属性需要耗费大量的性能，所以要尽量避免重复访问这些属性。如果需要重复访问，则把它们的值保存在变量中，以提高性能

## 客户区尺寸client

关于元素尺寸，一般地，有偏移大小 `offset`、客户区大小 `client` 和滚动大小`scroll`。

![client](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_DOM_size_client.jpg)

### 客户区大小

客户区大小 `client` 指的是元素内容及其内边距所占据的空间大小

**clientHeight**

`clientHeight` 属性返回元素节点的客户区高度

```js
clientHeight = padding-top + height + padding-bottom
```

**clientWidth**

`clientWidth` 属性返回元素节点的客户区宽度

```html
<!-- clientWidth = padding-left + width + padding-right -->
<div id="test" style="width: 100px;height: 100px;padding: 10px;margin: 10px;border: 1px solid black;"></div>
<script>
//120(10+100+10)
console.log(test.clientHeight);
console.log(test.clientWidth);
</script>
```

[注意]滚动条宽度不计算在内

```html
<div id="test" style="width: 100px;height: 100px;padding: 10px;margin: 10px;border: 1px solid black;overflow:scroll"></div>
<script>
//103(120-17)，滚动条宽度为17px
console.log(test.clientHeight);
console.log(test.clientWidth);
</script>
<div id="test" style="width:100px;margin: 10px;border: 1px solid black;overflow:scroll;font-size:20px;line-height:1;height:100px">
    内容<br>内容<br>内容<br>内容<br>内容<br>内容<br>
</div>
<script>
//83(100-17)
console.log(test.clientHeight);
</script>
```

当 `height` 和纵向 `padding` 的和为0(以及小于`17px`的情况)时，如果仍然存在滚动条，各浏览器表现不一样

```html
<div id="test" style="width: 100px;height:0;margin: 10px;border: 1px solid black;overflow:scroll"></div>
<script>
//chrome/safari:-17(0-17)
//firefox/IE:0
console.log(test.clientHeight);
</script>
<div id="test" style="width: 100px;height:10px;margin: 10px;border: 1px solid black;overflow:scroll"></div>
<script>
//chrome/safari:-7(10-17)
//firefox/IE:0
console.log(test.clientHeight);
</script>
```

**bug**

如果设置 `overflow:scroll`，使得滚动条始终存在，当不设置高度 `height` 值时，各个浏览器表现不一样。firefox存在一个最小高度为 `34px` 的垂直滚动条，IE7-浏览器存在一个最小高度为 `19px` 的垂直滚动条，而其他浏览器的垂直滚动条无最小高度　

所以，当 `clientHeight` 的值小于 `34px` 时，`firefox` 会返回`34`；当`clientHeight`的值小于`19px`时，IE7-会返回19

```html
<div id="test" style="width: 100px;margin: 10px;border: 1px solid black;overflow:scroll"></div>
<script>
//chrome/IE8+/safari:0(因为height和padding都是0)
//firefox:34(设置overflow:scroll之后，默认存在一个高34px的垂直滚动条)
//IE7-:19(默认存在一个高19px的垂直滚动条)
console.log(test.clientHeight);
</script>
<div id="test" style="width: 100px;margin: 10px;border: 1px solid black;font-size:20px;line-height:1;overflow:scroll">内容</div>
<script>
//chrome/IE8+/safari:20(20*1)
//firefox:34(20<34)
//IE7-:20(20>19)
console.log(test.clientHeight);
</script>
<div id="test" style="width: 100px;padding-top:20px;margin: 10px;border: 1px solid black;font-size:20px;line-height:1;overflow:scroll">内容</div>
<script>
//chrome/IE8+/safari:40(20*1+20)
//firefox:40(40>34)
//IE7-:40(40>19)
console.log(test.clientHeight);
</script>
```

**clientLeft**

`clientLeft` 属性返回左边框的宽度

**clientTop**

`clientTop` 属性返回上边框的宽度

```html
<div id="test" style="width: 100px;height: 100px;padding: 10px;margin: 10px;border: 1px solid black;"></div>
<script>
//1 1
console.log(test.clientLeft);
console.log(test.clientTop);
</script>
```

[注意]如果 `display` 为 `inline` 时，`clientLeft`属性和`clientTop`属性都返回0

```html
<div id="test" style="display:inline;width: 100px;height: 100px;padding: 10px;margin: 10px;border: 1px solid black;"></div>
<script>
//0 0
console.log(test.clientLeft);
console.log(test.clientTop);
</script>
```

 

### 页面大小

常用 `document.documentElement` 的 `client` 属性来表示页面大小(不包含滚动条宽度)

[注意]在IE7-浏览器中，`<html>`元素默认存在垂直滚动条

```html
<body style="overflow:scroll">
<script>
//1903(1920-17)
console.log(document.documentElement.clientWidth);
//930(947-17)
console.log(document.documentElement.clientHeight);
</script>
```

另一对常用的表示页面大小的属性是 `window.innerHeight` 和`innerWidth`属性(包含滚动条宽度)

`innerHeight`和`innerWidth`表示的是浏览器窗口大小减去菜单栏、地址栏等剩余的页面尺寸，由于滚动条是属于页面的，所以包含滚动条

[注意]IE8-浏览器不支持innerHeight和innerWidth属性

```html
<body style="overflow:scroll">
<script>
//1920
console.log(window.innerWidth);
//947
console.log(window.innerHeight);
</script>
```

如果没有滚动条，这两类属性在电脑端表示同样的值，但是却表示不同的含义。在移动端，`innerWidth`和`innerHeight`表示的是视觉视口，即用户正在看到的网站的区域；而`document.documentElement.clientWidth`和`clientHeight`表示的是布局视口，指`CSS`布局的尺寸。

### 注意事项

【1】所有客户区 `client` 属性都是只读的

```html
<div id="test" style="width: 100px;height: 100px;padding: 10px;margin: 10px;border: 1px solid black;"></div>
<script>
console.log(test.clientHeight);
//IE8-浏览器会报错，其他浏览器则静默失败
test.clientHeight = 10;
console.log(test.clientHeight);
</script>
```

【2】如果给元素设置了 `display:none`，则客户区`client`属性都为0

```html
<div id="test" style="width: 100px;height: 100px;padding: 10px;margin: 10px;border: 1px solid black;display:none;"></div>
<script>
console.log(test.clientHeight);//0
console.log(test.clientTop);//0
</script>
```

【3】每次访问客户区 `client` 属性都需要重新计算，重复访问需要耗费大量的性能，所以要尽量避免重复访问这些属性。如果需要重复访问，则把它们的值保存在变量中，以提高性能

```html
<div id="test" style="width: 100px;height: 100px;padding: 10px;margin: 10px;border: 1px solid black;"></div>      
<script>
console.time("time");
for(var i = 0; i < 100000; i++){
    var a = test.clientHeight;
}
console.timeEnd('time');//66.798ms
</script>
<div id="test" style="width: 100px;height: 100px;padding: 10px;margin: 10px;border: 1px solid black;"></div>         
<script>
console.time("time");
var a = test.clientHeight;
for(var i = 0; i < 100000; i++){
    var b = a;
}
console.timeEnd('time');//1.705ms
</script>
```

## 滚动 Scroll

### 滚动宽高

**scrollHeight**

`scrollHeight` 表示元素的总高度，包括由于溢出而无法展示在网页的不可见部分

**scrollWidth**

`scrollWidth` 表示元素的总宽度，包括由于溢出而无法展示在网页的不可见部分


【1】没有滚动条时，`scrollHeight`与`clientHeight`属性结果相等，`scrollWidth`与`clientWidth`属性结果相等

```html
<div id="test" style="width: 100px;height: 100px;padding: 10px;margin: 10px;border: 1px solid black;"></div>
<script>
//120 120
console.log(test.scrollHeight,test.scrollWidth);
//120 120
console.log(test.clientHeight,test.clientWidth);
</script>
```

【2】存在滚动条时，但元素设置宽高大于等于元素内容宽高时，`scroll`和`client`属性的结果相等

```html
<div id="test" style="width: 100px;height: 100px;padding: 10px;margin: 10px;border: 1px solid black;overflow:scroll;font-size:20px;line-height:1;">
    内容<br>内容<br>
</div>
<script>
//103(120-17) 103(120-17)
console.log(test.scrollHeight,test.scrollWidth);
//103(120-17) 103(120-17)
console.log(test.clientHeight,test.clientWidth);
</script>
```

【3】存在滚动条，但元素设置宽高小于元素内容宽高，即存在内容溢出的情况时，`scroll`属性大于`client`属性

::: tip
scrollHeight属性存在兼容性问题，chrome和safari浏览器中，scrollHeight包含padding-bottom；而IE和firefox不包含padding-bottom
:::

```html
<div id="test" style="width: 100px;height: 100px;padding: 10px;margin: 10px;border: 1px solid black;overflow:scroll;font-size:20px;line-height:200px;">
    内容</div>
<script>
//chrome/safari:220(200+10+10)
//firefox/IE:210(200+10)
console.log(test.scrollHeight);
//103(120-17)
console.log(test.clientHeight);
</script>
```
### 页面尺寸

`document.documentElement.clientHeight`表示页面的可视区域的尺寸，而`document.documentElement.scrollHeight`表示`html`元素内容的实际尺寸。但是由于各个浏览器表现不一样，分为以下几种情况

【1】`html`元素没有滚动条时，IE和firefox的`client`和`scroll`属性始终相同，且返回可视区的尺寸大小；而safari和chrome表现正常，`clientHeight`返回可视区域大小，而`scrollHeight`返回元素内容大小

```js
//firefox:  755 755
//chrome:   947 8(body元素的margin)
//safari:   744 8(body元素的margin)
//IE:       768 768
console.log(document.documentElement.clientHeight,document.documentElement.scrollHeight)
```

【2】`html` 元素存在滚动条时，各个浏览器都表现正常。`clientHeight`返回可视区域大小，而`scrollHeight`返回元素内容大小

```html
<body style="height:1000px">
<script>
//firefox:  755 1016(1000+8*2)
//chrome:   947 1016(1000+8*2)
//safari:   744 1016(1000+8*2)
//IE:       768 1016(1000+8*2)
console.log(document.documentElement.clientHeight,document.documentElement.scrollHeight)
</script>
```

**兼容**

因此要取得文档实际高度时，要取得`<html>`元素的`scrollHeight`和`clientHeight`的最大值

```js
var docHeight = Math.max(document.documentElement.scrollHeight,document.documentElement.clientHeight);
var docWidth  = Math.max(document.documentElement.scrollWidth,document.documentElement.clientWidth);
```

### 滚动长度

**scrollTop**

`scrollTop` 属性表示被隐藏在内容区域上方的像素数。元素未滚动时，`scrollTop`的值为0，如果元素被垂直滚动了，scrollTop的值大于0，且表示元素上方不可见内容的像素宽度

**scrollLeft**

`scrollLeft` 属性表示被隐藏在内容区域左侧的像素数。元素未滚动时，`scrollLeft`的值为0，如果元素被水平滚动了，`scrollLeft`的值大于0，且表示元素左侧不可见内容的像素宽度

当滚动条滚动到内容底部时，符合以下等式

```html
<!-- scrollHeight == scrollTop  + clientHeight -->
<div id="test" style="width: 100px;height: 100px;padding: 10px;margin: 10px;border: 1px solid black;overflow:scroll;font-size:20px;line-height:200px;">
    内容</div>
<button id='btn1'>点击</button>
<div id="result"></div>
<script>
btn1.onclick = function(){
    result.innerHTML = 'scrollTop:' + test.scrollTop+';clientHeight:' + test.clientHeight + ';scrollHeight:' + test.scrollHeight
}
</script>
```

与 `scrollHeight` 和 `scrollWidth` 属性不同的是，`scrollLeft`和`scrollTop`是可写的


```html
<div id="test" style="width: 100px;height: 100px;padding: 10px;margin: 10px;border: 1px solid black;overflow:scroll;font-size:20px;line-height:200px;">
    内容</div>
<button id='btn1'>向下滚动</button>
<button id='btn2'>向上滚动</button>
<script>
btn1.onclick = function(){test.scrollTop += 10;}
btn2.onclick = function(){test.scrollTop -= 10;}
</script>
```


### 页面滚动

理论上，通过 `document.documentElement.scrollTop` 和 `scrollLeft` 可以反映和控制页面的滚动；但是chrome和safari浏览器是通过` document.body.scrollTop` 和 `scrollLeft` 来控制的

```html
<body style="height:1000px">
<button id='btn1' style="position:fixed;top:0;">点击</button>
<div id="result" style="position:fixed;top:30px;"></div>
<script>
btn1.onclick = function(){
    result.innerHTML = 'html的scrollTop:' + document.documentElement.scrollTop +';body的scrollTop:' + document.body.scrollTop;
}
</script>    
</body>
```

所以，页面的滚动高度兼容写法是

```js
var docScrollTop = document.documentElement.scrollTop || document.body.scrollTop
```

**回到顶部**

可以利用 `scrollTop` 来实现回到顶部的功能

```js
function scrollTop(){
    if((document.body.scrollTop || document.documentElement.scrollTop) != 0){
        document.body.scrollTop = document.documentElement.scrollTop = 0;
    }
}
<body style="height:1000px">
<button id='btn' style="position:fixed">回到顶部</button>
<script>
function scrollTop(){
    if((document.body.scrollTop || document.documentElement.scrollTop) != 0){
        document.body.scrollTop = document.documentElement.scrollTop = 0;
    }
}
btn.onclick = scrollTop;
</script>
</body>
```


还有两个 `window` 的只读属性可以获取整个页面滚动的像素值，它们是 `pageXOffset` 和 `pageYOffset`

**pageXOffset**

`pageXOffset` 表示水平方向上页面滚动的像素值

**pageYOffset**

`pageYOffset` 表示垂直方向上页面滚动的像素值

　　[注意]IE8-浏览器不支持

```html
<body style="height:1000px">
<button id='btn1' style="position:fixed;top:0;">点击</button>
<div id="result" style="position:fixed;top:30px;"></div>
<script>
btn1.onclick = function(){
    result.innerHTML = 'pageYOffset:' + window.pageYOffset;
}
</script>    
</body>
```




### 滚动方法

**scrollTo(x,y)**

`scrollTo(x,y)` 方法滚动当前 `window` 中显示的文档，让文档中由坐标 `x` 和 `y` 指定的点位于显示区域的左上角

```html
<body style="height:1000px">
<button id='btn' style="position:fixed">滚动</button>
<script>
btn.onclick = function(){scrollTo(0,0);}
</script>
```

**scrollBy(x,y)**

`scrollBy(x,y)`方法滚动当前`window`中显示的文档，`x` 和 `y` 指定滚动的相对量

```html
<body style="height:1000px">
<button id='btn1' style="position:fixed">向下滚动</button>
<button id='btn2' style="position:fixed;top:40px">向上滚动</button>
<script>
btn1.onclick = function(){scrollBy(0,100);}
btn2.onclick = function(){scrollBy(0,-100);}
</script>
```

【小应用】

利用 `scrollBy()` 加 `setInterval` 计时器实现简单的快速滚动功能

```html
<body style="height:1000px">
<button id='btn1' style="position:fixed">开始滚动</button>
<button id='btn2' style="position:fixed;top:40px">停止滚动</button>
<script>
var timer = 0;
btn1.onclick = function(){
    timer = setInterval(function(){
        scrollBy(0,10);
    },100)}
btn2.onclick = function(){
    clearInterval(timer);
    timer = 0;
}
</script>    
```


**scrollIntoView()**

`Element.scrollIntoView` 方法滚动当前元素，进入浏览器的可见区域

该方法可以接受一个布尔值作为参数。如果为 `true`，表示元素的顶部与当前区域的可见部分的顶部对齐（前提是当前区域可滚动）；如果为 `false`，表示元素的底部与当前区域的可见部分的尾部对齐（前提是当前区域可滚动）。如果没有提供该参数，默认为 `true`

```html
<body style="height:1000px">
<div id="test" style="height:100px;width:100px;position:absolute;left:0;top:500px;background-color:green"></div>
<button id='btn1' style="position:fixed">滚动到页面开头</button>
<button id='btn2' style="position:fixed;top:40px">滚动到页面结尾</button>
<script>
btn1.onclick = function(){
    test.scrollIntoView();
};
btn2.onclick = function(){
    test.scrollIntoView(false);
}
</script>
```

**scrollIntoViewIfNeeded()**

`scrollIntoViewIfNeeded(true)`方法只在当前元素在视口中不可见的情况下，才滚动浏览器窗口或容器元素，最终让它可见。如果当前元素在视口中可见，这个方法什么也不做 

如果将可选的`alignCenter`参数设置为`true`，则表示尽量将元素显示在视口中部(垂直方向)

　　[注意]该方法只有chrome和safari支持

```html
<body style="height:1000px">
<div id="test" style="height:100px;width:100px;position:absolute;left:0;top:500px;background-color:green"></div>
<button id='btn' style="position:fixed">滚动到页面中间</button>
<script>
btn.onclick = function(){
    test.scrollIntoViewIfNeeded(true)
};
</script>
```

**scrollByLines(lineCount)**

`scrollByLines(lineCount)` 方法将元素的内容滚动指定的行髙，`lineCount`值可以是正值， 也可以是负值

　　[注意]该方法只有safari支持

```html
<div id="test" style="width: 100px;height: 100px;padding: 10px;margin: 10px;border: 1px solid black;overflow:scroll;font-size:20px;line-height:200px;">
    内容</div>
<button id='btn1'>向下滚动</button>
<button id='btn2'>向上滚动</button>
<script>
btn1.onclick = function(){test.scrollByLines(1);}
btn2.onclick = function(){test.scrollByLines(-1);}
</script>
```

**scrollByPages(pageCount)**

`scrollByPages(pageCount)`方法将元素的内容滚动指定的页面高度，具体高度由元素的高度决定

[注意]该方法只有safari支持

```html
<div id="test" style="width: 100px;height: 100px;padding: 10px;margin: 10px;border: 1px solid black;overflow:scroll;font-size:20px;line-height:200px;">
    内容</div>
<button id='btn1'>向下滚动</button>
<button id='btn2'>向上滚动</button>
<script>
btn1.onclick = function(){test.scrollByPages(1);}
btn2.onclick = function(){test.scrollByPages(-1);}
</script>
```
### 滚动事件

`scroll` 事件是在 `window` 对象上发生的，它表示的是页面中相应元素的变化。当然，`scroll` 事件也可以用在有滚动条的元素上

```html
<body style="height:1000px">
<div id="result" style="position:fixed;top:10px;"></div>
<script>
window.onscroll = function(){
    result.innerHTML = '页面的scrollTop:' + (document.documentElement.scrollTop||document.body.scrollTop);
}
</script>    
</body>
```
## 回到顶部的实现方案
### 写法

【1】锚点

在页面顶部放置一个指定名称的锚点链接，在页面下方放置一个返回到该锚点的链接，用户点击该链接即可返回到该锚点所在的顶部位置

```html
<body style="height:2000px;">
    <div id="topAnchor"></div>
    <a href="#topAnchor" style="position:fixed;right:0;bottom:0">回到顶部</a>
</body>
```

【2】scrollTop

`scrollTop` 属性表示被隐藏在内容区域上方的像素数。元素未滚动时，`scrollTop` 的值为 `0`，如果元素被垂直滚动了，`scrollTop` 的值大于`0`，且表示元素上方不可见内容的像素宽度

由于 `scrollTop` 是可写的，可以利用 `scrollTop` 来实现回到顶部的功能

```html
<body style="height:2000px;">
    <button id="test" style="position:fixed;right:0;bottom:0">回到顶部</button>
    <script>
        test.onclick = function(){
            document.body.scrollTop = document.documentElement.scrollTop = 0;
        }
    </script>
</body>
```


【3】scrollTo()

`scrollTo(x,y)`方法滚动当前`window`中显示的文档，让文档中由坐标 `x` 和 `y` 指定的点位于显示区域的左上角

设置 `scrollTo(0,0)` 可以实现回到顶部的效果

```html
<body style="height:2000px;">
    <button id="test" style="position:fixed;right:0;bottom:0">回到顶部</button>
    <script>
        test.onclick = function(){
            scrollTo(0,0);
        }
    </script>
</body>
```

【4】scrollBy()

`scrollBy(x,y)`方法滚动当前 `window` 中显示的文档，`x` 和 `y` 指定滚动的相对量

只要把当前页面的滚动长度作为参数，逆向滚动，则可以实现回到顶部的效果

```html
<body style="height:2000px;">
    <button id="test" style="position:fixed;right:0;bottom:0">回到顶部</button>
    <script>
        test.onclick = function(){
            var top = document.body.scrollTop || document.documentElement.scrollTop
            scrollBy(0,-top);
        }
    </script>
</body>
```

【5】scrollIntoView()

`Element.scrollIntoView` 方法滚动当前元素，进入浏览器的可见区域　

该方法可以接受一个布尔值作为参数。如果为 `true`，表示元素的顶部与当前区域的可见部分的顶部对齐（前提是当前区域可滚动）；如果为 `false`，表示元素的底部与当前区域的可见部分的尾部对齐（前提是当前区域可滚动）。如果没有提供该参数，默认为`true`

使用该方法的原理与使用锚点的原理类似，在页面最上方设置目标元素，当页面滚动时，目标元素被滚动到页面区域以外，点击回到顶部按钮，使目标元素重新回到原来位置，则达到预期效果

```html
<body style="height:2000px;">
    <div id="target"></div>
    <button id="test" style="position:fixed;right:0;bottom:0">回到顶部</button>
    <script>
        test.onclick = function(){
            target.scrollIntoView();
        }
    </script>
</body>
```

### 增强

下面对回到顶部的功能进行增强

【1】显示增强

使用`CSS`画图，将“回到顶部”变成可视化的图形(如果兼容IE8-浏览器，则用图片代替)

使用`CSS`伪元素及伪类 `hover` 效果，当鼠标移动到该元素上时，显示回到顶部的文字，移出时不显示　　

::: demo
```html
<style>
.box{
    /* position:fixed; */
    right:10px;
    bottom: 10px;
    height:30px;
    width: 50px;    
    text-align:center;
    padding-top:20px;    
    background-color: lightblue;
    border-radius: 20%;
    overflow: hidden;
}
.box:hover:before{
    top:50%
}
.box:hover .box-in{
    visibility: hidden;
}
.box:before{
    position: absolute;
    top: -50%;
    left: 50%;
    transform: translate(-50%,-50%);
    content:'回到顶部';
    width: 40px;
    color:peru;
    font-weight:bold;
}    
.box-in{
    visibility: visible;
    display:inline-block;
    height:20px;
    width: 20px;
    border: 3px solid black;
    border-color: white transparent transparent white;
    transform:rotate(45deg);
}
</style>
<template>
<div id="box" class="box">
    <div class="box-in"></div>
</div>   
</template>


```
:::

【2】动画增强

为回到顶部增加动画效果，滚动条以一定的速度回滚到顶部

动画有两种：一种是 `CSS` 动画，需要有样式变化配合`transition`；一种是 `javascript`动画，使用定时器]来实现　　

在上面的5种实现中，`scrollTop`、`scrollTo()`和`scrollBy()`方法可以增加动画，且由于无样式变化，只能增加 `javascript` 动画

定时器又有 `setInterval`、`setTimeout`和`requestAnimationFrame`这三种可以使用，下面使用性能最好的定时器 `requestAnimationFrame`来实现

[注意]IE9-浏览器不支持该方法，可以使用 `setTimeout` 来兼容

1、增加 `scrollTop`的动画效果

使用定时器，将 `scrollTop` 的值每次减少50，直到减少到0，则动画完毕

```html
<script>
var timer  = null;
box.onclick = function(){
    cancelAnimationFrame(timer);
    timer = requestAnimationFrame(function fn(){
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if(oTop > 0){
            document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
            timer = requestAnimationFrame(fn);
        }else{
            cancelAnimationFrame(timer);
        }    
    });
}
</script>
```

【时间版运动】

但是，上面的代码有一个问题，就是当页面内容较多时，回到顶部的动画效果将持续很长时间。因此，使用时间版的运动更为合适，假设回到顶部的动画效果共运动500ms，则代码如下所示

```html
<body style="height: 2000px;">
<button id="test" style="position:fixed;right:10px;bottom:10px;">回到顶部</button>
<script>
var timer  = null;
test.onclick = function(){
    cancelAnimationFrame(timer);
    //获取当前毫秒数
    var startTime = +new Date();     
    //获取当前页面的滚动高度
    var b = document.body.scrollTop || document.documentElement.scrollTop;
    var d = 500;
    var c = b;
    timer = requestAnimationFrame(function func(){
        var t = d - Math.max(0,startTime - (+new Date()) + d);
        document.documentElement.scrollTop = document.body.scrollTop = t * (-c) / d + b;
        timer = requestAnimationFrame(func);
        if(t == d){
          cancelAnimationFrame(timer);
        }
    });
}
</script>
</body>
```

2、增加scrollTo()动画效果

将 `scrollTo(x,y)` 中的 `y` 参数通过 `scrollTop`值获取，每次减少50，直到减少到0，则动画完毕

```html
<script>
var timer  = null;
box.onclick = function(){
    cancelAnimationFrame(timer);
    timer = requestAnimationFrame(function fn(){
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if(oTop > 0){
            scrollTo(0,oTop-50);
            timer = requestAnimationFrame(fn);
        }else{
            cancelAnimationFrame(timer);
        }    
    });
}
</script>
```

3、增加scrollBy()动画效果

将 `scrollBy(x,y)` 中的 `y` 参数设置为-50，直到`scrollTop`为0，则回滚停止

```html
<script>
var timer  = null;
box.onclick = function(){
    cancelAnimationFrame(timer);
    timer = requestAnimationFrame(function fn(){
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if(oTop > 0){
            scrollBy(0,-50);
            timer = requestAnimationFrame(fn);
        }else{
            cancelAnimationFrame(timer);
        }    
    });
}
</script>
```
### 实现

由于 `scrollTop`、`scrollBy()`和`scrollTo()`方法，都以`scrollTop`值是否减少为0作为动画停止的参照，且三个动画的原理和实现都基本相似，性能也相似。最终，以最常用的`scrollTop`属性实现动画增强效果

当然，如果觉得500ms的时间不合适，可以根据实际情况进行调整

```html
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Document</title>
<style>
.box{
    position:fixed;
    right:10px;
    bottom: 10px;
    height:30px;
    width: 50px;    
    text-align:center;
    padding-top:20px;    
    background-color: lightblue;
    border-radius: 20%;
    overflow: hidden;
}
.box:hover:before{
    top:50%
}
.box:hover .box-in{
    visibility: hidden;
}
.box:before{
    position: absolute;
    top: -50%;
    left: 50%;
    transform: translate(-50%,-50%);
    content:'回到顶部';
    width: 40px;
    color:peru;
    font-weight:bold;

}    
.box-in{
    visibility: visible;
    display:inline-block;
    height:20px;
    width: 20px;
    border: 3px solid black;
    border-color: white transparent transparent white;
    transform:rotate(45deg);
}
</style>
</head>
<body style="height:2000px;">
<div id="box" class="box">
    <div class="box-in"></div>
</div>    
<script>
var timer  = null;
box.onclick = function(){
    cancelAnimationFrame(timer);
    //获取当前毫秒数
    var startTime = +new Date();     
    //获取当前页面的滚动高度
    var b = document.body.scrollTop || document.documentElement.scrollTop;
    var d = 500;
    var c = b;
    timer = requestAnimationFrame(function func(){
        var t = d - Math.max(0,startTime - (+new Date()) + d);
        document.documentElement.scrollTop = document.body.scrollTop = t * (-c) / d + b;
        timer = requestAnimationFrame(func);
        if(t == d){
          cancelAnimationFrame(timer);
        }
    });
}
</script>
</body>
</html>
```



## 元素视图的3个方法

### getBoundingClientRect()

判断一个元素的尺寸和位置最简单的方法就是使用`getBoundingClientRect()`

`Element.getBoundingClientRect()`方法返回一个对象，该对象提供当前元素节点的大小、它相对于视口(viewport)的位置等信息。但是，各个浏览器返回的对象包含的属性不相同

```
firefox: top left right bottom width height x y(其中，x=left，y=top)
chrome/safari/IE9+:top left right bottom width height
IE8-:  top left right bottom
```

问题来了，该方法返回的 `width` 和 `height` 是客户区宽高 `client`，还是滚动宽高 `scroll`，或者是偏移宽高 `offset`，或者是设置宽高呢

```html
<div id="test" style="width: 100px;height: 100px;padding: 10px;line-height: 200px;border:1px solid black;overflow:scroll">内容</div>    
<script>
//chrome/safari: 220(10+200+10)
//firefox/IE: 210(10+200)
console.log(test.scrollHeight)
//103(100+10+10-17)
console.log(test.clientHeight)
//122(100+10+10+1+1)
console.log(test.offsetHeight)
//122(100+10+10+1+1)
console.log(test.getBoundingClientRect().height)
</script>
```

由代码结果看出，该方法返回的宽高是偏移宽高 `offset`

```js
Element.getBoundingClientRect().width =  border-left-width + padding-left + width + padding-right + border-right-width

Element.getBoundingClientRect().height =  border-top-width + padding-top + height + padding-bottom + border-bottom-width
```

下面来分析 `top`、`left`、`right`、`bottom`这四个值

- top:  元素顶部相对于视口的纵坐标

- left:  元素左边界相对视口的横坐标

- right: 元素右边界相对视口的横坐标

- bottom:元素底部相对于视口的纵坐标

```js
bottom = top + height
right = left + width
```

[注意]该方法的所有属性值都没有单位，且给定的是元素在页面中相对于视口的位置

问题又来了，相对于视口和相对于页面有什么区别。理论上，与 `absolute` 和 `fixed` 的区别类似，但表现上与它们正相反。发生滚动时，`fixed`元素保持不动是为了保持与视口的原始距离；而发生滚动时，`getBoundingClientRect()`方法的`top`、`left`、`right`、`bottom`这四个值相应的发生改变，是因为元素位置移动了，与视口距离自然也改变了

**bug**

IE7-浏览器把视口的左上角坐标设置为(2,2)，其他浏览器则将(0,0)作为起点坐标

```html
<body style="margin:0">
<div id="test" style="width: 100px;height: 50px;padding: 10px;line-height: 200px;overflow:scroll;border:1px solid black">内容</div>    
<script>
//chrome/firefox/safari/IE8+ 0 72(50+10+10+1+1)
//IE7- 2 74(72+2)
console.log(test.getBoundingClientRect().top,test.getBoundingClientRect().bottom)

//chrome/firefox/safari/IE8+ 0 122(100+10+10+1+1)
//IE71 2 124(122+2)
console.log(test.getBoundingClientRect().left,test.getBoundingClientRect().right)
</script>
</body>
```

**兼容**

可以利用IE7-浏览器中特性节点的 `specified` 属性实现浏览器识别

```js
function getBoundingClientRect(obj){
    var temp = obj.getBoundingClientRect();
    //IE7-浏览器
    if(Boolean(obj.attributes[0]) && !obj.attributes[0].specified){
        return{
            left: temp.left -2,
            top: temp.top -2,
            right: temp.right -2,
            bottom: temp.bottom -2
        }
    }else{
        return temp;
    }    
}
```

 

### getClientRects()

`getClientRects()` 方法与 `getBoundingClientRect()` 不同，该方法是一个返回元素的数个矩形区域的类数组对象。每个类数组对象的参数与 `getBoundingClientRect()` 方法相同，每个矩形都有 `bottom`、`height`、`left`、`right`、`top`和`width`六个属性，表示它们相对于视口的四个坐标，以及本身的高度和宽度

如果应用于块级元素，则`getClientRects()[0]`和`getBoundingClientRect()`的属性返回相同的值，且IE7-浏览器在`getClientRects()`方法中，同样存在视口左上角坐标被设置为(2,2)的bug

```html
<body style="margin:0">
<div id="test" style="width: 100px;height: 50px;padding: 10px;line-height: 200px;overflow:scroll;border:1px solid black">内容</div>    
<script>
//其他浏览器返回0 0， IE7-浏览器返回 2 2 
console.log(test.getClientRects()[0].top,test.getBoundingClientRect().top)
//其他浏览器返回0 0， IE7-浏览器返回 2 2 
console.log(test.getClientRects()[0].left,test.getBoundingClientRect().left)
//72(50+10+10+1+1) 72
console.log(test.getClientRects()[0].height,test.getBoundingClientRect().height)
</script>
```

 实际上，该方法主要用于内联元素，内联元素有多少行，该方法返回的对象有多少个成员。这个方法主要用于判断行内元素是否换行，以及行内元素的每一行的位置偏移

```html
<body style="margin:0">
<div style="width:100px;"><span id="el">
Hello World
Hello World
Hello World
</span></div>
<script>
console.log(el.getClientRects().length); // 3
console.log(el.getClientRects()[0].left); // 0
console.log(el.getClientRects()[0].right); // 88
console.log(el.getClientRects()[0].bottom); // 17
console.log(el.getClientRects()[0].height); // 16
console.log(el.getClientRects()[0].width); // 88
</script>
</body>
```
### elementFromPoint()

`getBoundingClientRect(x,y)` 方法使我们能在视口中判定元素的位置。但有时我们想反过来，判定在视口中的指定位置上有什么元素。这可以用 `Document` 对象的`elementFromPoint()`方法来判定。传递 `X` 和 `Y` 坐标(相对于视口)，该方法选择在指定坐标的最上层和最里层的 `Element` 对象。如果指定的点在视口以外，`elementFromPoint()` 返回 `null`

[注意]最上层是指`z-index`最大的元素；最里层是指最里层的子元素

这个方法可以用来检测元素是否发生重叠或是碰撞

```html
<body style="margin:0">
<div id="test" style="width: 100px;height: 100px;">
    <span id="span1">123</span>
</div>
<script>
```