---
title: 对象
date: 2021-01-13 15:03:03
permalink: /pages/yyjeewasweew
author: 
  name: jeffery
categories: 
  - javascript
  - 数据类型
tags: 
  - javascript
  - 数据类型
---

# 对象

## 对象的属性和访问方式


对象的属性可以分为数据属性和访问器属性

**数据属性**

- configurable：属性能否删除而重新定义
- enumerable：属性是否可枚举，能够通过for...in循环
- writable：属性值能否被修改
- value：属性的真实值



**访问器属性**

- configurable：属性能否删除而重新定义
- enumerable：属性是否可枚举，能够通过for...in循环
- get: 在读取属性值时调用的函数
- set：在写入属性值时调用的函数



对象属性的访问方式有两种，一种是使用点操作符（.），另一种是使用中括号操作符（[]）。
```javascript
objectName.properName

ObjectName[perpertyName]
```
## 创建对象方式


- 基于Object()构造函数
```javascript
var person = new Object()
person.name = 'zhangsan'
```

- 基于对象字面量
```javascript
var person = {}
person.name = 'zhangsan'
```

- 基于工厂方法模式
```javascript
function createPerson(name) {
  let obj = new Object()
  obj.name = name
  return obj
}
```

- 基于构造函数模式
```javascript
function Person (name) {
  this.name = name
  this.getName = function () {
    return this.name
  }
}
```

- 基于原型对象的模式
```javascript
function Person () {}
Person.prototype.name = 'zhangsan'
Person.prototype.getName = function () {
  return this.name
}
```

- 构造函数和原型混合的模式
```javascript
function Person (name) {
  this.name = name
}
Person.prototype.getName = () {
  return this.name
}
```

- 基于动态原型模式
```javascript
function Person(name) {
  this.name = name
  if (typeof Person._initialized === 'undefined') {
    Person.prototype.getName = function () {
      return this.name
    }
  }
  Person._initialized = true
}
    
```



## Object 静态方法

### 对象属性模型的相关方法

- `Object.getOwnPropertyDescriptor()`：获取某个属性的描述对象。
- `Object.defineProperty()`：通过描述对象，定义某个属性。
- `Object.defineProperties()`：通过描述对象，定义多个属性
- `Object.getOwnPropertyNames(obj)`
- `Object.getOwnPropertySymbols(obj)`
- `Object.keys()`
- `Object.values()`
- `Object.entries()`

### 控制对象状态的方法

- `Object.preventExtensions()`：防止对象扩展。
- `Object.isExtensible()`：判断对象是否可扩展。
- `Object.seal()`：禁止对象配置，对象无法添加新属性，也无法删除旧属性。
- `Object.isSealed()`：判断一个对象是否可配置。
- `Object.freeze()`：冻结一个对象，对象无法添加新属性，无法删除旧属性，也无法改变属性的值。
- `Object.isFrozen()`：判断一个对象是否被冻结

### 原型链相关方法

- `Object.create()`
- `Object.setPrototypeOf()`
- `Object.getPrototypeOf()`

### Object 的实例方法

- `Object.prototype.valueOf()`：返回当前对象对应的值。
- `Object.prototype.toString()`：返回当前对象对应的字符串形式。
- `Object.prototype.toLocaleString()`：返回当前对象对应的本地字符串形式。
- `Object.prototype.hasOwnProperty()`：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。
- `Object.prototype.isPrototypeOf()`：判断当前对象是否为另一个对象的原型。
- `Object.prototype.propertyIsEnumerable()`：判断某个属性是否可枚举。

### 对象其他方法

- `Object.assign()`
- `Object.is()`：比较两个值是否相等
- `Object.fromEntries()`：是`Object.entries()`的逆操作，用于将一个键值对数组转为对象。



### Object.fromEntries() 用法

```javascript
Object.fromEntries([
  ['foo', 'bar'],
  ['baz', 42]
])
// { foo: "bar", baz: 42 }
```

将键值对的数据结构还原为对象，因此特别适合将 Map 结构转为对象。

```javascript
// 例一
const entries = new Map([
  ['foo', 'bar'],
  ['baz', 42]
]);

Object.fromEntries(entries)
// { foo: "bar", baz: 42 }

// 例二
const map = new Map().set('foo', true).set('bar', false);
Object.fromEntries(map)
// { foo: true, bar: false }
```

配合URLSearchParams对象，将查询字符串转为对象

```javascript
Object.fromEntries(new URLSearchParams('foo=bar&baz=qux'))
// { foo: "bar", baz: "qux" }
```


## new 操作符的原理


new 原理

- 创建一个空对象
- 将空对象的 __proto__ 原型属性指向构造函数的原型对象 `prototype`
- 将函数的 `this` 指向空对象
- 调用函数，如果函数执行结果返回对象，则将对象返回，否则返回 `this`



```javascript
function Cat(name, age) {
  this.name = name
  this.age = age
}

function New() {
  var obj = {}
  obu.__proto__ = Cat.prototype
  var res = Cat.apply(obj, arguments)
  return typeof res ==== 'object' ? res : obj
  
}
```

## Object.create()函数


创建并返回一个指定原型和指定属性的对象
​

```javascript
Object.creat(prototype, propertyDescriptor)

let obj = Object.creat(null, {
  name: {
    value: 'input',
    writable: true,
    enumerable: true,
    configurable: true
  }
})

// 手动实现 create
Object.create = function (proto, properiesObject) {
  // 省去中间很多判断
  function F() {}
  F.prototype = proto
  
  return new F()
}
  
```

在 `create()` 函数中，首先声明一个函数为 `F()` 函数，然后将 `F()` 函数的`prototype` 属性指向传入的 `proto` 参数，通过 `new` 操作符生成 `F()` 函数的实例
​

## 原型对象


每一个函数在创建时都会被赋予一个 `prototype` 属性，它指向函数的原型对象，这个对象可以包含所有实例共享的属性和函数
​

### 原型对象、构造函数和实例之间的关系


```javascript
function Person () {}
Person.prototype.name = 'Nicholas'
Person.prototype.age = 29
Person.prototype.job = 'Software Engineer'
Person.prototype.sayName = function () {
  console.log(this.name)
}

var person1 = new Person()
var person2 = new Person()
```


造函数`Person`为例看看构造函数、原型对象和实例之间的关系，如图
​

![image (3)](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/image%20(3).png)

构造函数 `Person` 有个`prototype`属性，指向的是`Person`的原型对象。在原型对象中有`constructor`属性和另外4个原型对象上的属性，其中constructor属性指向构造函数本身。
​

通过new操作符创建的两个实例`person1`和`person2`，都具有一个`__proto__`属性（`[[Prototype]]`即`__proto__`属性），指向的是`Person`的原型对象
​

### 原型链

对象的每个实例都具有一个`__proto__`属性，指向的是构造函数的原型对象，而原型对象同样存在一个`__proto__`属性指向上一级构造函数的原型对象，就这样层层往上，直到最上层某个原型对象为`null`
​

原型链关系图

![image (4)](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/image%20(4).png)


## 继承

继承作为面向对象语言的三大特性之一，可以在不影响父类对象实现的情况下，使得子类对象具有父类对象的特性；同时还能在不影响父类对象行为的情况下扩展子类对象独有的特性
​

要实现继承，要有父类，定义了一个父类Animal并增加属性、实例函数和原型函数，
​

```javascript
function Animal(name) {
    this.name = name || '动物'
    this.type = 'Animal'
    // 实例函数
    this.sleep = function () {
        console.log(this.name + '正在睡觉')
    }
}

// 原型函数
Animal.prototype.eat = function (food){
    console.log(this.name + '正在吃' + food)
}
```


### 原型链继承
原型链继承的主要思想是：重写子类的prototype属性，将其指向父类的实例。
​

```javascript
function Cat(name) {
    this.name = name
}

// 原型继承
Cat.prototype = new Animal()
Cat.prototype.constructor = Cat


let cat = new Cat('加菲猫')

console.log(cat.type)
console.log(cat.name)
cat.sleep()
cat.eat('猫粮')
```
**原型链继承的优点**

- 简单，易于实现。只需要设置子类的 `prototype` 属性为父类的实例即可，实现起来简单
- 继承关系纯粹。生成的实例既是子类的实例，也是父类的实例
- 可通过子类直接访问父类原型链属性和函数。



**原型链继承的缺点**

- 子类的所有实例将共享父类的属性。如果父类 `Animal` 中的值是引用数据类型，会影响其他子类实例的属性值。
- 在创建子类实例时，无法向父类的构造函数传递参数。
- 无法实现多继承
- 为子类增加原型对象上的属性和函数时，必须放在 `new Animal()` 函数之后



### 构造函数继承

构造继承的主要思想是在子类的构造函数中通过 `call()` 函数改变 `this` 的指向，调用父类的构造函数，从而能将父类的实例的属性和函数绑定到子类的 `this` 上
​

```javascript
// 构造函数继承
function Cat(name) {
    Animal.call(this)
    this.name = name || 'Tom'
}

let cat = new Cat('加菲猫')

console.log(cat.type)
console.log(cat.name)
cat.sleep()
cat.eat('猫粮')  //  Uncaught TypeError: cat.eat is not a function
```
子类可以正常调用父类的实例函数，而无法调用父类原型对象上的函数，这是因为子类并没有通过某种方式来调用父类原型对象上的函数
​

**构造继承的优点**

- 可解决子类实例共享父类属性的问题
- 创建子类的实例时，可以向父类传递参数
- 可以实现多继承



**构造继承的缺点**

- 实例只是子类的实例，并不是父类的实例
- 只能继承父类实例的属性和函数，并不能继承原型对象上的属性和函数
- 无法复用父类的实例函数。子类生成的每个实例都会拥有父类实例函数的引用，这会造成不必要的内存消耗，影响性能。



### 复制继承

复制继承的主要思想是首先生成父类的实例，然后通过 `for...in` 遍历父类实例的属性和函数，并将其依次设置为子类实例的属性和函数或者原型对象上的属性和函数
​

```javascript
// 复制继承
function Cat(name, age) {
    var animal = new Animal(age)
    for (let key in animal) {
        // 实例属性和函数
        if (animal.hasOwnProperty(key)) {
            this[key] = animal[key]
        } else {
        // 原型对象上的属性和函数
        Cat.prototype[key] = animal[key]
        }
    }
    // 子类自身的属性
    this.name = name
}
```
**复制继承的优点**

- 支持多继承。每次实例化子类执行函数，父类也会实例化不会出现属性影响
- 能同时继承实例的属性和函数与原型对象上的属性和函数
- 可以向父类构造函数中传递值



**复制继承的缺点**

- 父类的所有属性都需要复制，消耗内存
- 实例只是子类的实例，并不是父类的实例



### 组合继承
组合继承的主要思想是组合了构造继承和原型继承两种方法

- 第一步：在子类的构造函数中通过 `call()` 函数调用父类的构造函数，将父类的实例的属性和函数绑定到子类的 `this` 中
- 第二步：通过改变子类的 `prototype` 属性，继承父类的原型对象上的属性和函数。



```javascript
function Cat(name, age) {
    Animal.call(this)
    this.name = name
}

Cat.prototype = new Animal()
Cat.prototype.constructor = Cat
```
**组合继承的优点**

- 既能继承父类实例的属性和函数，又能继承原型对象上的属性和函数
- 既是子类的实例，又是父类的实例
```javascript
cat instanceof Cat // true
cat instanceof Animal // true
```

- 不存在引用属性共享的问题
- 可以向父类的构造函数中传递参数



**组合继承的缺点**

- 父类的构造函数会执行两次。一次 `call()` 函数调；另一次父类的实例时调用



### 寄生组合继承


在组合继承的基础上进行优化两次执行父类构造函数
​

```javascript
// 寄生组合继承

function create(parent, child) {
    let foo = function() {}
    foo.prototype = parent.prototype
    child.prototype = new foo()
    child.prototype.constructor = child
}

function Cat(name, age) {
    Animal.call(this)
}

create(Animal, Cat)
```
```javascript
foo.prototype = parent.prototype
```
只取父类 `Animal` 的 `prototype` 属性，过滤掉 `Animal` 的实例属性，从而避免了父类的实例属性绑定两次。
​

