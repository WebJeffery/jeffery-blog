---
title: 数据类型基础
date: 2020-12-29 10:27:01
permalink: /pages/aac3errwdasweew
author: 
  name: jeffery
categories: 
  - javascript
  - 数据类型
tags: 
  - javascript
  - 数据类型
---

# 数据类型基础

## 数据类型概念

`javascript` 拥有强大的类型系统，主要包括原生对象（ECMAScript规范的数据类型）、宿主对象和浏览器拓展对象

![](http://assets.processon.com/chart_image/6115f0a00e3e7407d39ddc05.png)


原生对象分为两类：原始类型(primitive type)和对象类型(object type)。

**原始类型分为两类**

- **空值**，`undefined` 和 `null`。逻辑上，`undefined` 表示原始类型的空值，`null`表示对象类型的空值
- **包装对象**；`String` 、`Number` 、`Boolean`、`Symbol`、`BigInt` 是原始类型，也是包装类型，可以调用属性和方法


**对象类型也分为两类**
- **构造器对象**：`Object`、 `Function`、`Date`、`Array`、`Error`、`RegExp`
- **单体内置对象**：`JSON`, `Math`, `arguments`, 全局对象


## 原始值和引用值

上面提到，原生对象数据类型分为两种：基本类型和对象类型。
- `javascript`基本数据类型包括`Undefined`、`Null`、`Boolean`、`Number`、`String`，ES6 新增了 `Symbol`、`BigInt` 共7种，
- 对象类型也称为复杂类型，在 `javascript` 中是 `Object`

![image-20210813093134267](https://gitee.com/FIF/pic-beg/raw/master/images/vue/image-20210813093134267.png)

## 原始值 vs 复杂值

### 存储方式

- **栈存储**

因为原始值**占据固定大小空间**，是简单的数据段，为了便于提升变量查询速度，将其存储在 **栈(stack)** 中；被引用或拷贝时，会创建一个完全相等的变量；

- **堆存储**

引用类型值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度，因此其存储在 **堆(heap)** 中，存储在变量处的值是一个指针，指向存储对象的内存处，多个引用指向同一个地址，会有“共享”情况，修改值相互影响。



::: tip
基本类型和引用类型不同，决定他们的访问方式和比较方式不同
:::

### 访问方式

- 按值访问

原始值作为不可细化的值进行存储和操作的，引用它们会转移其值

```js
var myString = 'foo';
var myStringCopy = myString;
var myString = null;
console.log(myString,myStringCopy);//null,'foo'
```

- 引用访问

引用值是通过引用进行存储和操作的，而不是实际的值。创建一个包含引用对象的变量时，其值是内存中的一个引用地址。

```js
var myObject = {};
var copyOfMyObject = myObject;//没有复制值，而是复制了引用
myObject.foo = 'bar';//操作myObject中的值
//现在如果输出myObject和copyOfMyObject，则都会输出foo属性，因为它们引用的是同一个对象
console.log(myObject,copyOfMyObject);//Object{foo="bar"}
```


**深入理解示例**

```js
let a = {
  name: 'Julia',
  age: 20
}

function change(o) {
  o.age = 24;
  o = {
    name: 'Kath',
    age: 30
  }
  return o;
}

let b = change(a);     // 注意这里没有new，后面new相关会有专门文章讲解
console.log(b.age);    // 第一个console
console.log(a.age);    // 第二个console
```

函数传参进来的 `o`，传递的是对象在堆中的内存地址值，通过调用 `o.age = 24`确实改变了 `a` 对象的 `age` 属性；把参数 `o` 的地址返回，将  `{name: "Kath", age: 30} ` 存入其中，最后返回 `b` 的值就变成了 `{name: "Kath", age: 30}`。而如果 `return` 去掉，那么 `b `就会返回  `undefined`

### 比较方式

原始值采用值比较，而引用值采用引用比较。引用值只有在引用相同的对象(即有相同的地址)时才相等。即使是包含相同对象的两个变量也彼此不相等，因为它们并不指向同一个对象

```js
var price1 = 10;
var price2 = 10;
var price3 = new Number('10');
console.log(price1 == price2);//true
console.log(price1 == price3);//true

var objectFoo = {same:'same'};
var objectBar = {same:'same'};
console.log(objectFoo == objectBar);//false
var objectA = {foo: 'bar'};
var objectB = objectA;
console.log(objectA == objectB);//true
```

### 动态属性

对于复杂值，可以为其添加属性和方法，也可以改变和删除其属性和方法；但简单值不可以添加属性和方法

```js
var str = 'test';
str.property = true;
console.log(str.property);//undefined　

```

## 数据类型检测

### 第一种判断方法：typeof

`typeof` 返回值是一个字符串，得到的值有：`'undefined'`、`'number`、`'string'`、`'boolean'`、`'symbol'`、`'bigint'`、`'object'`、`'function'`

```js
typeof 1 // 'number'
typeof '1' // 'string'
typeof undefined // 'undefined'
typeof true // 'boolean'
typeof Symbol() // 'symbol'
typeof BigInt(3) // "bigint"
typeof null // 'object'
typeof [] // 'object'
typeof {} // 'object'
typeof console // 'object'
typeof console.log // 'function'
```

上面有个特殊的地方，`typeof null` 会输出 `object`，这是 JS 存在的一个悠久 Bug，不代表 `null` 就是引用数据类型，并且 `null` 本身也不是对象。因此，`null` 在 `typeof` 之后返回的是有问题的结果，不能作为判断 `null` 的方法。如果你需要在 `if `语句中判断是否为 `null`，直接通过 `===null` 全等来判断就好。

此外还要注意，引用数据类型 `Object`，用 `typeof` 来判断的话，除了 `'function'` 会判断为 OK 以外，其余都是 `'object'`，是无法判断出来的，所以 `typeof` 应用于基本类型判断合适（null 除外）

### 第二种判断方法：instanceof

`new` 一个对象，那么这个新对象就是它原型链继承上面的对象了，通过 `instanceof` 我们能判断这个对象是否是之前那个构造函数生成的对象，这样就基本可以判断出这个新对象的数据类型。它适用于引用类型判断，不适合基本类型判断

```js
let Car = function() {}
let benz = new Car()
benz instanceof Car // true
let car = new String('Mercedes Benz')
car instanceof String // true
let str = 'Covid-19'
str instanceof String // false
```

实现 `instanceof`

```js
function myInstanceof(left, left) {
  if (typeof left !== 'null' && (typeof left === 'object' || typeof left === 'function')) {
    let proto = Object.getPrototypeOf(left)

    while (true) {
      if (proto === left.prototype) {
        return true
      } else if (proto === null) {
        return false
      } else {
        proto = Object.getPrototypeOf(proto)
      }
    }
  } else {
    return false
  }
}
// 验证一下自己实现的myInstanceof是否OK
console.log(myInstanceof(new Number(123), Number));    // true
console.log(myInstanceof(123, Number));                // false
```

**instanceof vs typeof**

- `instanceof` 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型；

- `typeof` 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了 `function` 类型以外，其他的也无法判断。

不管单独用 `typeof` 还是 `instanceof`，都不能满足所有场景的需求，而只能通过二者混写的方式来判断。但是这种方式判断出来的其实也只是大多数情况，较推荐下面的第三种方法

### 第三种判断方法：Object.prototype.toString

`toString()` 是 `Object` 的原型方法，调用该方法，可以统一返回格式为 `[object Xxx]` 的字符串，其中 `Xxx` 就是对象的类型。对于 `Object` 对象，直接调用 `toString()` 就能返回 `[object Object]`；而对于其他对象，则需要通过 `call` 来调用，才能返回正确的类型信息。

```js
Object.prototype.toString({})       // "[object Object]"
Object.prototype.toString.call({})  // 同上结果，加上call也ok
Object.prototype.toString.call(1)    // "[object Number]"
Object.prototype.toString.call('1')  // "[object String]"
Object.prototype.toString.call(true)  // "[object Boolean]"
Object.prototype.toString.call(function(){})  // "[object Function]"
Object.prototype.toString.call(null)   //"[object Null]"
Object.prototype.toString.call(undefined) //"[object Undefined]"
Object.prototype.toString.call(/123/g)    //"[object RegExp]"
Object.prototype.toString.call(new Date()) //"[object Date]"
Object.prototype.toString.call([])       //"[object Array]"
Object.prototype.toString.call(document)  //"[object HTMLDocument]"
Object.prototype.toString.call(window)   //"[object Window]"
```

从上面这段代码可以看出，`Object.prototype.toString.call()` 可以很好地判断引用类型，甚至可以把 `document` 和 `window` 都区分开来。

但是在写判断条件的时候一定要注意，使用这个方法最后返回统一字符串格式为 `[object Xxx]` ，而这里字符串里面的 `Xxx` ，第一个首字母要大写（注意：使用 typeof 返回的是小写），这里需要多加留意。

实现一个全局通用的数据类型判断方法

```js
function getType(obj){
  // toString 方法提取数据类型字符串，首字母大写
  return Object.prototype.toString.call(obj).replace(/^\[object (\S+)\]$/, '$1');  // 注意正则中间有个空格
}

getType([])     // "Array"
getType('123')  // "String" 
getType(window) // "Window" toString返回
getType(null)   // "Null"
getType(undefined)   // "Undefined" 
getType()            // "Undefined"
getType(function(){}) // "Function"
getType(/123/g)      //"RegExp"
```

### 第四种判断方法：构造器constructor

构造器 `constructor` 可以判断对象类型（包括包装类型），使用 `undefined`、`null` 会报错

```js
let s
s.constructor // VM297:1 Uncaught TypeError: Cannot read property 'constructor' of undefined

let num = 33
let str = '33'
let flag = false
let arr = new Array(33)

num.constructor === Number // true
str.constructor === String // true
flag.constructor === Boolean // true
arr.constructor === Array // true
```

## 数据类型转换

在日常的业务开发中，经常会遇到 `JavaScript` 数据类型转换问题，有的时候需要我们主动进行强制转换，而有的时候 `JavaScript` 会进行隐式转换，隐式转换的时候就需要多注意了。


### 强制类型转换

强制类型转换方式包括 `Number()`、`parseInt()`、`parseFloat()`、`toString()`、`String()`、`Boolean()`，这几种方法都比较类似，通过字面意思可以很容易理解，都是通过自身的方法来进行数据类型的强制转换。下面我列举一些来详细说明。

**Number() 方法的强制转换规则**

- 如果是布尔值，`true` 和 `false` 分别被转换为 1 和 0；
- 如果是数字，返回自身；
- 如果是 `null`，返回 0；
- 如果是 `undefined`，返回` NaN`；
- 如果是字符串，遵循以下规则：如果字符串中只包含数字（或者是 0X / 0x 开头的十六进制数字字符串，允许包含正负号），则将其转换为十进制；如果字符串中包含有效的浮点格式，将其转换为浮点数值；如果是空字符串，将其转换为 0；如果不是以上格式的字符串，均返回 `NaN`；
- 如果是 `Symbol`，抛出错误；
- 如果是对象，并且部署了 `[Symbol.toPrimitive]` ，那么调用此方法，否则调用对象的 `valueOf() `方法，然后依据前面的规则转换返回的值；如果转换的结果是 `NaN` ，则调用对象的 `toString() `方法，再次依照前面的顺序转换返回对应的值（Object 转换规则会在下面细讲）。

下面通过一段代码来说明上述规则。

```js
Number(true);        // 1
Number(false);       // 0
Number('0111');      //111
Number(null);        //0
Number(undefined);   // NaN
Number('');          //0
Number('1a');        //NaN
Number(-0X11);       //-17
Number('0X11')       //17
```

**Boolean() 方法的强制转换规则**

这个方法的规则是：除了 `undefined`、 `null`、 `false`、 `''`、 `0（包括 +0，-0）`、 `NaN` 转换出来是 `false`，其他都是 `true`。

```js
Boolean(0)          //false
Boolean(null)       //false
Boolean(undefined)  //false
Boolean(NaN)        //false
Boolean(1)          //true
Boolean(13)         //true
Boolean('12')       //true
```

### 隐式类型转换

- 如果类型相同，无须进行类型转换；
- 如果其中一个操作值是 `null` 或者 `undefined`，那么另一个操作符必须为 `null `或者 `undefined`，才会返回 `true`，否则都返回 `false`；
- 如果其中一个是 `Symbol `类型，那么返回 `false`；
- 两个操作值如果为 `string` 和 `number` 类型，那么就会将字符串转换为 `number`；
- 如果一个操作值是 `boolean`，那么转换成 `number`；
- 如果一个操作值为 `object` 且另一方为 `string`、`number` 或者 `symbol`，就会把 `object` 转为原始类型再进行判断（调用 object 的 valueOf/toString 方法进行转换）。

代码示例

```js
null == undefined       // true  规则2
null == 0               // false 规则2
'' == null              // false 规则2
'' == 0                 // true  规则4 字符串转隐式转换成Number之后再对比
'123' == 123            // true  规则4 字符串转隐式转换成Number之后再对比
0 == false              // true  e规则 布尔型隐式转换成Number之后再对比
1 == true               // true  e规则 布尔型隐式转换成Number之后再对比
var a = {
  value: 0,
  valueOf: function() {
    this.value++;
    return this.value;
  }
};
// 注意这里a又可以等于1、2、3
console.log(a == 1 && a == 2 && a ==3);  //true f规则 Object隐式转换
// 注：但是执行过3遍之后，再重新执行a==3或之前的数字就是false，因为value已经加上去了，这里需要注意一下
```

### '+' 的隐式类型转换规则

'+' 号操作符，不仅可以用作数字相加，还可以用作字符串拼接。仅当 '+' 号两边都是数字时，进行的是加法运算；如果两边都是字符串，则直接拼接，无须进行隐式类型转换。

除了上述比较常规的情况外，还有一些特殊的规则，如下所示。

- 如果其中有一个是字符串，另外一个是 `undefined`、`null` 或布尔型，则调用 `toString()` 方法进行字符串拼接；如果是纯对象、数组、正则等，则默认调用对象的转换方法会存在优先级，然后再进行拼接。
- 如果其中有一个是数字，另外一个是 `undefined`、`null`、布尔型或数字，则会将其转换成数字进行加法运算，对象的情况还是参考上一条规则。
- 如果其中一个是字符串、一个是数字，则按照字符串规则进行拼接。

下面还是结合代码来理解上述规则，如下所示。

```js
1 + 2        // 3  常规情况
'1' + '2'    // '12' 常规情况
// 下面看一下特殊情况
'1' + undefined   // "1undefined" 规则1，undefined转换字符串
'1' + null        // "1null" 规则1，null转换字符串
'1' + true        // "1true" 规则1，true转换字符串
'1' + 1n          // '11' 比较特殊字符串和BigInt相加，BigInt转换为字符串
1 + undefined     // NaN  规则2，undefined转换数字相加NaN
1 + null          // 1    规则2，null转换为0
1 + true          // 2    规则2，true转换为1，二者相加为2
1 + 1n            // 错误  不能把BigInt和Number类型直接混合相加
'1' + 3           // '13' 规则3，字符串拼接
```

整体来看，如果数据中有字符串，`JavaScript` 类型转换还是更倾向于转换成字符串

**Object 的转换规则**

对象转换的规则，会先调用内置的 [ToPrimitive] 函数，其规则逻辑如下：

- 如果部署了 `Symbol.toPrimitive` 方法，优先调用再返回；
- 调用 `valueOf()`，如果转换为基础类型，则返回；
- 调用 `toString()`，如果转换为基础类型，则返回；
- 如果都没有返回基础类型，会报错。

```js
var obj = {
  value: 1,
  valueOf() {
    return 2;
  },
  toString() {
    return '3'
  },
  [Symbol.toPrimitive]() {
    return 4
  }
}
console.log(obj + 1); // 输出5
// 因为有Symbol.toPrimitive，就优先执行这个；如果Symbol.toPrimitive这段代码删掉，则执行valueOf打印结果为3；如果valueOf也去掉，则调用toString返回'31'(字符串拼接)
// 再看两个特殊的case：
10 + {}
// "10[object Object]"，注意：{}会默认调用valueOf是{}，不是基础类型继续转换，调用toString，返回结果"[object Object]"，于是和10进行'+'运算，按照字符串拼接规则来

[1,2,undefined,4,5] + 10
// "1,2,,4,510"，注意[1,2,undefined,4,5]会默认先调用valueOf结果还是这个数组，不是基础数据类型继续转换，也还是调用toString，返回"1,2,,4,5"，然后再和10进行运算，还是按照字符串拼接规则
```

### 测试

```js
'123' == 123   // true
'' == null    // false
'' == 0        // true
[] == 0        // true
[] == ''       // true
[] == ![]      // true
null == undefined //  true
Number(null)     // 0
Number(undefined)     // NaN
Number('')      // 0
parseInt('');    // NaN
{}+10           // 10
let obj = {
    [Symbol.toPrimitive]() {
        return 200;
    },
    valueOf() {
        return 300;
    },
    toString() {
        return 'Hello';
    }
}
console.log(obj + 200); // 400
```
