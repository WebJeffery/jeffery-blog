---
title: 函数
date: 2021-01-11 15:03:03
permalink: /pages/ssfeewasweew
author: 
  name: jeffery
categories: 
  - javascript
  - 数据类型
tags: 
  - javascript
  - 数据类型
---

# 函数

## 函数定义

总共有4种定义函数的方式

- 函数声明语句：使用 `function` 关键字加函数名称，声明的函数会出现函数提升
- 函数表达式（匿名函数）：不会出现函数提升
- `Function` 构造函数：接收任意数量的参数，最后一个参数始终都被看成是函数体，而前面的参数是新函数的参数
- 箭头函数：`ES6` 新增函数


```js
// 函数声明
function funcname([arg1 [,arg2 [...,argn]]]){
    statement;
}

// 函数表达式
var functionName = function funcName([arg1 [,arg2 [...,argn]]]){
    statement;
}

// Function 构造函数
var sum = new Function('num1','num2','return num1 + num2');
//等价于
var sum = function(num1,num2){
    return num1+num2;
}

// 箭头函数
var functionName = ([arg1 [,arg2 [...,argn]]]) => {
    statement;
}
```

## 函数调用

`javascript` 一共有4种调用模式：

- 函数调用模式：函数中的 `this` 绑定到全局对象，严格模式下为 `undefined`
- 方法调用模式：函数中的 `this` 绑定到调用对象上
- 构造器调用模式：函数中的 `this` 绑定 `new` 新创建实例对象上
- 间接调用模式：改变 `this` 指向第一个参数

```js
// 函数调用模式
function add(x,y){
    console.log(this) // this 指向全局对象，严格模式下为 undefined
    return x+y;
}

var sum = add(3,4);


// 方法调用模式
var o = {
    m: function(){
        console.log(this); // this 指向 o
    }
};
o.m();//1


// 构造器调用模式
function fn(){
    this.a = 1;
};
var obj = new fn(); // this 指向 obj
console.log(obj.a);//1

// 间接调用模式
var target = {};
function sum(x,y){
  console.log(this)  // this 指向 target
    return x+y;
}
console.log(sum.call(target,1,2));//3
console.log(sum.apply(target,[1,2]));//3

```

## 函数属性和方法

### 属性

**length属性**

函数的 `length` 属性则表示形参个数，`arguments` 对象的 `length` 属性表示实参个数

```js
function add(x,y){
    console.log(arguments.length)//3
    console.log(add.length);//2
}
add(1,2,3);
```

**name 属性**

`name` 属性表示函数的名称

```js
function fn(){};
console.log(fn.name);//'fn'
```

`Function` 构造函数返回的函数实例，`name` 属性的值为 `“anonymous”`

```js
(new Function).name // "anonymous"
```

`bind` 返回的函数，`name` 属性值会加上 `“bound ”` 前缀

```js
function foo() {};
foo.bind({}).name // "bound foo"
(function(){}).bind({}).name // "bound "
```

**prototype属性**

每一个函数都有一个 `prototype` 属性，这个属性指向一个对象的引用，这个对象称做原型对象(prototype object)。每一个函数都包含不同的原型对象。将函数用做构造函数时，新创建的对象会从原型对象上继承属性

```js
function fn(){};
var obj = new fn;
fn.prototype.a = 1;
console.log(obj.a);//1
```

### 方法

继承 `Object` 的三个方法 `toString`、`toLocaleString`、`valueOf()`
#### apply()和call()

`apply()` 和 `call()` 调用函数，并改变函数中 `this` 的作用域指向

```js
window.color = "red";
var o = {color: "blue"};
function sayColor(){
    console.log(this.color);
}

sayColor();            //red
sayColor.call(this);   //red
sayColor.call(window); //red
sayColor.call(o);      //blue
```

在非严格模式下，使用函数的 `call()` 或 `apply()` 方法时，`null` 或 `undefined` 值会被转换为全局对象。而在严格模式下，函数的 `this`值始终是指定的值

```js
// 非严格模式
var color = 'red';
function displayColor(){
    console.log(this.color);
}
displayColor.call(null);//red

// 严格模式
var color = 'red';
function displayColor(){
    'use strict';
    console.log(this.color);
}
displayColor.call(null);//TypeError: Cannot read property 'color' of null
```

**call、apply 使用场景**

- 调用对象的原生方法
```js
Object.prototype.hasOwnProperty.call(obj, 'toString');// false
```

- 找出数组最大元素
```js
var a = [10, 2, 4, 15, 9];
Math.max.apply(null, a);//15
```

- 将类数组对象转换成真正的数组

```js
Array.prototype.slice.apply({0:1,length:1});//[1]
```

- 绑定回调函数的对象

```js
var o = {};
o.f = function () {
  console.log(this === o);
}
var f = function (){
  o.f.apply(o);
};

document.getElementById('btn).addEventListener('click', f);
```

#### bind()

`bind` 将函数绑定到某个对象，返回一个新的函数

```js
function f(y){
    return this.x + y; //这个是待绑定的函数
}
var o = {x:1};//将要绑定的对象
var g = f.bind(o); //通过调用g(x)来调用o.f(x)
g(2);//3
```

模拟实现 `bind` 函数
```js
Function.prototype.bind = function(context){
  var self = this,
      context = [].shift.call(arguments),
      args = [].slice.call(arguments);
  return function(){
    return self.apply(context,[].concat.call(args,[].slice.call(arguments)));
  }
}
```

## ES6 函数拓展

ES6标准关于函数扩展部分，主要涉及以下四个方面：参数默认值、`rest` 参数、扩展运算符和箭头函数
### 参数默认值

一般地，为参数设置默认值需进行如下设置

```js
function log(x, y) {
  y = y || 'World';
  console.log(x, y);
}
```

有了参数默认值，写法可以简化
```js
function log(x, y = 'World') {
  console.log(x, y);
}
log('Hello') // Hello World
```

指定了默认值以后，函数的 `length` 属性，将返回没有指定默认值的参数个数

```js
(function (a) {}).length // 1
(function (a = 5) {}).length // 0
(function (a, b, c = 5) {}).length // 2
```
### rest参数

用于获取函数的多余参数，不需要使用 `arguments` 对象了。`rest` 参数搭配的变量是一个数组，该变量将多余的参数放入数组中

```js
function push(array, ...items) {
  items.forEach(function(i) {
    array.push(i);
    console.log(i);
  });
}
var a = [];
push(a, 1, 2, 3);
```

函数的 `length` 属性不包括 `rest` 参数

```js
(function(a) {}).length  // 1
(function(...a) {}).length  // 0
(function(a, ...b) {}).length  // 1
```

::: warning
`rest` 参数之后不能再有其他参数
:::

```js
//Uncaught SyntaxError: Rest parameter must be last formal parameter
function f(a, ...b, c) {
  //todo
}
```

### 扩展运算符

扩展运算符是三个点 `(...)` 。它好比 `rest` 参数的逆运算，将一个数组转为用逗号分隔的参数序列

```js
console.log(...[1, 2, 3])// 1 2 3
console.log(1, ...[2, 3, 4], 5)// 1 2 3 4 5
```

用于函数调用
```js
function add(x, y) {
  return x + y;
}
var numbers = [4, 38];
add(...numbers) // 42
```

`Math.max` 方法简化
```js
// ES5
Math.max.apply(null, [14, 3, 77])

// ES6
Math.max(...[14, 3, 77])

//等同于
Math.max(14, 3, 77)
```

`push` 方法简化
```js
// ES5
var arr1 = [0, 1, 2];
var arr2 = [3, 4, 5];
Array.prototype.push.apply(arr1, arr2);

// ES6
var arr1 = [0, 1, 2];
var arr2 = [3, 4, 5];
arr1.push(...arr2);
```
### 箭头函数

箭头函数根据当前的词法作用域而不是根据 `this` 机制顺序来决定 `this`，所以，箭头函数会继承外层函数调用的 `this` 绑定，而无论 `this` 绑定到什么

```js
var test = () => {
    console.log(this.a);
}
//形式上等价于
var test = function(){
    console.log(this.a);
}

//实质上等价于
function fn(){
    var that = this;
    var test = function(){
        console.log(that.a);
    }
}

```

::: warning 箭头函数使用规则
- `this` 在箭头函数中被绑定，4种绑定规则中的无论哪种都无法改变其绑定
- 箭头函数不可以当作构造函数，也就是不可以使用 `new` 命令，否则会报错
- 箭头函数中不存在 `arguments` 对象, 用 `rest` 代替
- 不支持 `Generator` 函数
:::


## 高阶函数

 高阶函数指操作函数的函数，一般地，有以下两种情况

  1、函数可以作为参数被传递

  2、函数可以作为返回值输出

`javascript` 中的函数显然满足高阶函数的条件，在实际开发中，无论是将函数当作参数传递，还是让函数的执行结果返回另外一个函数，这两种情形都有很多应用场景。

### 函数作为参数传递

把函数当作参数传递，代表可以抽离出一部分容易变化的业务逻辑，把这部分业务逻辑放在函数参数中，这样一来可以分离业务代码中变化与不变的部分。其中一个常见的应用场景就是回调函数

**回调函数**

  在 `ajax` 异步请求的应用中，回调函数的使用非常频繁。想在 `ajax` 请求返回之后做一些事情，但又并不知道请求返回的确切时间时，最常见的方案就是把 `callback` 函数当作参数传入发起 `ajax` 请求的方法中，待请求完成之后执行 `callback` 函数

```js
var getUserInfo = function( userId, callback ){
  $.ajax( 'http://xx.com/getUserInfo?' + userId, function( data ){
    if ( typeof callback === 'function' ){
      callback( data );
    }
  });
}
getUserInfo( 123, function( data ){ 
  alert ( data.userName );
});
```

### 返回值输出函数

函数当作返回值输出的应用场景也有很多，封装一个类型判断方法

```js
var isType = function( type ){ 
  return function( obj ){
    return Object.prototype.toString.call( obj ) === '[object '+ type +']';
  }
};
var isString = isType( 'String' ); 
var isArray = isType( 'Array' ); 
var isNumber = isType( 'Number' );
console.log( isArray( [ 1, 2, 3 ] ) );    // 输出：true
```

### AOP（面向切面编程）


`AOP` 的主要作用是抽离跟核心业务逻辑无关的代码，比如日志统计、安全控制、异常处理等。这些功能抽离出来之后，再通过“动态织入”的方式掺入业务逻辑模块中。这样做的好处首先是可以保持业务逻辑模块的纯净和高内聚性，其次是可以很方便地复用日志统计等功能模块

在 `javascript` 中实现 `AOP` ，都是指把一个函数“动态织入”到另外一个函数之中。通过扩展 `Function.prototype` 来实现


## 函数柯里化

`currying` 又称部分求值。一个 `currying` 的函数首先会接受一些参数，接受了这些参数之后，该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保存起来。待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值

```js
  var currying = function (fn) {
    var args = [];
    //储存传到curring函数中的除了fn之外的其他参数，并储存到args函数中
    args = args.concat([].slice.call(arguments,1));
    return function () {
      if (arguments.length === 0) {
        return fn.apply(this, args);
      } else {
        //将fn中的参数展开，然后再储存到args数组中
        [].push.apply(args, arguments);
      }
    }
  };
  var cost = (function () {
    var money = 0;
    return function () {
      for (var i = 0, l = arguments.length; i < l; i++) {
        money += arguments[i];
      }
      return money;
    }
  })();
  var cost = currying(cost,100,200); // 转化成 currying 函数
  cost(100,200); // 未真正求值 
  cost(300);   // 未真正求值
  console.log((cost()));  // 求值并输出：900
  ```

  **反柯里化**

  反柯里化主要用于扩大适用范围，创建一个应用范围更广的函数。使本来只有特定对象才适用的方法，扩展到更多的对象。

`uncurrying` 的话题来自JavaScript之父Brendan Eich在2011年发表的一篇文章。以下代码是 uncurrying 的实现方式之一：

```js
Function.prototype.uncurrying = function () { 
  var _this = this;
  return function() {
    var obj = Array.prototype.shift.call( arguments );
    return _this.apply( obj, arguments );
  };
};
```

## 惰性函数

惰性函数表示函数执行的分支只会在函数第一次调用的时候执行，在第一次调用过程中，该函数会被覆盖为另一个按照合适方式执行的函数，这样任何对原函数的调用就不用再经过执行的分支了。


**函数重写**

由于一个函数可以返回另一个函数，因此可以用新的函数来覆盖旧的函数

```js
function a(){
    console.log('a');
    a = function(){
        console.log('b');
    }
}
```

惰性函数的本质就是函数重写。所谓惰性载入，指函数执行的分支只会发生一次，有两种实现惰性载入的方式


1、第一种是在函数被调用时，再处理函数。函数在第一次调用时，该函数会被覆盖为另外一个按合适方式执行的函数，这样任何对原函数的调用都不用再经过执行的分支了。代码重写如下

```js
function addEvent(type, element, fun) {
    if (element.addEventListener) {
        addEvent = function (type, element, fun) {
            element.addEventListener(type, fun, false);
        }
    }
    else if(element.attachEvent){
        addEvent = function (type, element, fun) {
            element.attachEvent('on' + type, fun);
        }
    }
    else{
        addEvent = function (type, element, fun) {
            element['on' + type] = fun;
        }
    }
    return addEvent(type, element, fun);
}
```

在这个惰性载入的 `addEvent()` 中，`if` 语句的每个分支都会为 `addEvent` 变量赋值，有效覆盖了原函数。最后一步便是调用了新赋函数。下一次调用 `addEvent()` 时，便会直接调用新赋值的函数，这样就不用再执行 `if`语句了

但是，这种方法有个缺点，如果函数名称有所改变，修改起来比较麻烦


 2、第二种是声明函数时就指定适当的函数。把嗅探浏览器的操作提前到代码加载的时候，在代码加载的时候就立刻进行一次判断，以便让 `addEvent` 返回一个包裹了正确逻辑的函数

```js
var addEvent = (function () {
    if (document.addEventListener) {
        return function (type, element, fun) {
            element.addEventListener(type, fun, false);
        }
    }
    else if (document.attachEvent) {
        return function (type, element, fun) {
            element.attachEvent('on' + type, fun);
        }
    }
    else {
        return function (type, element, fun) {
            element['on' + type] = fun;
        }
    }
})();
```