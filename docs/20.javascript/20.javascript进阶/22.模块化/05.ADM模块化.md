---
title: AMD 模块化
date: 2020-03-05 18:37:10
permalink: /pages/slwawlledef257cb
author: 
  name: jeffery
categories: 
  - javascript
tags: 
  - javascript
---

# AMD 模块化

AMD 是异步模块定义。异步强调的是，在加载模块以及模块所依赖的其它模块时，都采用异步加载的方式，避免模块加载阻塞了网页的渲染进度

`AMD` 作为一个规范，只需定义其语法 `API`，而不关心其实现。`AMD`规范简单到只有一个 `API`，即 `define` 函数

```js
define([module-name?], [array-of-dependencies?], [module-factory-or-object]);
```

- `module-name`: 模块标识，可以省略

- `array-of-dependencies`: 所依赖的模块，可以省略

- `module-factory-or-object`: 模块的实现，或者一个`JavaScript`对象


`define` 函数具有异步性。当 `define` 函数执行时，首先会异步的去调用第二个参数中列出的依赖模块，当所有的模块被载入完成之后，如果第三个参数是一个回调函数则执行；然后告诉系统模块可用，也就通知了依赖于自己的模块自己已经可用

 

## 加载

使用 `require.js` 的第一步，是先去官方网站[下载](http://requirejs.org/docs/release/2.3.3/minified/require.js)。下载后，假定把它放在js子目录下面，就可以加载了

```js
<script src="js/require.js"></script>
```

`HTML` 中的`script`标签在加载和执行过程中会阻塞网页的渲染，所以一般要求尽量将 `script` 标签放置在 `body` 元素的底部，以便加快页面显示的速度，还有一种方式就是通过异步加载的方式来加载 `js`文件，这样可以避免js文件对html渲染的阻塞

```js
<script src="js/require.js" defer async></script>
```

 

## 入口文件

`require.js` 在加载的时候会检查 `data-main` 属性，当 `requireJS`自身加载执行后，就会再次异步加载 `data-main` 属性指向的`main.js`。这个 `main.js` 是当前网页所有逻辑的入口，理想情况下，整个网页只需要这一个 `script` 标记，利用 `requireJS` 加载依赖的其它文件

```js
<script data-main="scripts/main" src="js/require.js"></script>
```

::: tip
在 `main.js` 中所设置的脚本是异步加载的。所以如果在页面中配置了其它`JS`加载，则不能保证它们所依赖的JS已经加载成功
:::

```js
<script data-main="scripts/main" src="js/require.js"></script>
<script src="js/other.js"></script>
```

【内部机制】

在 `RequireJS` 内部，会使用 `head.appendChild()` 将每一个模块依赖加载为一个 `script` 标签。`RequireJS` 等待所有的依赖加载完毕，计算出模块定义函数正确调用顺序，然后依次调用它们

 

## 模块

模块不同于传统的脚本文件，它良好地定义了一个作用域来避免全局名称空间污染。它可以显式地列出其依赖关系，并以函数(定义此模块的那个函数)参数的形式将这些依赖进行注入，而无需引用全局变量。`RequireJS` 的模块是模块模式的一个扩展，其好处是无需全局地引用其他模块

`RequireJS` 的模块语法允许它尽快地加载多个模块，虽然加载的顺序不定，但依赖的顺序最终是正确的。同时因为无需创建全局变量，甚至可以做到在同一个页面上同时加载同一模块的不同版本

一个文件应该只定义1个模块。多个模块可以使用内置优化工具将其组织打包

如果我们的代码不依赖任何其他模块，那么可以直接写入 `javascript` 代码

```js
//main.js
console.log(1);
```

![requirejs1](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_modular_requirejs1.png)

但这样的话，就没必要使用 `require.js` 了。真正常见的情况是，主模块依赖于其他模块，这时就要使用 `AMD` 规范定义的的 `require()`函数

```js
// main.js
require(['moduleA'], function(a){
　　console.log(a);
});
//moduleA.js
define(function(){
    return 1;
})
```

![requirejs1](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_modular_requirejs1.png)

　　这里抛出一个问题，为什么主模块使用的是 `require()`函数，而模块`moduleA` 使用 `define()` 函数呢？

因为 `define()` 定义的模块可以被调用，而 `require()` 不可以。主模块 `main.js` 是入口文件，需要调用别的模块，而不需要被别的模块调用，所以使用 `require()` 或`define()`都可以。而 `moduleA` 需要被调用，所以只能使用 `define()`

如果把 `moduleA.js` 中的 `define()` 方法改为 `require()` 方法，则返回 `undefined`

```js
// main.js
require(['moduleA'], function(a){
　　console.log(a);
});
//moduleA.js
require(function(){
    return 1;
})
```

![requirejs3](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_modular_requirejs3.png)

【简单的值对】

上面的模块 `moduleA`中，回调函数返回了一个数字。而实际上，模块可以有多种形式，比如一个简单的值对

```js
define({
    color: "black",
    size: "unisize"
});
```

返回的结果如下：

![requirejs4](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_modular_requirejs4.png)

【函数式定义】

如果一个模块没有任何依赖，但需要一个做 `setup` 工作的函数，则在`define()`中定义该函数，并将其传给 `define()`

```js
define(function () {
    //Do setup work here
    return {
        color: "black",
        size: "unisize"
    }
});
```

返回的结果如下：

![requirejs5](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_modular_requirejs4-20210718193638936.png)

【存在依赖的函数式定义】

如果模块存在依赖：则第一个参数是依赖的名称数组；第二个参数是函数，在模块的所有依赖加载完毕后，该函数会被调用来定义该模块，因此该模块应该返回一个定义了本模块的 `object`。依赖关系会以参数的形式注入到该函数上，参数列表与依赖名称列表一一对应

```js
//moduleA.js
define(['moduleB'], function(b) {
    var num = 10;
    return b.add(num);
    }
);
////moduleB.js
define({
    add: function(n){
        return n+1;
    }
});
```

![requirejs6](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_modular_requirejs6.png)

【命名模块】

`define()` 中可以包含一个模块名称作为首个参数

```js
//moduleA.js
define("moduleA",['moduleB'], function(b) {
    var num = 10;
    return b.add(num);
    }
);
```

　　这些常由优化工具生成。也可以自己显式指定模块名称，但这使模块更不具备移植性——就是说若将文件移动到其他目录下，就得重命名。一般最好避免对模块硬编码，而是交给优化工具去生成。优化工具需要生成模块名以将多个模块打成一个包，加快到浏览器的载入速度

 

## 路径配置

`html`中的 `base` 元素用于指定文档里所有相对 `URL` 地址的基础 `URL`，`requireJS` 的 `baseUrl` 跟这个 `base` 元素起的作用是类似的，由于 `requireJS` 总是动态地请求依赖的 `JS` 文件，所以必然涉及到一个 `JS` 文件的路径解析问题，`requireJS` 默认采用一种 `baseUrl + moduleID` 的解析方式，`requireJS` 对它的处理遵循如下规则：

1、在没有使用 `data-main` 和 `config` 的情况下，`baseUrl` 默认为当前页面的目录

2、在 `有data-main` 的情况下，`main.js` 前面的部分就是 `baseUrl`，比如上面的 `js/`

3、在有 `config` 的情况下，`baseUrl` 以 `config` 配置的为准

上述三种方式，优先级由低到高排列

`RequireJS` 以一个相对于 `baseUrl` 的地址来加载所有的代码。页面顶层`script` 标签含有一个特殊的属性 `data-main` ，`require.js` 使用它来启动脚本加载过程，而 `baseUrl` 一般设置到与该属性相一致的目录

```html
<script data-main="js/main.js" src="scripts/require.js"></script>
```

　　在模块章节的示例中，代码如下所示

```js
// main.js
require(['moduleA'], function(a){
　　console.log(a);
});
//moduleA.js
define(function(){
    return 1;
})
```

入口文件 `main.js` 依赖于 `moduleA` ，直接写成 `['moduleA']`，默认情况下，`require.js` 假定 `moduleA` 与 `main.js` 在同一个目录，即 `'js/moduleA.js'`，文件名为 `moduleA.js` ，然后自动加载

![requirejs7](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_modular_requirejs7.png)

使用 `require.config()` 方法，我们可以对模块的加载行为进行自定义。`require.config()`就写在主模块（main.js）的头部。参数就是一个对象，这个对象的 `paths` 属性指定各个模块的加载路径

下面在 `demo` 文件夹下新建一个 `test` 文件夹，并在 `test` 文件夹下新建一个 `moduleA.js` 文件，内容如下

```js
//moduleA.js
define(function(){
    return 2;
})
```

而在原来的js文件夹下，依然存在一个 `moduleA.js` 文件，内容如下

```js
//moduleA.js
define(function() {
    return 1;
});
```

当js文件夹下的 `main.js` 进行 `config` 配置时

```js
// main.js
require.config({
    baseUrl: 'test'
})
require(['moduleA'], function(a){
    console.log(a);
});
```
结果为2，说明识别的是 `'test/moduleA.js'` 文件

![requirejs8](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_modular_requirejs8.png)

当 `js` 文件夹下的 `main.js` 不进行 `config` 配置时

```
// main.js
require(['moduleA'], function(a){
    console.log(a);
});
```
结果为1，说明识别的是 `'js/moduleA.js'` 文件

![requirejs9](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_modular_requirejs9.png)

`RequireJS` 默认假定所有的依赖资源都是js脚本，因此无需在 `module ID` 上再加 `".js"` 后缀，`RequireJS` 在进行 `module ID` 到 `path` 的解析时会自动补上后缀 

如果一个模块的路径比较深，或者文件名特别长，比如`'js/lib/moduleA.min.js'`，则可以使用 `config` 配置对象中的 `paths` 属性

```js
// main.js
require.config({
    paths:{
        'moduleA':'lib/moduleA.min'
    }
})
require(['moduleA'], function(a){
    console.log(a);
});
//moduleA-min.js
define(function(){
    return 3;
})
```

　　结果为3

![requirejs10](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_modular_requirejs10.png)

要注意的是，这里的 `paths` 的 `'moduleA'` 设置的是 `'lib/moduleA.min'`，而不是`'js/lib/moduleA.min'`，是因为`requireJS`中的文件解析是一个`"baseUrl + paths"`的解析过程

在 `index.html` 的入口文件设置的是 `'js/main'`，所以 `baseURL` 是`'js'`。因此`'baseUrl + paths' = 'js/lib/moduleA.min'`

```html
<script src="require.js" data-main="js/main" defer async></script>
```

如果在 `config` 配置对象中设置了 `baseUrl`，则以此为准

```js
// main.js
require.config({
    baseUrl: 'js/lib',
    paths:{
        'moduleA':'moduleA.min'
    }
})
require(['moduleA'], function(a){
    console.log(a);
});
```

结果同样为3，`baseURL`是`'js/lib'`，`paths`是`'moduleA.min'`。因此`'baseUrl + paths' = 'js/lib/moduleA.min'`

![requirejs10](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_modular_requirejs10.png)

如果一个 `module ID` 符合下述规则之一，其`ID`解析会避开常规的`"baseUrl + paths"`配置，而是直接将其加载为一个相对于当前 `HTML` 文档的脚本：1、以 ".js" 结束；2、包含 URL 协议，如 "http:" or "https:"

如下所示，`require()` 函数所依赖的模块路径为 `'js/moduleA.js'`

```js
// main.js
require.config({
    baseUrl: 'js/lib',
    paths:{
        'moduleA':'moduleA.min'
    }
})
require(['js/moduleA.js'], function(a){
    console.log(a);
});
```

而该文件的代码如下，路径为 `'js/moduleA.js'`，而不是 `'js/lib/moduleA.min'`，所以，最终结果为1

```
//moduleA.js
define(function() {
    return 1;
});
```
一般来说，最好还是使用 `baseUrl` 及 `"paths"`, `config` 去设置 `module ID`。它会带来额外的灵活性，如便于脚本的重命名、重定位等。 同时，为了避免凌乱的配置，最好不要使用多级嵌套的目录层次来组织代码，而是要么将所有的脚本都放置到baseUrl中，要么分置为项目库/第三方库的一个扁平结构，如下

```
www/
    index.html
    js/
        app/
            sub.js
        lib/
            jquery.js
            canvas.js
        main.js
```

 

## CommonJS

`commonJS` 主要应用于服务器端编程，如 `nodejs`。使用打包工具`Browserify` 可以对 `CommonJS` 进行格式转换，使其可以在浏览器端进行

而 `require` JS支持一种简单包装 `CommonJS` 的方式，只要在 `commonJS` 代码的外层简单包裹一层函数，就可以在浏览器端直接运行

```js
define(function(require, exports, module) {

});
```

如果该模块还依赖其他模块，如依赖模块 `moduleA`，则代码如下

```js
define(['moduleA'],function(require, exports, module) {

});
```

`a.js` 和 `b.js` 的 `commonJS` 形式的代码如下

```js
// a.js
var a = 100;
module.exports.a = a;

// b.js
var result = require('./a');
console.log(result.a);
```

`index.html` 直接引用 `b.js` 会报错，提示 `require` 没有被定义

```html
<script src="b.js"></script> 
```

将 `a.js` 和 `b.js` 进行改造之后，代码如下

```js
// a.js
define(function(require, exports, module) {
    var a = 100;
    module.exports.a = a;
});

// b.js
define(function(require, exports, module) {
    var result = require('./a');
    console.log(result.a);
});
```

`index.html` 将入口文件设置为 `'js/b'`，则结果为100

```js
<script src="require.js" data-main="js/b" defer async></script>
```

 

## 懒加载

有如下例子，入口文件 `main.js` 代码如下

```js
// main.js
require(['a'], function(a){
    console.log('main');
    document.onclick = function(){
        a.test();
    }
});
```

所依赖的模块 `a.js` 的代码如下

```js
define(function(){
    console.log('a');
    return {
        test : function(){
            console.log('a.test');
        }
    }
})
```

　　在浏览器端执行时，即使不点击页面，浏览器也会下载 `a.js` 文件。这个性能消耗是不容忽视的

![requirejs12](https://pic.xiaohuochai.site/blog/JS_modular_requirejs12.png)

`AMD` 保留了 `commonjs` 中的`require`、`exprots`、`module`这三个功能。可以不把依赖罗列在`dependencies`数组中。而是在代码中用`require`来引入

重写后的代码如下

```js
// main.js
define(function(){
    console.log('main');
    document.onclick = function(){
        require(['a'],function(a){
            a.test();
        });
    }
});
//a.js
define(function(){
　　console.log('a');
    return {
        test : function(){
            console.log('a.test');
        }
    }
})
```

　　在浏览器端执行时，如果不点击页面，浏览器就不会下载a.js文件，这样就实现懒加载

![requirejs13](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_modular_requirejs13.png)

 

## 其他配置

　　在 `requireJS`中，除了路径配置之外，还有一些其他配置

【配置设置】

　　在前面的例子中，我们配置`requireJS`中的路径是通过入口文件`main.js`中的`config`对象来配置的。实际上，不通过入口文件，也可以进行requireJS的配置

1、在 `index.html` 文件嵌入 `javascript` 代码

在 `HTML` 文件中，加载 `requireJS` 文件之后，立即对 `requireJS` 进行配置，相当于将 `main.js` 文件变为内嵌的 `javascript` 文件

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
<script src="require.js"></script>
<script>
require.config({
    baseUrl: 'js/lib',
    paths:{
        'moduleA':'moduleA.min'
    }
})    
require(['moduleA'], function(a){
    console.log(a);
});
</script>
</body>
</html>
```

2、将配置作为全局变量 `"require"`在`require.js`加载之前进行定义，它会被自动应用

这里有一个问题是，如果 `require` 作为全局变量被提前定义，则`data-main`入口文件，是以baseUrl为基础进行设置的

[注意]使用 `var require = {}` 的形式而不是 `window.require = {}` 的形式。后者在IE中运行不正常

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
<script>
var require = {
    baseUrl: 'js/lib',
    paths:{
        'moduleA':'moduleA.min'
    }    
}    
</script>
<script src="require.js" data-main="../main"></script>
</body>
</html>
```

【shim】

`shim` 属性为那些没有使用 `define()` 来声明依赖关系、设置模块的"浏览器全局变量注入"型脚本做依赖和导出配置，即加载非规范的模块

举例来说，`underscore` 和 `backbone` 这两个库，都没有采用 `AMD` 规范编写。如果要加载它们的话，必须先定义它们的特征。具体来说，每个模块要定义
（1）`exports`值（输出的变量名），表明这个模块外部调用时的名称；
（2）`deps`数组，表明该模块的依赖性

通过如下配置后，现在可以通过 `_` 调用 `underscore` 的api，使用`Backbone`来调用`backbone`的api

```js
　　require.config({
　　　　shim: {

　　　　　　'underscore':{
　　　　　　　　exports: '_'
　　　　　　},
　　　　　　'backbone': {
　　　　　　　　deps: ['underscore', 'jquery'],
　　　　　　　　exports: 'Backbone'
　　　　　　}
　　　　}
　　});
```


 

## 插件

`require.js` 还提供一系列[插件](https://github.com/jrburke/requirejs/wiki/Plugins)，实现一些特定的功能

【dom ready】　

`RequireJS` 加载模块速度很快，很有可能在页面 `DOM Ready` 之前脚本已经加载完毕。需要与 `DOM` 交互的工作应等待 `DOM Ready`。现代的浏览器通过 `DOMContentLoaded` 事件来知会

但是，不是所有的浏览器都支持 `DOMContentLoaded`。[domReady模块](https://raw.github.com/requirejs/domReady/latest/domReady.js)实现了一个跨浏览器的方法来判定何时 `DOM`已经`ready`

```js
// main.js
require(['domready!'], function(){
    console.log('ready');
});
```

【text】

[text插件](https://raw.github.com/requirejs/text/latest/text.js)可以用来加载如 `.html`、`.css` 等文本文件，可以通过该插件来实现完整组件(结构+逻辑+样式)的组件化开发

```js
require(["some/module", "text!some/module.html", "text!some/module.css"],
    function(module, html, css) {
    }
);
```